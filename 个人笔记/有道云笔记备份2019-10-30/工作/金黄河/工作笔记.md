# ==03.03==

## ping命令
- ping IP地址  有回复则表示可以连接上该ip


## 使用SVN
- site-1.8.22 解压到eclipse\jee-2018-12\eclipse\dropins
    - site-1.6.18连接不上
- 在show-view中连接到公司的svn服务器：https://192.168.1.221:8443/svn/cymz
- svn检出和导出的区别：https://blog.csdn.net/qq_39056805/article/details/80504494
- 检出到eclipse的工程如果报错，删除后从工作空间重新导入一下
- 注意：我安装了一个ftl的插件，svn就不显示了，卸载了就又显示了。


## Navicat Premium
- Navicat是一套数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。Navicat 是以直觉化的图形用户界面而建的，可以安全和简单地创建、组织、访问并共用信息。 
- Navicat Premium 是 Navicat 的产品成员之一，能简单并快速地在各种数据库系统间传输数据，或传输一份指定 SQL 格式及编码的纯文本文件。其他功能包括导入向导、导出向导、查询创建工具、报表创建工具、资料同步、备份、工作计划及更多。 
- 解压入职文件中的Navicat Premium 12，到D盘
- Navicat Premium基本使用 https://blog.csdn.net/yangchenju/article/details/80633055


## 前端样式框架
- layui 
- bootstrap


## 今日工作
1. 使用SVN，检出system文件
2. **安装lombok插件**
    - https://blog.csdn.net/weixin_42289193/article/details/80984678?tdsourcetag=s_pcqq_aiomsg
        - 最后一步不用改，改了运行不了eclipse。回头再研究！！！？？？
3. 在len-web/ resources application-test.yml 20....里面 看到数据库连接地址，此应用的端口8888    用Navicat访问里面的jdbc地址，把库复制到自己的mysql里。
4. 在len-sys里写控制器，写页面，执行增删改查


---

# ==03.04==


## 构思
- 增 查 删 改
    1. 查询 显示所有的基本信息 手机号 姓名 -----跟着 查看详情 删除 
    增加按钮在查询页面最低，点击后可进入增加页面  查看详情后可以修改保存
    2. 增加页面 请求 hwl/add，控制器转发进入增加页面，页面用html，用ajax提交，成功则返回弹窗，失败也返回弹窗(异常处理)
- **步骤**：页面-控制器-service-实体类-mapper-写入数据库


## 建表
- 来电信息表---基础表
    ```sql
    create table my_user (
        uid int auto_increment primary key comment '用户id', ---主键
        phone varchar(20) comment'来电号码',
        phone_home varchar(20) comment'归属地',
        phone_time varchar(20) comment'来电时间'，
        username varchar(20) comment'姓名',
        phone2 varchar(20) comment'联系电话',
        is_secrecy int default 2 comment'是否保密',     ----默认2否      1是2否
        home varchar(50) comment'家庭住址',
        pid varchar(20) comment'外键表单编码'
    ) default charset=utf8;
    ```
    - **pid:表单编码的设计**：
        - 点击新增时，发出请求，响应过来的页面中 同时返回当前的时间毫秒值...--先不管重复，让not null 即可，重复就走异常处理
        - 点击保存时：毫秒值同时存进`来电信息表`的外键和`表单信息`的主键
- 表单信息表---详情表
    ```sql
    create table my_pp(
        pid varchar(20) primary key comment'表单编码',    ----主键
        form_home varchar(20) comment'表单来源',        ----单选
        nature varchar(20) comment'性质分类',            ----单选
        content varchar(20) comment'内容分类',            ----不知道咋选，不管
        title varchar(20) comment'标题',
        area varchar(20) comment'事发区域',
        event varchar(20) comment'大事记',
        time int default 0 comment '重复次数',        ----默认值0
        branch int comment'线路',                    ----1-18    0=无线路
        detail varchar(200) comment'详细内容',
        mode int comment'回复方式',                    ----1当场回复 2转办单位
        answer varchar(200) comment'答复信息'
    )default charset=utf8;
    ```


## 记录
1. 毕哥说实体类重写加上equals and HashCode,他说他们老师说的，也不知道为啥

---


# ==03.05==


## 今日工作
1. 创建数据库
2. 创建实体类
3. 画前端页面
4. 缕开发步骤

---


# ==03.06==


## 今日工作
1. 完善前端页面
2. 


## 记录
1. lenos手脚架有readme可以看


---

# ==03.07==

## 更改
- 表单详情表是主表，来电信息表是副表。

## 毕哥补充要求
1. 来电号码和联系电话要同步显示，是一样的。
2. 新增页面如果来电号码输入后，失去焦点，查看数据库有没有这条数据，有的话就显示他的相关信息，没有就继续添加
3. 表单编码是字母＋数字
4. 线路是多选，当选择无后前边的要全部清空-----jQuery
5. 表单来源和性质分类是在数据库基础表里的，建基础表。
6. 杜哥补充：一个用户可以有多个工单，想想根据什么查询


## 基础表设计
1. bid
2. form_home：表单来源---全部存入，取的时候按照逗号拆分
3. nature：性质分类---全部存入，取的时候按照逗号拆分
3. form_codeid：表单编码id，每次请求时访问，加1后存入。


## Springboot的properties和yml两种配置文件
> https://www.cnblogs.com/zslli/p/8717483.html
- 这是两种不同的格式，如果两个格式同时存在，则先读properties
    - 在properties文件里面的 “ .”  连接在yml文件里面全部换成 "：" 进行连接，并且每一级之间必须换行，在第二级开始应该进行一个Tab键的缩进，当然如果是同级的就不需要进行缩进
    - 在yml文件里面如果是需要进行赋值那么必须是要在 "：" 后面进行一个空格键的缩进
    - 在yml文件里面所有的配置，**相同级别只能出现一次**，比如我们使用了spring这个级别，那么我们在后边进行spring级别的配置的时候就必须在这个地方进行，不能在写一个spring级别
- yml文件的好处：天然的树状结构，一目了然，实质上跟properties是差不多的。官方给的很多demo，都是用yml文件配置的。


## 表单编码设计
1. 表单编码需要在请求新建页面的时候显示


## 今日工作
1. 上午修改增加数据，改成两个表保存，完善了从前端到数据库的那几个类，现在看着不那么乱了。
2. 新接触了layui、easyui这几个词。
3. 做了个基础表，想做编码卡住了，感觉需要学习一下freemarker
4. 知道了yml，稍了解freemarker

## 复习：
- controller-->service-->serviceimpl-->mapper.java-->mapper.xml
- https://blog.csdn.net/congweijing/article/details/82499627

---

# ==03.08==

## FreeMarker的2种注释方式：
- a. **叹号** <!-- 注释 -->
    发布之后，客户端可以看到注释内容。会执行注释内的代码，比如遍历等，如果写错也会报错。
- b. **井号** <#-- 注释 -->
    发布之后，客户端看不到注释内容。不会执行注释内的代码，注释内的代码写错了也没事


## 表单编码整体设计
1. 添加一个编码的基础表存字母和数字
2. 字母固定是"DTXF-"，数字是每天归零
3. 判断数字每天归零的依据，可以再在基础表存一个日期，一旦访问

## 从数据库中获取下拉选内容
- 同时查两个下拉选的内容
- 用list<map<>>接收
- list里两个元素分别是两个下拉选的名字，map里key是


---

# ==03.10==
## 今天不上班，刚搬完家

## 文本框同步输入
- 代码：
    <script type="text/javascript">
        window.onload=function(){
            var one=document.getElementById("one");
            var two=document.getElementById("two");
            one.onkeyup=function(){
                two.value=this.value;
            }
        }
    </script>

## FreeMarker遍历list
- 代码
    ```
    <#list options as option> 
        <option>${option.formSrc}</option>
    </#list>
    ```
- 注意的是，虽然options是绑定名，但是它不加${}，而是在遍历元素上加${}。


## Freemarker for循环--输出多选/单选
- 代码1：
    ```
    <#list min..max as i>    
        <li>${i}</li>
    </#list>
    从min开始，每次迭代1，到max结束。如果min是1，max是5，则会输出1、2、3、4、5
    ```
- 代码2：
    ```
    <#list 1..totality as i>
    totality为后台绑定转发数据绑定名
    ```

## freemarker 数字输出中的逗号问题
- 加?c：${xxx?c}


## 将复选框保存到数据库的方法
#### 方法一   后端实现
- 实体类加个属性
    一个用来接收请求参数，数组类型
    一个用来保存到数据库，字符串类型
    两个属性之间进行数组和字符串的转换，用循环实现转换
- 代码一：数组转字符串代码：
    ```java
    String[] arr ={"1","2","3"};
    StringBuilder sb = new StringBuilder();
    for(int i = 0;i<arr.length;i++){
    sb.append(arr[i]);
    sb.append(",");     逗号隔开
    }
    String str = sb.toString();
    System.out.println(str);    //123
    缺点是最后还有个逗号，还得处理掉
    ```
- 代码二：毕哥代码
    ```java
    //将数组转换成list再转换成字符串，逗号好看一些， 也不用使用StringBuilder和遍历
    //String list =Arrays.asList(arr).toString();
    //substring截取指定范围的字符串，去掉[]
    //System.err.println(list.substring(1,list.length()-1));
    ```
- 代码三：Arrays.toString();
    ```java
    String[] str1 = {"wo","ni"};
    System.out.println(Arrays.toString(str1));
    ```
#### 方法二   前端实现
- https://blog.csdn.net/wodetian1225/article/details/80684617
- 存入：设置一个隐藏框，name为提交的参数名，value为拼接的字符串，点击复选框就会触发事件让复选框的值拼接在字符串中。
- 取出：看网址
#### 方法三 后端String接收
 - 后端用String接收，接收到的是自动完成了逗号分隔的字符串

---

# ==03.11==


## Stringbuiler和String的互转
- String类转换为StringBuiler类
    ```java
    String s = "hello";
    StringBuilder sb = new StringBuilder(s);
    ```
- StringBuilder类转换为String类
    ```java
    StringBuilder sb = new StringBuilder();
    sb.append("abc").append("efg");
    String s = sb.toString();
    ```


## 复选框的点击事件，看addnew.ftl


## 外键设计
- 可以是表单编码，表单编码一定是唯一的，并且可以从页面获取到
- 可以是uid：不重复，**先插入附表**，然后通过**查找**数据库现在的id值，赋给主表外键，**然后插入主表**
        这个比较合理，可以提现主附表关系
- 不可是来电号码：号码设置成不可更改，也不必更改，但是可以重复，不便于关联查询。


## 构思查询和详情显示
- 需求：一个号码可以有多个表单(工单)
- 简略表显示来电号码、姓名、表单编码、表单来源、性质分类、线路。---按照来电号码排序
    - 每个号码的来电时间不一样，联系电话可能也不一样，万一换号了，姓名也不一样。所以来电信息表和表单详情表的数据应该是一对一的关系，利用uid外键对应
- 查询根据id关联
- 简略表的每条数据后面跟着
    - 添加：添加的时候进入添加页面，来电信息显示之前的，表单详情为空
    - 详情/编辑：查看详情，查看详情时可以修改，
        - 详情页面注意：
            - 来电号码不可更改
            - 有’修改并保存‘的按钮
            - 有’删除‘按钮，删除是删除来电信息和表单详情两处数据都删除
    - 删除：删除和详情页的一样，是删除来电信息和表单详情两处数据都删除
- 简略表右上角有‘新建’按钮，进入新建页面
- 点击删除，根据id删除


## layui入门
- 官网：www.layui.com
- 视频：哔哩哔哩layui视频教程--后盾人
#### 模块和引入
- layui模块：
    - 官网有内置模块，比如layer、laydate、layim、table(数据表格，不是静态表格)
- 分模块就是分别引入，不分模块就是一下全引入
- 引入模块
    ```
    layui.use(['layer', 'form'], function(){      方括号内是引入模块
        var layer = layui.layer
        ,form = layui.form;      一般声明的变量和引入的模块名是一样的
        ......
    ```
    - 非模块化方式不用引入模块，即不用写：layui.use()
#### 引入文件
- layer依赖于JQuery，要先引入JQuery再引入layer
- layui引入文件：
    1. 下载包中的layui文件夹完整复制到项目中
    2. 引入layui目录中的layui.js
    3. 引入layui/css目录中的layui.css
    提供样式和效果的支持。注意css用<link>引，js用<script>引


## 异步提交--回显设计
- 每个可输入来电号码的页面都要有回显事件
- 只有输入手机号数据回显的时候才用到异步提交
- 输入手机号，失去焦点事件，根据手机号查询所有相关数据，每次的来电信息和表单详情都铺到页面上


## 待完善
- 表单编码不能重复，回退后保存会保存重复的表单编码，涉及到异常处理
- 字符串和字符串数组的相互转换


## lenos-Debug
- 毕哥说，只要不改方法名，什么的， 在方法内改东西，都不用重启


---

# ==03.12==


## 跳转页面的几种方式
> https://www.cnblogs.com/gh0408/p/6323631.html

- window.location.href    跳转
- window.open    在新窗口打开
#### location.href主要用法
```js
javascript中的location.href有很多种用法，主要如下
    self.location.href="/url" 当前页面打开URL页面
    location.href="/url" 当前页面打开URL页面
    windows.location.href="/url" 当前页面打开URL页面，前面三个用法相同。
    this.location.href="/url" 当前页面打开URL页面
    parent.location.href="/url" 在父页面打开新页面
    top.location.href="/url" 在顶层页面打开新页面
```
#### layui数据表格按钮的点击跳转
- 好像只能通过js来实现跳转，把参数写在地址后面
- 路径可以是绝对路径，也可以是相对路径
    绝对 URL - 指向另一个站点（比如 href="http://www.example.com/index.htm"）
    相对 URL - 指向站点内的某个文件（href="index.htm"）
    锚 URL - 指向页面中的锚（href="#top"


## 遍历子级节点
- 代码
    var select = document.getElementById('select');
    var options = select.getElementsByTagName('option');
    for(var i = 0;i<options.length;i++){
            alert(options[i].nodeName);//OPTION
        }


---

# ==03.13==


## 前端传的数字类型多选保存和取出完整方案
- 保存：数组传入，实体类两个属性接收，保存的时候用Array.toString将数组转成字符串保存进去，不用截取
- 取出：直接传出字符串形式，读取到的绑定值可以自动识别为数组，并且遍历出来--遍历的前提是字符串一定要有中括号


---

# ==03.15==

## layui时间选择器
```
layui.use('laydate', function(){
      var laydate = layui.laydate;
      laydate.render({
            elem: '#test',//这里是input的id
            type: 'year'
          });
})
```
- elem是做为日期选择器的input的id。
    - 比如：<input type="text" class="layui-input" id="test" placeholder="yyyy">


## jq和js不能混用
- 代码
    ```js
    var year = new Date().getFullYear(); //获取当前年份
    for(var i=year-2;i<year+8;i++){
        var op = $("<option></option>");//声明元素
        op.html(i+"年");
        $("#sel2").append(op);
        if(i==year){
        op.attr("selected","selected");
        }
    }
    ```
- op是jq对象，所以不能用op.selected=true;来定义
- 百度：只有jquery对象才能使用jquery定义的方法，普通的dom对象一般可以通过$()转换成jquery对象。
    - 由于jquery对象本身是一个集合。所以如果jquery对象要转换为dom对象则必须取出其中的某一项，一般可通过索引取出。
    - 如：$("#msg")[0]，$("div").eq(1)[0]，$("div").get()[1]，$("td")[5]这些都是dom对象，可以使用dom中的方法，但不能再使用Jquery的方法。
    - 但是 没有索引的话，$("#msg"),不能使用dom方法。


## 小项
- lenos${} 如果页面代码存在这样的，里面不写东西，就会报404，加注释也没用。可能是lenos里集成的freemarker的问题


# ==03.18==

## 预算-设置关联下拉选的默认值
- ${"下拉选选择器"}.val();  val中填写已经存在的值，就是**设置默认值**
- layui.use() 就相当于$(function(){})


## 列表的多选框
- 因为是多选框，所以获取数据的时候是数组的形式


## 弹出页面的效果
> 弹出页面--layer，回头研究

- 代码：
    ```
    function outUrl(title,url) {
        var perContent = layer.open({
            type:2,
            title: title,
            content: url,
            area: ['100%', '100%'],
            maxmin: true,            //最大化按钮
            anim:3,                    //动画
            shade: [0.8, '#393D49'],//遮罩层
            end: function(){
            }
        });
        layer.full(perContent);
    }
    ```
- 调用 outUrl("",url)即可实现; 
    - 他封装了layer.open和layer.full


## 下拉选
- disabled="disabled"    一旦设置disabled="disabled" 就改不了颜色了
- layui的下拉选如果值为"" ，就会显示灰色的 - '请选择'


## ajax的url
- 绝对路径：/端口号之后的内容
- 相对路径：不加/，从当前路径所在目录后开始写


## 关于关闭弹出层
- 代码：关闭弹出层并刷新父页面
    ```js
    window.parent.location.reload(); //刷新父页面
    var index = parent.layer.getFrameIndex(window.name); //获取窗口索引
    parent.layer.close(index);  // 关闭layer
    ```

## layui的数据表格分页
-  后台接收要接收请求参数，默认是：page limit，然后处理，sql为limit(x,y)分页查询
    这两个参数名可以改。看文档-数据表格-异步数据接口，里面其实都说了，一直没仔细看


# ==03.19==
## 关于数据表格的一系列代码，可以在budgetList.ftl？html回顾


## 数据表格重载
#### 刷新
- 代码：点击刷新则刷新表格
    ```js
    $('#refresh').on('click', function () {
            miniTable.reload()
        });
    ```
- miniTable是给表格实例声明的变量：var miniTable=table.render({...
- 代码二：也可以在table.render({...      里边加id属性，然后执行重载
    table.reload('testReload',{})    这个代码在https://www.layui.com/demo/table/reload.html有
#### 查询
- 代码：https://www.layui.com/demo/table/reload.html
    ```
    var $ = layui.$, active =..........
    $(this).data('type')  这个$()应该就是内部的jQuery了，所以这两部分代码是要做好先后顺序的
        这里的data('type')是搜索按钮的属性：data-type="select"  应该是因为内部的jquery所以data-才不写的，改了就错了
    ```
- 这个type对应active里的方法，所以要对应好
#### `var $ = layui.$`
 - 意思是：使用内部jQuery
 - 见文档：https://www.layui.com/doc/base/faq.html


## 命名
- 变量命名不能加-，前后端都不能加


## ajax请求状态码为canceld的问题
- 期间发现一个.js的响应状态吗也是canceld
- 有时保存点立即提交，页面不跳转，但是也保存了，没弹窗，也没关闭层
- **原因**：监听表单提交事件中，用了ajax，ajax请求和form表单提交发生了冲突
    - https://www.jianshu.com/p/719c2a2da406
    - ajax请求时，有另外一个请求变更了当前的URL，导致当前正在执行的ajax进求进行中止操作。中止后该请求的状态码将为canceled。
    - 而URL发生变更的原因是：Form表单的提交操作和表单中按钮的click事件同时发生了调用，其中按钮的click事件触发导致当前url发生了变更。
    - 我没深入理解，但是我突然想到了监听事件中注掉的return false;
    - 尽管这里的表单没有写提交地址，但或许他也是有提交的操作的，或许就是这个提交操作，和ajax对url产生了冲突。导致了错误
- **解决方法一**：把监听提交事件中最后的return false写上；
- **解决方法二**：如果不用layui，还有个：Ajax请求中的async:false/true
    - https://www.cnblogs.com/mmzuo-798/p/7098979.html
    1. async. 默认是 true，即为异步方式，$.ajax执行后，会继续执行ajax后面的脚本，直到服务器端返回数据后，触发$.ajax里的success方法，这时候执行的是两个线程。
    2. async 设置为 false，则所有的请求均为同步请求，在没有返回值之前，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。
- 需要注意的是：form表单的return false 是js本身就有的，作用是阻止表单跳转，但是不会影响表单的提交
#### 3.20补充：关于ajax和form表单的提交跳转问题
- https://blog.csdn.net/c782699991/article/details/78529604
- form表单在点击提交的时候回自己提交并刷新当前页面，这也是一种跳转。当前页面的数据会清空，如果在layui监听表单中return false，就不会跳转，即不会刷新当前页面，当前页面的写好的数据也不会被清空。
- layui的监听表单提交事件，应该也封装了这个刷新效果，这样做更符合本身表单提交带来的刷新效果，同时也可以让我们返回ture或false来决定是否阻止刷新(跳转)
    - 因为按说提交按钮是button而不是submit的话，是不会有自动刷新当前页的效果的，但是layui可能封装了监听事件让表单提交，


---

# ==03.21==


## 民政：导入导出功能


## Java泛型<? extends T>和<? super T>
 - https://zhidao.baidu.com/question/646868566975781205.html


## 命名不规范：bypage 整张表
有不少没用的代码，冗余的代码，还没有注释


---

# ==03.22==


## easyExcel(ExcelUtil)
#### @ExcelProperty注解：
- 导出时：
    - index经过我的测试，其实是代表的优先级：
    相同的数字按照出现的先后顺序写在excel中
    不同的按照大小顺序先后写在excel中(不会有空列)
    不写的不会被写在excel中
    - value注解：如果不写则excel本列的标题空白
- 导入时：
    - readExcel()方法，根据表头的顺序和注解中index的值来对应。
    表头是第一个，就对应index=0的。如果存在多个index=0，则把数据给最后一个index为0的属性


---

# ==03.27==


## layui数据表格的筛选过滤小工具
- 如果本列没有field:属性，那么不会在过滤项中。过滤只会过滤有field属性的项 
- 如果想要让过滤，可以随便写个field
        比如操作列，肯定是没有对应的后台属性的，可以随便写个field，就可以参与筛选过滤了


## 什么是layui自动化渲染和方法级渲染
 - ？？？？


# ==03.28==


## 刷新按钮重载表格改进
- 代码：
    ```
    $('#refresh').on('click', function () {
        $('#select1').val('');
        $('#select2').val('');
        table.reload('lowIncomeList', {
            where: {
                select1: null,
                select2: null
            }
        });
    });
    ------去掉var miniTable = table.render
    ```


## 回车事件触发重载查询(兼容了不同的浏览器)
    ```
    document.onkeydown = function (e) {
        var theEvent = window.event || e;
        var code = theEvent.keyCode || theEvent.which;
        if (code == 13) {
            $(".select .select-on").click();
        }
    };
    ```
    

## e = e || window.event
> 为了实现多种浏览器兼容。https://www.jianshu.com/p/e8a6fad0f7bc

- e存在就用e不存在就用windon.event。假如e没初始化，结果就为window.event，否则还是原来的e，利用|| 的短路行为来给e初始化
- 写全：https://www.jianshu.com/p/e8a6fad0f7bc
    ```
    function(event){
        var e=event?event||window.event;
    }
    如果存在event,那么var e=event;而如果不存在event，那么var e=window.event.
    ```


## & | 和 && ||
- **&、|** 单个的逻辑运算符会将左右两个表达式都进行运算得出布尔值，再进行运算。
- **&&** 短路与，若左边表达式为false则不会对右边的表达式进行判断，因为结果必为false；
- **||** 短路或，若左边表达式结果为true则不会对右边的表达式进行判断，因为结果必为true。
- **短路的逻辑运算符相当于普通的逻辑运算符效率更高效**。


---

# ==03.31==

## mybatis: <where>标签
- 不用where标签：
    ```
    where 1=1
    <if test="name!=null and name!=''">
        and arg1like '%${arg1}%'
    </if>
    ```
- 用where标签：
    ```
    <where>
        <if test="name!=null and name!=''">
            and arg1like '%${arg1}%'
        </if>
    </where>
    ```

## 杂
- 控制器：修改方法名：table()
        listTool参数传给getAmount()
- 业务层：删除判断，接收参数
- 映射：去掉多余注释，添加语句：
    ```xml
    <where>
         <if test="select1!=null and select1!=''"> and XXXXXX like '%${select1}%'</if>
         <if test="select2!=null and select2!=''"> and XXXXXX like '%${select2}%'</if>
    </where>
    ```
- 25已完成：预算 爱心午餐 

#### 明天看公司test包下的mapper包
- 我删了，空的。------蓝色加号，预算的改名了，主机是不是不会删除那个，删了吧问徐哥

#### lenos
- file文件夹的绝对路径为/file，直接在端口号之后


---

# ==04.03==


## Excel传到后台存到数据库中的数值错误问题
- 例子：导入Excel表格，身份证号码如果是数值类型的话，是大于int的，一路传到数据库好像会经过int和long之间的转换，导致数值在转换过程中产生错误(应该和int的溢出有关)
- 解决办法，将其转换为文本格式，并且身份证本身就不是数值，所以应当用文本格式



# ==04.04==


## layui重新渲染
- 实例：数据表格的头工具栏'上传'按钮用upload模块监听，当表格重载后，按钮其实也被刷新了，而upload模块绑定的还是原先的按钮，虽然看着一摸一样，但是经过刷新后的按钮已经不是第一次绑定监听的按钮了
- 解决办法：每次数据表格重载都重新渲染一次upload监听
    - 可用function方法封装，然后再所有重载操作中都调用一次方法。


## layui的`var $ = layui.$`
- 也可以写为：`var $ = layui.jquery;`
- 表示使用layui内置的JQuery
- 举例：
    ```js
    //layui事件监听后的触发操作
    var $ = layui.$, active = {
        //重载查询功能
        select: function(){//select是type对应的值
            var select1 = $('#select1').val();
            var select2 = $('#select2').val();
            //执行重载
            table.reload('tableOne', {
                page: {
                  curr: 1 //重新从第 1 页开始
                },
                where: {
                  select1:select1,
                  select2:select2,
                }
            });
            //重新渲染upload实例
            upup();
        },//不同事件用逗号隔开
        
        //刷新按钮重载表格
        refresh: function(){
            console.log(555);
            $('#select1').val('');
            $('#select2').val('');
            table.reload('tableOne', {
                where: {
                    select1: null,
                    select2: null
                }
            });
        }
    };
    
    /* 监听选择器中的点击事件(如果选择器写不过来，可以写多个，
                  写多个只有选择器的内容不一样，里面都一样，也可以绑定其他事件) */
    $('.select .layui-btn').on('click', function(){
        var type = $(this).data('type');
        active[type] ? active[type].call(this) : '';
    });
    ```
- 顺序问题：选择器绑定事件必须写在下面，不然会报：Uncaught TypeError: $ is not a function
    - 如果在layui.use加载模块括号内最先声明上var $ = layui.$，就不用考虑之后的顺序问题了


# ==04.10==


## ${}和#{}
- #{}是预编译，用?占位，然后读取值，如果值不是数值类型就加上''，如果值是数值类型就不加''
    - 在民政救助平台中测试的控制台输出如下
        ```
        AllListTool [limit=20, page=1, select1=null, select2=null, select3=null, pass=0]
        [2m2019-04-10 10:32:15.827[0;39m [32mDEBUG[0;39m [35m10048[0;39m [2m---[0;39m [2m[nio-8888-exec-2][0;39m [36mc.l.m.C.getCshlrjknlrjzList             [0;39m [2m:[0;39m ==>  Preparing: SELECT row_id rowId FROM cymz_cshlrjknlrjz LIMIT ?,?
        [2m2019-04-10 10:32:15.829[0;39m [32mDEBUG[0;39m [35m10048[0;39m [2m---[0;39m [2m[nio-8888-exec-2][0;39m [36mc.l.m.C.getCshlrjknlrjzList             [0;39m [2m:[0;39m ==>  Parameters: 0(Integer), 20(Integer)
        [2m2019-04-10 10:32:15.834[0;39m [32mDEBUG[0;39m [35m10048[0;39m [2m---[0;39m [2m[nio-8888-exec-2][0;39m [36mc.l.m.C.getCshlrjknlrjzList             [0;39m [2m:[0;39m <==  Total: 20
        ```
- ${}是直接取代位置，取得值是什么就是什么，不加''
    - 在民政救助平台中测试的控制台输出如下
        ```
        AllListTool [limit=20, page=1, select1=null, select2=null, select3=null, pass=0]
        [2m2019-04-10 10:21:57.300[0;39m [32mDEBUG[0;39m [35m31636[0;39m [2m---[0;39m [2m[nio-8888-exec-4][0;39m [36mc.l.m.C.getCshlrjknlrjzList             [0;39m [2m:[0;39m ==>  Preparing: SELECT row_id rowId FROM cymz_cshlrjknlrjz LIMIT 0,20 
        [2m2019-04-10 10:21:57.301[0;39m [32mDEBUG[0;39m [35m31636[0;39m [2m---[0;39m [2m[nio-8888-exec-4][0;39m [36mc.l.m.C.getCshlrjknlrjzList             [0;39m [2m:[0;39m ==>  Parameters: 
        [2m2019-04-10 10:21:57.305[0;39m [32mDEBUG[0;39m [35m31636[0;39m [2m---[0;39m [2m[nio-8888-exec-4][0;39m [36mc.l.m.C.getCshlrjknlrjzList             [0;39m [2m:[0;39m <==  Total: 20
        ```
#### 关于mybatis中llike模糊查询中#和$的使用
> https://blog.csdn.net/u010398771/article/details/70768280


# ==04.10==


## 城阳民政‘老党员页面’发布后404的错误
- controller中的转发页面地址中文件夹的名字大小写不严格导致
- eclipse对转发路径的大小写不敏感，所以eclipse运行可以正常显示
- 发布后命令行运行jar包对大小写敏感，所以404


---

# **04.15**


## 密钥错误的原因好像和jdk有关，可以重新add jdk试试


---

# **04.16**


## 记录jeecg创建同步数据库
- int如果是长度设置0，存到数据库就是int类型。如果长度是20，存到数据库就是bigint
- date存进去都是datetime2


## jeecg同步数据库失败的原因
- 失败原因：**字段注释**
    - SqlServer中：新增数据字段注释的sql：
        ```sql
        EXECUTE sp_addextendedproperty 'MS_Description', '收益浮动表', 'user', 'dbo', 'table', 'COM_IncomeFloat', 'column', 'RowId';
        ```
    - 修改数据字段注释的sql：
        ```sql
        EXECUTE sp_updateextendedproperty 'MS_Description', '收益浮动表', 'user', 'dbo', 'table', 'COM_IncomeFloat', 'column', 'RowId';
        ```
    - 而同步数据库时，后台执行的sql是修改数据字段注释，此时字段没有注释的话----就会报错：
        ```
        Hibernate: 
        EXECUTE sp_updateextendedproperty N'MS_Description', 'id', N'SCHEMA', N'dbo', N'TABLE', N'test000', N'COLUMN', N'id'
        [2019-04-16 19:03:37] [WARN] [org.hibernate.engine.jdbc.spi.SqlExceptionHelper:143] SQL Error: 15217, SQLState: S0002
        [2019-04-16 19:03:37] [ERROR] [org.hibernate.engine.jdbc.spi.SqlExceptionHelper:144] 无法更新或删除属性。'dbo.test000.id' 不存在属性 'MS_Description'。
        [2019-04-16 19:03:37] [ERROR] [org.jeecgframework.web.cgform.service.impl.config.CgFormFieldServiceImpl:277] 无法更新或删除属性。'dbo.test000.id' 不存在属性 'MS_Description'。
        org.hibernate.exception.SQLGrammarException: 无法更新或删除属性。'dbo.test000.id' 不存在属性 'MS_Description'。
        ```
    - 并且，用jeecg平台创建表单时，字段的注释并没有存到数据库中字段的注释中，导致表单只能在创建的时候就编辑完，后续再编辑还是会执行修改字段注释的操作，依旧会失败。
- 解决办法：用Navicat或SqlServer management studio创建表，并写全注释，然后'从数据库中导入表单'


## SqlServer运行sql文件
- 如果运行的时候不点具体的数据库(用Navicat运行的话，此时数据库名为N/A)，运行后会存储到系统数据库master中。
    - Navicat隐藏了系统数据库，在SqlServer可视化桌面能看到


---

# ==04.17==


## 知识产权(jeecg)"设置业务开展时间"功能--创建||操作时间错误问题
- 错误描述：假如数据库中的某条数据，有创建时间，在点击编辑后保存，会保存不进去，保存事件的控制器就走不进去，错误原因是日期转换错误
- 错误原因：代码生成的时候，把创建时间和修改时间也展示到了页面上，设置的type="hidden"隐藏域。代码如下：
    ```html
    <input id="zlAotoperdate" name="zlAotoperdate" type="hidden" value="${zlAppliopentimePage.zlAotoperdate }">
    ```
    - 则在点击查看编辑页面的时候，数据带过来，但是点保存的时候，这个数据在用实体类接收的时候接收不了，实体类类型是date，这个我不知道 是什么类型，他转换不了。
- 真正原因是：**前台传的日期(字符串)有毫秒值**，后台用date接收转换会失败
    - 观点支撑是：设置`type="text"`依然一样的错误
- 需要注意的是：日期控件是可以转换的，日期控件的展示代码是：
    ```html
    <input id="zlAotbegindate" name="zlAotbegindate" type="text" style="width: 150px"  
    class="Wdate" onClick="WdatePicker()" ignore="ignore" 
    value='<fmt:formatDate value='${zlAppliopentimePage.zlAotbegindate}' type="date" pattern="yyyy-MM-dd"/>'>
    ```
    - 是因为这里进行了格式转换，没有了毫秒值
- 解决方法：
    - 一：把前端页面的相关input去掉，不让他被实体类接收，就不会转换失败
    - 二：把日期格式化去掉毫秒值


---

# ==04.22==


## this的使用
- 有时候直接在方法里写this，接收到的是window、document对象。
    - 可以console.log检验
- 这时候应该写标签里的内联方法，方法里写this，然后js方法里的方法用参数接收。就行了


##获取标签的value值
- 只有input才能获取，而且标签内得有value，否则说：Cannot read property 'value' of null


# ==04.23==


## 记录一条sql语句：
- 正确的写法
    ```sql
    SELECT
    CASE
    	WHEN
    		am_sum IS NULL THEN
    		0 ELSE am_sum 
    	END AS am_sum,
    CASE
    	WHEN pm_sum IS NULL THEN
    		0 ELSE pm_sum 
    	END AS pm_sum,
    CASE
    	WHEN am IS NULL THEN
    		10 ELSE am 
    	END AS am,
    CASE
    	WHEN pm IS NULL THEN
    		20 ELSE pm 
    	END AS pm,
    CASE
    	WHEN am_mayuyuedate IS NOT NULL THEN
    	am_mayuyuedate 
    	WHEN pm_mayuyuedate IS NOT NULL THEN
    	pm_mayuyuedate ELSE CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) 
    	END AS DATA 
    FROM
    	(
    	SELECT
    		sqam.am_sum,
    		sqpm.pm_sum,
    		sqam.am_mayuyuedate,
    		sqpm.pm_mayuyuedate 
    	FROM
    		(
    		SELECT
    			COUNT( * ) am_sum,
    			CONVERT ( VARCHAR ( 10 ), zl_CCYuYueDate, 120 ) am_mayuyuedate,
    			zl_CCYuYueAmPm 
    		FROM
    			zl_CorpoorCertific 
    		WHERE
    			zl_CCYuYueAmPm = 'am' 
    			AND zl_CCYuYueDate >= '2019-04-23' 
    		GROUP BY
    			zl_CCYuYueDate,
    			zl_CCYuYueAmPm 
    		) sqam
    		FULL JOIN (
    		SELECT
    			COUNT( * ) pm_sum,
    			CONVERT ( VARCHAR ( 10 ), zl_CCYuYueDate, 120 ) pm_mayuyuedate,
    			zl_CCYuYueAmPm 
    		FROM
    			zl_CorpoorCertific 
    		WHERE
    			zl_CCYuYueAmPm = 'pm' 
    			AND zl_CCYuYueDate >= '2019-04-23' 
    		GROUP BY
    			zl_CCYuYueDate,
    			zl_CCYuYueAmPm 
    		) sqpm ON sqam.am_mayuyuedate = sqpm.pm_mayuyuedate 
    	) sq
    	FULL JOIN ( SELECT * FROM zl_examinenum WHERE type = 2 ) yy -- 这一行
    	ON CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) = sq.am_mayuyuedate 
    	OR CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) = sq.pm_mayuyuedate 
    WHERE
    	(
    	CASE
    		WHEN am_mayuyuedate IS NOT NULL THEN
    		am_mayuyuedate 
    		WHEN pm_mayuyuedate IS NOT NULL THEN
    		pm_mayuyuedate ELSE CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) 
    		END 
    ) >= '2019-04-23'
    ```
- 错误的写法
    ```sql
    SELECT
    CASE
    WHEN
    	am_sum IS NULL THEN
    	0 ELSE am_sum 
    	END AS am_sum,
    CASE
    	WHEN pm_sum IS NULL THEN
    	0 ELSE pm_sum 
    	END AS pm_sum,
    CASE
    	WHEN am IS NULL THEN
    		10 ELSE am 
    	END AS am,
    CASE
    	WHEN pm IS NULL THEN
    	20 ELSE pm 
    	END AS pm,
    CASE
    	WHEN am_mayuyuedate IS NOT NULL THEN
    	am_mayuyuedate 
    	WHEN pm_mayuyuedate IS NOT NULL THEN
    	pm_mayuyuedate ELSE CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) 
    	END AS DATA 
    FROM
    	(
    	SELECT
    		sqam.am_sum,
    		sqpm.pm_sum,
    		sqam.am_mayuyuedate,
    		sqpm.pm_mayuyuedate 
    	FROM
    		(
    		SELECT
    			COUNT( * ) am_sum,
    			CONVERT ( VARCHAR ( 10 ), zl_CCYuYueDate, 120 ) am_mayuyuedate,
    			zl_CCYuYueAmPm 
    		FROM
    			zl_CorpoorCertific 
    		WHERE
    			zl_CCYuYueAmPm = 'am' 
    			AND zl_CCYuYueDate >= '2019-04-23' 
    		GROUP BY
    			zl_CCYuYueDate,
    			zl_CCYuYueAmPm 
    		) sqam
    		FULL JOIN (
    		SELECT
    			COUNT( * ) pm_sum,
    			CONVERT ( VARCHAR ( 10 ), zl_CCYuYueDate, 120 ) pm_mayuyuedate,
    			zl_CCYuYueAmPm 
    		FROM
    			zl_CorpoorCertific 
    		WHERE
    			zl_CCYuYueAmPm = 'pm' 
    			AND zl_CCYuYueDate >= '2019-04-23' 
    		GROUP BY
    			zl_CCYuYueDate,
    			zl_CCYuYueAmPm 
    		) sqpm ON sqam.am_mayuyuedate = sqpm.pm_mayuyuedate 
    	) sq
    	FULL JOIN zl_examinenum yy -- 这一行
    	ON CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) = sq.am_mayuyuedate 
    	OR CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) = sq.pm_mayuyuedate 
    WHERE
    	(
    	CASE
    		WHEN am_mayuyuedate IS NOT NULL THEN
    		am_mayuyuedate 
    		WHEN pm_mayuyuedate IS NOT NULL THEN
    		pm_mayuyuedate ELSE CONVERT ( VARCHAR ( 10 ), yy.DATA, 120 ) 
    		END 
    		) >= '2019-04-23' 
    AND yy.type =2 -- 这一行
    ```
 - 这是知产查询的一个语句，把这个type的where条件写在不同的位置是不同的效果。
    - 写在full join 语法之内，会先查符合条件的examinenum表，然后再被full join语法执行全连接
    - 写在最后，会先执行全连接，然后在全连接的表中筛选符合type条件的数据


---

# ==04.26==


## 城阳民政菜单id重复-bug问题记录

## main.ftl里的
-  `<@tree data=menu start="start" end="end"/>`
- 是把转发过来的绑定名为menu的对象，改名成data。可能是freemarker里面的
## 修改MenuServiceImpl.java里面的代码，将num用全局的静态变量代替。
    主要涉及到getMenuJsonByUser(arg)方法里的for循环，和getChilds(arg0,arg1,arg2)方法
- 这里用到了**递归**，到时候用到的时候过来看看
- 这里也用到了一个好像是**匿名方法**还是什么的：
    ```
    ......List, (o1, o2) -> {/.........
    应该学过，看JSD1809_SE的lambda包，别的包也搜搜看看
    ```

---

# ==05.06==


## SqlServer中union all 和 rownumber(分页)连用
- 这种情况下，如果where rownumber>xx ,查询出来的rownumber序号虽然符合>xx但不是连续的。而且每次查询出来的都不一样
- 如果where rownumber<yy 或者存在一个小于的条件，结果就正常。或者加ORDER BY rownumber


---

# ==05.11==

## jquery的append方法
- append()中如果直接填字符串，应该都可以
- append()中如果填的是对象的html，需要注意：
    - 这种不可以：
        ```
        html代码：
        <div id="template" style="display:none;">
                            <tr>
                                <td style="width: 15px" class="value">1</td>
                                <td style="width: 60px" class="value"><input type="text" class="inp-a" style="width: 50px"></td>
                                <td style="width: 25px" class="value"><input type="text" class="inp-a" style="width: 15px"></td>
                                <td style="width: 25px" class="value"><input type="text" class="inp-a" style="width: 15px"></td>
                                <td style="width: 80px" class="value"><input type="text" class="inp-a" style="width: 70px"></td>
                                <td style="width: 80px" class="value"><input type="text" class="inp-a" style="width: 70px"></td>
                                <td style="width: 120px" class="value"><input type="text" class="inp-a" style="width: 110px"></td>
                                <td style="width: 120px" class="value"><input type="text" class="inp-a" style="width: 110px"></td>
                                <td style="width: 80px" class="value"><input type="text" class="inp-a" style="width: 70px"></td>
                                <td style="width: 80px" class="value"><input type="text" class="inp-a" style="width: 70px"></td>
                                <td style="width: 150px" class="value">
                                    <button class="layui-btn layui-btn-primary layui-btn-xs" 
                                            title="请上传'上传专利代理人资格证书'">上传证书*</button>
                                    <button class="layui-btn layui-btn-primary layui-btn-xs">删除</button></td>
                            </tr>
            </div>
        js代码：$("#table-three").append($("#template").html());
        ```
    - 原因是div中不会有tr，这是一个错误的结构，在页面渲染的时候会把tr去掉，里面只剩input。加上jeecg、easyui的样式冲突。
        - 正确的应该是用`<table>`标签，使其至少能够正常渲染：`<tr>  <td></td>  </tr>  </table>`
#### 操作append的元素
- 不可行的代码： 
    ```js
    var nump = 0;        
       function addperson(){
           $("#table-three").append($("#template-person").html());
        $("#table-three tr:last-child td:first").html(nump);
        nump++;
       }
    ```
    - 先添加模板元素，再执行赋值，会将nump添加给所有的选择元素的html
- 可行代码
    ```
    var nump = 0;
       function addperson(){
        $("#template-person tr:last-child td:first").html(nump);
        $("#table-three").append($("#template-person").html());
        nump++;
       }
    ```
    - 先把模板的值改变，然后再添加模板元素。可行
- 应该是渲染问题，页面加载完成后添加的元素在document树形结构中没渲染好
#### 应该是jeecg影响了children选择器选择的问题
- children选择器只选择子元素，而jeecg在table中每个tr上加了一层<tbody>就选不到了
- 用find()不用children
- 代码如下：
    ```
    //添加元素
    $("#table-three").append($("#template-person").html());
    //获取tr的个数，除去一个标题
    var amount = $('#table-three').find('tr').length-1;
    //用find给序号位赋值
    $("#table-three").find('tr').eq(amount).find('td').eq(0).html(nump)
    nump++;
    ```


## jquery的children()与find()区别
> https://blog.csdn.net/littleqqqqq/article/details/51783098

- 通过以上的解释，可以总结如下：
    1. children及find方法都用是用来获得element的子elements的，两者都不会返回 text node，就像大多数的jQuery方法一样。
    2. children方法获得的仅仅是元素一下级的子元素
    3. find方法获得所有下级元素
    4. children方法的参数selector 是可选的（optionally），用来过滤子元素，但find方法的参数selector方法是必选的。


---

# ==05.14==

## html中的id和方法名不能有一样的，不然会报‘方法未定义的错误’


## input type=file 文件名
- 只获取文件名
    ```
    document.getElementById('fileField').files[0].name
    ```
- 获取带路径的文件名
    ```
    document.getElementById('fileField').value
    ```


## 前端json的复杂取值
- 代码：
    ```js
    //1. 准备：json是一个list，key在数组arr中
    var arr = ["姓名","性别"]
    //2.1 这种：index是变量，可以遍历
    datalist[0][arr[index]] 
    //2.2 这两种不可遍历:
    datalist[0]["姓名"]    datalist[0].姓名
    //2.3 如果json不是数组，把下标`[0]`去掉即可
    datalist[arr[index]]    -    datalist["姓名"]   -   datalist.姓名  
    ```
- --暂时先这样，回头要总结全。


---

# ==05.14==


## jeecg天衣无缝提交按钮拓展方法
- 代码：
    ```
    var win = frameElement.api.opener;        用当前iframe的api获取父页面
    win.$('#zlServiceagencyawardList').datagrid('reload');  刷新父页面中的一个t:datagrid，绑定的是t:dataGrid的name: zlServiceagencyawardList 
    frameElement.api.close();    关闭这个iframe
    ```

---

# ==05.17==


## 调用layui模块内部的方法
- 在声明方法的时候写 window.方法名，即声明整个窗口的方法
    ```
    例如： var fun() --> window.fun()
        window.apply = function(){}
    ```


# ==05.19==

## layui上传按钮的渲染问题
- 知产的反复渲染，经总结后得出：不能用同一个按钮，即使是修改id渲染也不行。解决办法是新增按钮，删除按钮，如下：
    ```js
    //创建按钮并且渲染
    //$("#updiv").append('<input id="unify-upbtn" class="unify-upbtn" type="hidden">');
    apply(upbtnobj);//将本按钮信息传递，重新渲染上传组件
    $("#unify-upbtn").click();//触发上传
    //删除按钮
    //$("#unify-upbtn").remove();
    ```
- 后来F12看html结构发现，layui上传在触发以后，会自己在监听的按钮下生成一个：
    ```html
    <input class="layui-upload-file" type="file" accept="undefined" name="file">
    ```
- 记下来，以后研究


---

# ==05.22==

## 报表的排序方法：  
    ```js
    //不排序是：
    data:list
    //排序1：
    data: list.sort(function (a, b) { return a.value - b.value; })
    //list也可以是自己写的name-value数组
    //排序2：
    data: myfun(list)
    
    function myfun(list) {
        var temp = [0, 1, 1, 0, 4, 4, 6, 2, 1, 1];
        let _arr = arr.slice()
        for (let i = 0; i < _arr.length; i++) {
            // let j = getRandomInt(0, i) ---也可以是随机的，上边用了数组，所以这里注掉了
            let j = temp[i];
            let t = _arr[i]
            _arr[i] = _arr[j]
            _arr[j] = t
        }
         console.log(temp);
        return _arr
    }
    
    function getRandomInt(min, max) { // 随机的
        return Math.floor(Math.random() * (max - min + 1) + min)
    }
    ```


## echarts
- 主题切换
    ```
    //基于准备好的dom，初始化echarts实例
    var myChart2 = echarts.init(document.getElementById('report2'),threme);
    // 执行两次，用于更换主题样式
    myChart2.dispose();
    myChart2 = echarts.init(document.getElementById('report2'),threme);
    ```
- data和name的填值
    - 传过来的list中是name-value形式，并且要**小写**


---

# ==05.22==


## layui数据表格
- 如果不返回数据总量，则不显示分页工具栏


---

# ==06.14==


## `c:foreach`标签的`items`可以这么写：
- items="a,b,c,d,e"
- 遍历的时候个会根据 ' , ' 隔开


---

# ==06.17==


## nio和io包
- 如果file导入的是nio的包，当文件不存在的时候删除会有异常，io的包如果被删除的文件不存在，返回值为false
    ```java
    //所以先判断是否存在
    File file = new File(filepath);
    if(file.exists()){
        file.delete();
    }
    ```

---

# ==06.18==


## SQLServer在做字符串比较时--空格问题
- SQL Server 在做字符串比较时==会自动去掉首尾空格==


## layui的下拉选--空格问题
- 用`append(<option>.....)`的时候，如果不赋值给value，会自动把填充进去的值的首尾空格去掉
- 这时候如果用`.val(arg)`方法，里面的arg如果有空格，即使和填进去的值一样也赋不上值，因为layui下拉选填进去的值把空格去掉了


## MySQL优化
- 总结一下工作中的MySQL调优经验
    > https://blog.csdn.net/h_h_v/article/details/79550748  
- MySQL常用30种SQL查询语句优化方法
    > https://blog.csdn.net/youthsunshine/article/details/53465847  
- MySQL学习总结（39）——49条MySql语句优化技巧
    > https://blog.csdn.net/u012562943/article/details/52856496   
- MySQL单向自动同步
    > https://my.oschina.net/u/1251858/blog/2050612


---

# ==06.25==

## jeecg的eq/order/and查询用法
```java
/**
 * EasyUI-dataGrid 根据投诉单自增主键，查找反馈列表
 */
@RequestMapping(params = "doFeedList")
public void doFeedList(HexIfeedbformEntity feedForm,HttpServletRequest request,HttpServletResponse response, DataGrid dataGrid){
    CriteriaQuery cq = new CriteriaQuery(HexIfeedbformEntity.class, dataGrid);
    //查询条件组装器
    org.jeecgframework.core.extend.hqlsearch.HqlGenerateUtil.installHql(cq, feedForm, request.getParameterMap());
    try{
        //自定义追加查询条件
          cq.eq("hexIfid",feedForm.getHexIfid());  // 是 where =
          cq.addOrder("hexIfffbtime", SortDirection.desc);    // 是 order by

          /*cq.and(        // 是 and
                Restrictions.eq("hexIfid",feedForm.getHexIfid()),
                Restrictions.eq("aaa",feedForm.getHexIffdes())
        );*/

    }catch (Exception e) {
        throw new BusinessException(e.getMessage());
    }
    cq.add();
    systemService.getDataGridReturn(cq, true);
    System.err.println(dataGrid.getResults().toString());
    TagUtil.datagrid(response, dataGrid);
}
```


---

# ==06.26==


## 路径问题
- `request.getSession().getServletContext().getRealPath("/");`
    - `request.getSession().getServletContext()` 获取的是Servlet容器对象，相当于tomcat容器了。
    - `getRealPath("/")` 获取实际路径，“/”指代项目根目录
    - 所以代码返回的是项目在容器中的实际发布运行的根路径
    `D:\JavaWorkSpaceForIDEA\qingpi_packingMaterial\src\main\webapp\`  -- ==带斜杠！！！==
- `String path = request.getServletContext().getRealPath("/upload");` 获取项目根路径下的upload文件的磁盘绝对路径。
    - 和`request.getServletContext().getRealPath("/upload/");`效果一样
    - 得到：`D:\JavaWorkSpaceForIDEA\qingpi_packingMaterial\src\main\webapp\upload`   -- ==不带斜杠！！！==
- PROJECT笔记整合中有：
    - 调用`request.getServletContext().getRealPath("文件夹名称")`即可获取到等同于`webapp`文件夹下的某子级文件夹的路径！

## layui渲染的问题
- 以下拉选举例 -- 海克斯康，投诉单的update页面。需要在页面加载完成中给下拉选赋值，并且页面这个事件没有在layui模块中写。
    - 那么此时layui的模块加载和页面的加载完成事件时同时进行加载的。就会存在layui模块还没加载完，就要用到layu下拉选的渲染方法，此时就会报错
- 由此可以做个事：在layui模块最下面，总是写`上form.render()`，这样以后在页面加载时：
    - 即使页面还没等layui加载完就调用他的渲染，等到layui加载完后也会渲染一次(只是走到调用的时候js会报个错而已)。
    - 而如果是页面等到了layui加载完再调用，也不会有js报错
- **以后直接这样吧**：把页面加载完成事件写在layui模块内的下面
    ```
    <%--全局变量--%>
    <script>
        。。。
    </script>
    
    <!-- ==================================== -->
    <!-- ========layui模块&页面加载完成事件 -->
    <script>
      layui.user[...............{
        。。。。
        //====================================
        //============页面加载完成事件=============
            。。。。
    
        //====================================
        //=============页面初始赋值=============
            。。。。
      }
    </script>
    
    <script>
        //====================================
        //============声明的普通方法=============
        。。。
    </script>
    ```


---

# ==06.28==

## 判断对象类型
- xxx.getClass()


## jeecg的双击单击事件和操作列按钮的点击事件--参数区别
- 例子：
    ```
    function clickRow(rowIndex,rowData){
    //选中行的索引
        //console.log(rowIndex);
    //点击行的数据
        //console.log(rowData);
    }
    //点击(双击单击)时有第一个参数，也有第二个参数，第一个是行索引，第二个是行数据
    //操作列的按钮触发时只有第一个参数是行索引，没有第二个参数
    ```


## jeecg的执行sql参数：写null需要注意的事
- 如过预编译的?有多个，可以写null。
    ```java
    systemService.findOneForJdbc(sql,null,null); // 不会报错，逻辑正常
    ```
- 当预编译的?只有一个时，写null会报：`没有为参数1设置值`。
    ```
    systemService.findOneForJdbc(sql,nul); // 会报错
    ```
    - 估计原因是：
        - 这第二个参数为null，可能我们认为的是这个null表示的是我写的那个?的值为null。
        - 而实际方法底层判断时可能是认为null表示'预编译参数'这个属性为null，就是说，我没没有为预编译参数设置值。这个预编译参数不是单个的参数，而是相对广义一点的，代表的这个语句所有的预编译参数


# ==07.09==

## layui下拉选相关：
- 显示不全：
    ```
    /* 下拉选如果页面空间不够会折叠起来,吧overflow恢复为默认值 */
    .layui-form-select dl{
        overflow: visible;
    }
    /*如果下拉选显示不全，用overflow: visible;后，本来不全的会透明，所以加个背景色*/
    .layui-form-select dd{
        background-color: #fff;
    }
    ```
- 动态赋值并且想要触发值改变后的监听事件
    ```
    //没找到别的方法，只有这样才能触发到layui下拉选的监听事件
    $("选择器").next().find("dl").eq(0).find("dd[lay-value='"+拼接值+"']").click();
    ```


---

# ==08.13==


## Echarts组合图的主题bug
- Echarts组合图表，有时不受主题的影响。小工具的样式，颜色，指示器，拖拉条等等都会受影响。
- 解决办法：直接把样式改成内联的，其实主要就是color，直接在option中写即可


---

# ==09.08==


## 老项目(qingpi&cy12345)的class嵌套多层的原因
- **直接原因**：是按照了杜哥给的那个网站来照样子配置了class的输出路径 https://blog.csdn.net/ziwuzhulin/article/details/82462872
- **根本原因**：
    - Project Structure-->Project的输出目录按照上面网站的配置是： `x\y\z\WebRoot\WEB-INF\classes`。
    - 从而配置Project Structure-->Artifacts时，他的输出目录自动就变成了 `x\y\z\WebRoot\WEB-INF\classes\artifacts\cy12345_war_exploded`
        - 拓：程序运行时，用的是这里的class文件，而不是Modules的class文件。个人认为之所以有Modules的class文件是为了让开发者对每个模块的操作更灵活
    - 而Project Structure-->Modules的输出目录也是：`x\y\z\WebRoot\WEB-INF\classes`
    - 这就造成了：点击运行时，如下过程：
        - **一**：模块的文件先被编译，生成class文件输出到`x\y\z\WebRoot\WEB-INF\classes`下
            - 输出的是Modules-->Sources中被标记为Sources的文件的class
        - **二**： 整个项目编译打包(war_exploded(不是很懂))。输出路径是` x\y\z\WebRoot\WEB-INF\classes\artifacts\cy12345_war_exploded`
            - 所有的项目文件都编译打包，用于程序运行时使用。其中Modules编译的class直接复制过去(**试验了一下，copy的路径是打包的目录的WEB-INF\classes\，好像没法设置。这是关键**)，不再重新编译。
            - 这就造成了：
                - **第一次运行**：`classes文件夹`下先出现`模块class文件`。后出现`artifacts\cy12345_war_exploded\项目打包文件`，其中模块class文件位于`WEB-INF\classes`下
                - **第二次运行**：模块的class文件照旧被编译在classes文件夹下，而整个文件夹被作为模块的class文件被copy至`artifacts\cy12345_war_exploded\WEB-INF\classes`下
                - **以此类推**，每次编译，class文件夹下的所有文件都会被当做模块的class文件，copy到`artifacts\cy12345_war_exploded\WEB-INF\classes`下，从而此文件越套越大
- **解决办法**就是不让Modules的输出路径和Artifacts的打包路径一样即可。
    - 可以让打包路径在项目下的classes文件中，让Modules的输出路径在当前模块的WEB-INF\classes下



