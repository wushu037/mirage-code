
笔记下载code.tarena.com.cn
账号tarenacode
密码code_2013
TMOOC：tmooc.cn  邮箱账号，证后四位手机后四位
#-----------------------------------------xxx-------------------------------------------
左边比右边少一个的正常  右边可以突出一块
#此笔记的功能是起辅助拓展和备份课堂笔记个人注解的作用
#整理此笔记的要求：一些杂项写在小项，其他整合笔记中有的注释这里尽量有，不让这里指向整合笔记中添加的个人注释
#当天分隔线 ##各个知识点 ###知识点下的小知识点 - 无序段落 123.有序段落 ##小项 123456知识点序号	``缩进行并避免换色
#本笔记的day命名，基本按照笔记下载网站的大项名字.dayxx，从spring开始，有时同一天要写两个分隔线，此种情况会在分隔线下加###当天的日期
#本笔记，所有加'xx'引号的，均可尝试Ctrl+F搜索它的其他相关笔记


#---------------------------------------语言基础-----------------------------------------


##小项
1. 为什么qq不用java写：qq是即时通讯软件，用C更快；
2. 为什么C语言不用java模式（jvm）：各有优势，C快且基础
3. java要在虚拟机运行，不同系统有不同的JVM，都能运行标准的.cllass源文件
4. java对空格的使用要求不高，一般用一个
5. 多个符号同时出现，计算机最后进行赋值“=”
6. 不加引号计算机通认为是变量
7. 25E2=1.25*10^2
8. 多种类型参与，往范围大了靠
9. import java.util.Scanner; 写在类上边  因为这个工具在包里或者是在库里，进类之前就得取出来这个工具
10. Tab：水平制表位，固定占8位。输出时加转义符： \t
		9*9乘法表中输出使用
11. 类名大驼峰命名法(帕斯卡)，变量(小)驼峰命名法
12. 方法=函数=过程   在各种语言中的叫法不同


##只有JVM区分系统，JRE、JDK不分系统
 - JVM(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个多平台程序。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。
 - JVM的话相当于安装了操作系统。但是没法用软件，所以我们还要下运行在JVM上的软件，比如Eclipse

##注释
 - `/*多行注释*/`
 - `/**文档注释*/ `使用javadoc开发工具即可生成一个开发者文档，一般用在类和方法上。查看笔记'##文档注释'
 - `//`单行注释


##System.currentTimeMillis(); 
 - 返回的是从GMT 1970年1月1日00:00:00开始到现在的毫秒数(long型)。1970年是UNIX系统正式发布的时间，所以这一时间也称为UNIX时间戳(UNIX epoch) 
		文档：当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。


##默认值
 - 引用类型声明的时候默认值null
 - 基本类型若为类属性(成员变量)有默认值，若为final属性或方法属性则不会设置默认值
 - 注：	char默认值为/u0000
``		float默认值为0.0f
``		double默认值为0.0d,平时d可以不写;
``		布尔型默认值为false
``		引用类型默认值为null


##从1累乘到100溢出为什么得0
 - 每次循环都输出一下发现，到了一定的次数值就变成0了
		不知道是内存问题还是啥，回头仔细研究下吧


##System.out.println();
 - System：类
 - out：静态属性
 - println()：静态方法
		并且这个方法有很多重载方法，有各种各样的参数，所以我们可以输出很多不同的类型数据


18. int [] [] arr = new int [2] [] ; 数组的数组元素个数放在第一个[]中，是为了和其他语言兼容，其他语言都放在第一个
数组的数组可以用来表示类似"矩阵"这样的数据结构。很多语言把这样的结构称为二维数组。如C语言的二维数组，但是C语言的二维数组每一行里的列都要是固定(相同)的。而Java的每个行的列可以不固定(每个大数组里的小数组长度可以不一样)。
而严格地说Java中没有真正的二维数组，Java中没有二维数组的概念，可以认为所谓的二维数组在Java中只是一种特殊的形式而已。Java中称为数组的数组、数组类型的数组。

19. 方法不一定非要在main里调，但程序一定是从main开始，main是入口，程序运行的时候，第一个执行的方法就是main方法。

20. 关于王克晶的那个long sum = 0：从0加到100，
(天将说加减运算时计算机是从右向左计算),如果是long a = 100+3+2L 那一直加到2才转为L，但是加不加也无所谓了，因为最后加完了也没溢出，向左赋值给long后也自动转为long型了，而long a = 100L+3+2 从第一个就是long型，加3和2过程中自动转为long了。想一下直接字面量顾名思义一下。


##字面量
		https://blog.csdn.net/love_hachi/article/details/42705247
 - 在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（natation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等符合类型的值也支持字面量表示法。
###整数字面量
 -  整数可能是在典型的程序中最常用的类型。任何一个数字的值就是一个整数字面量。
###字符串字面量
 -   Java 中的字符串字面量和其他大多数语言一样——将一系列字符用双引号括起来。
		例如：	"Hello World" 
				"two\nlines" 
				"\"This is in quotes\"" 


21. 一个类中的方法或属性若声明为static，就可以直接调用，否则在调用时，必须用new生成该类的一个实例，才能调用里面的东西。
必须为static 这样主程序无需实例化！
实例化:在面向对象的编程中，通常把用类创建对象的过程称为实例化；new是对系统申请一块数据空间来将对象实例化。



##结束循环的情况有两种
 - 循环条件为false
 - 循环中碰到break


##break、continue和return的区别
 - break：直接跳出当前循环体（while、for、do while）或程序块（switch）。
		只跳出一层循环
 - continue：不再执行循环体中continue语句之后的代码，直接进行下一次循环。
 - return：在有返回值的方法中写则返回方法的返回值。在无返回值的方法中单独写return可以跳出方法的执行，return以下的不走


##switch case语句
		day04-CommandBySwitch.java
 - switch()变量类型支持的六种类型：
``		基本数据类型：byte, short, char, int
		对应的包装类型：Byte, Short, Character, Integer。   自动拆箱（从JDK1.5开始支持自动拆箱和自动装箱。自动拆箱就是自动将引用数据类型转化为基本数据类型，自动装箱就是自动将基本数据类型转化为引用数据类型
``		枚举类型：Enum
``		字符串类型：String（Jdk7+ 开始支持）
 - case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。
 - default语句可有可无，最多只能有一个。
###swich case的执行过程
 - 进行case判断时，JVM会自动从上到小扫描，寻找匹配的case，可能存在以下情况
``	情况一：匹配不成功
		- 有default执行default。
		- 没有default则不执行。
``	情况二：匹配成功
		- 语句块中不存在break时，从当前匹配成功的case开始，依次执行后续所有case。
		- 语句块中存在break时：
			若若当前匹配成功的case存在break，则跳出语句块；
			若当前匹配成功的case不存在break，则从当前case开始，依次执行后续case，直到遇到break，跳出语句块。


##算法&数据结构
 - 算法：解决问题的流程/步骤(顺序、分支、循环)
		程序员群-算法：一种逻辑计算方式
 - 数据结构:将数据按照某种特定的结构来保存。
		数组是最基本的数据结构
		克晶：设计良好的/合理的数据结构会导致好的算法，这句话的理解：
			数据结构是对数据的分类保存，比如java编程思想这本书为一个数据
			按出版社分类设计数据结构，找java编程思想这本书------设计不合理---不好找
			按图书类别分类设计数据结构，找java编程思想这本书---设计合理------好找
 - 先设计数据结构，再做算法
		还是做设计的更赚钱


##Math.random()的使用
 - 原理：
	例：生成随机数1到1000
		int number = (int)(Math.random()*1000+1);
		Math.random()------------0.0到0.999999999999999...
		*1000--------------------0.0到999.9999999999999...
		(int)--------------------0到999
		+1-----------------------1到1000
 - 在连续整数中取得一个随机数
``		值 = (int)(Math.random()*可能值的总数+ 第一个可能的值); 
		例如：int i  = (int)(Math.random()*10+5);     5-14之间的随机数
 - 在不相邻整数中取得一个随机数
``		1.在不相邻的两个整数中取得一个随机数
		例：随机产生2或4中的一个数
		int i = Math.random() < 0.5 ? 2 : 4;
``		2.在不相邻的多个整数中产生一个随机数
		例：1	5 	9 	10 
		放入数组，然后随机取数组下标


#--------------------------------------OOP.day01----------------------------------------


1、world中，把各个对象放在main外面，因为这个world里还有很多其他方法。把天空什么对象的放在main外面当作world的成员变量。那在world的各个方法中都可以用。（在main里局限了作用域）
但是在main里其实也建不了，因为static，但去掉static计算机就不认识main了，(是不是因为不加static的话main不在方法区，找不到入口)周四解释


##小项：
1. 克晶老师说：在自己做的类中写方法的时候，先把方法的第一要素省掉，直接void
		10-13号上午 126：12   此时还没学访问修饰符，不写就是默认。

#--------------------------------------OOP.day02----------------------------------------


1、类中成员变量  方法中局部变量（只能在方法中用）
成员和局部可以重名，用的时候就近所以用this。因为一般命名不会混用字母数字下划线$，纯字母，不加this自己给自己赋值就没意思了

2、重载：方法名还是那个方法名，只不过参数列表变了，对应的方法体也变了。想传同名的不同方法就会发生重载

3、构造方法在new对象的时候自动调用方法。普通方法new之后用.调用方法。为什么普通方法不能new的时候直接调用呢！因为构造方法名和类名相同，但是普通方法和类名不同！new的时候不能另加别的名啊，没这个语法！

4、因为我建了对象就是为了减少代码量，来调用的，而且调用的时候也得赋初值，所以java做了个方法叫构造方法，目的就是为了给成员变量赋初值，在里面写好方法的参数列表，用的时候直接new出来并且写出具体的值就可以。

5、构造方法没有返回值类型，不是没有返回值，是没有返回值类型--所以不加void (这不难理解，因为构造方法是实例化的时候自动调用的，不需要这个属性)

6、main里的是局部变量，因为main是方法，局部变量在栈里

7、以后报空指针异常，基本是因为操作了null的对象


#--------------------------------------OOP.day03----------------------------------------


1、特别注意java中-数组-的引用类型变量指向数组的第一个元素，于是可用下标找到它的下一个：
例如 int[] a = new int[3]；
引用a在栈中指向int[]第一个元素int[0];


#--------------------------------------OOP.day04----------------------------------------


2、继承要符合is a（是一个）的关系，比如老虎是一个动物

3、向上造型：派生类下还有很多对象，而且各个派生类和其各个对象都具有相同的行为（移动、被射击撞击），为减少代码重复，增强代码复用，把各个类的for循环用向上造型装在一个for循环里。（具体操作是数组，看当天World.java)

4、Sky sky; 只声明引用，这时sky是null，oop第一天时只声明引用，然后在方法里new。在10.17的97：58秒说了原因，是为了避免我们产生误觉：如果第一天就new好,好几天就不用动了（就不会注意new好的对象了），以后在方法里就可以直接用了，会以为引用就是直接用的，其实是必须创建对象才能用的。
但为了避免只声明忘记new之后，在用的时候空指针异常，所以我们实际应用中一般是声明的时候就new出来，这样sky就不是null了

5、FlyingObkect[] enemies;等同FlyingObkect[] enemies = null;---------只声明，enemies什么都没有，衣柜也没有，是null
    FlyingObkect[] enemies = {};等同FlyingObkect[] enemies = new FlyingObkect[0];----声明了，enemies有个衣柜，衣柜里什么也没有，数组长度是0。

6、重写：超类派生类中用，满足输出多个派生类各自需要的特有行为。重写被调看对象的行为，走的是派生类的方法
ppt中有重写搭配super.调用超类使用，同时输出超类和派生类的方法。一般用来功能扩展
super.方法名()---调用超类的有参构造（不写默认超类无参构造，没无参写有参）
this.方法名()一般不用也没讲，只说方法名一般不会重复

7、重写的两同两小一大：
两小的异常11月API讲
两小的返回值的大小看当天的Demo.java理解，oo.day04
一大：子类方法的修饰符权限必须大于或等于父类方法的修饰符访问权限（超类的一般用public，大于是不可能了，所以都用public）

8、构造派生类之前要先构造超类：意思是派生类的构造方法里会有超类构造方法，构造是构造方法
这是java规定，为了保证这个规定，在派生类构造方法中若不调用超类构造，则默认在派生类构造方法的第一行调用超类无参构造：super()。116.00
我们用的时候也是必须要把super()放在派生类构造中的第一行，放在下边编译错误，因为默认就在第一行调用无参。
好理解：在派生类构造中，当然先调超类构造再写子类构造，不能先写子类方法再调父类方法，乱了辈分


#--------------------------------------OOP.day05----------------------------------------


1、因为编译期没有分配对象，所以重写是运行期分配了对象才能绑定。---具体看笔记
看一下当天的OverrideOverloadDemo.java 有点难理解---重载看参数，重写看对象

2、窗口swing相关的： 照片在像板上，面板在相框上 JFrame---窗口（相框）   JPanel---面板（像板）

（20、eclipse导入项目的import和openfile:h=引入和打开，一个保存，一个不保存。。。。）

3、包的域名反写，是避免公司和公司之间冲突，域名全球唯一

4、访问不同包的类：import oo.day02.类名，还有import oo.day02.*访问这个包的全部类（不建议，影响效率）
（Scanner---在java.util.Scanner里，Scanner(System.in)是无参构造,int age = scan.nextInt()这是一个无参有int返回值的方法，nextDouble同理，当天笔记有推测java.util包的内容）
包可以有层次结构：比如a.b.c.d	和a.b.c.e 大项目一般有这样的 层次结构

5、访问修饰符：保护数据（private修饰的内容是实现对内的封装）;
类的访问修饰符只能public或默认，否则语法不允许。类中成员访问修饰符四种都可以。
java不建议默认的，建议“数据私有化，行为（方法）公开化”-------数据的私有化不包括超类，只有超类的数据用protected，其他的都是私有或公开
内部类下周一讲

6、static看当天的笔记、 StaticDemo.java和图，main写完一定先加载到方法区中（先编译生成.lass）

类只被加载一次，所以方法区中一个类只有一个，而堆中是new一次对象就加载一次

对象中的数据
访问实例变量用对象去点，访问静态变量用类名去点（用对象点也能可以，但java建议用类名点）

何时用：所有对象所共享的数据(图片、音频、视频等)：比如玩游戏地图，不可能来一个玩家服务器分配一次，只有一份，所有人共享

7、main一定是要有static的，计算机入口

8、13号上午193：00---(数组只要new了，所有元素都有默认值)在new的时候，系统会给所有的成员变量都赋默认值的---所以当天的StudentTest.java最后那两点注释就好理解了

9、18号下午StaticDome静态方法演示：
1）实例变量对象点，静态变量类名点---不加static的方法有隐式this传递，静态方法没有这个传递形式，实例变量加this也访问不到，而静态变量是类名点（看23条），类名点一定会有的，因为上来就是先加载类的方法区(她说没有类哪来的方法区啊)，而静态变量就在方法区中所以一定有(能访问到)，2）静态变量不依赖于对象来访问
3）访问静态方法系统默认加的类名点（一般不写，同类方法类名点就省了）
4）静态方法不能访问实例成员-----想在静态方法中访问实例成员可以先在方法中new出来对象，然后对象点来访问
5）PPT：由于static在调用时没有具体的对象，因此在static方法中不能对非static成员(对象成员)进行访问

10、自己做的类中方法不加static原因是：加了就不能访问类中成员。不过如果成员都加static也能访问，但成员不可能只有一份，比如Student里的name，各有各的名字，不能只加载一次（结合28看）


12：静态块：class Joo{
	static{//大括号就是语句块，加static就是静态块
	}
}
看当天的StaticDome：
执行过程
1）Joo o3 = new Joo()；把Joo.class加载到方法区里，系统自动走静态块，加载完之后分配对象，走构造方法
2）Joo o4 = new Joo();   方法区东西不变，只加载一次，new一个对象，走构造方法
类只被加载一次，
静态块属于类，在类被加载期间自动执行，只执行一次
何时用：加载/初始化静态资源(图片、音频、视频等)//初始化=加载
静态变量和静态块配着用，静态变量声明变量，静态块给静态变量赋值（也可以不用静态，但是多次加载浪费内存影响性能；或者也可以只做静态变量，在实例方法中赋值，但没必要，比如来敌机，虽然内存中就一张图片但是来一个小敌机对象我就接一次内存里的图片也没必要，在静态块中赋值就是在静态块中让小敌机等于这个图片）

13、所有飞行物都有图片但不适合放在超类，第一因为静态，第二因为图片不一样，数量也不一样，所以放在派生类中，自己做自己特有的属性

静态建议写在上边，静态加载的比较早，结构也清晰
多张图片逻辑也相关的，做成数组
读图片是共有行为，放超类

14、try--caturn--异常处理---看笔记

15、执行流程(18号下午206:00)：从main开始，走到new对象的时候，先加载这个对象的类（一个类只加载一次，多个对象一个类也只走一次），同时自动加载类中的静态块

16、静态块好处，只读一次，内存中只有一份，提高性能。实例的话new一个对象读一份，浪费内存；
所以静态资源放入静态块


#--------------------------------------OOP.day06----------------------------------------


1、final一般用来防止滥用继承伤害系统(String，Math，Double等就是final的)，不经意重写等，PPT有说明

2、面向对象三大特征：封装、继承、多态 ---final违背了面向对象的特点

3、static final：常量 结合static和final的特点
public static final：这三个词是一对，因为常量是要到处用的所以public

4、实例化=new对象，不完整的类(抽象类没有方法体所以不完整)是不能被实例化的，但new这个类的数组类型可以

5、抽象类的意义前两点是超类的意义，最后一点解释一下：以超类中飞行物的移动方法为例---不建议用普通方法，普通方法可以重写也可以不重写，但既然想统一用拿就做成抽象的----抽象方法能够达到统一强制重写的目的。
行为相同就用普通，行为不同就抽象(强制重写)

6、import java.awt.image.BufferedImage;作图片的，BufferedImage--图片类型

7、常量：效率高，在编译期用到常量的地方会直接替换成常量对应的数，且易修改


#--------------------------------------OOP.day07----------------------------------------


##内部类访问外部类的隐式前缀
		看课堂笔记及代码
 - 外部类名.this.
        表示 外部类的对象的
 - 可不写，但不可以只加this.
        因为this.代表 内部类的对象的


##匿名内部类
 - 当我们要声明一个类实现一个接口或者继承一个类，但这个类的实例我们只用一次的时候，用匿名内部类的话代码结构清晰很多，因为如果再创一个类但是只用一次明显显得浪费。
        例如：鼠标监听器-world.java，文件过滤器ListFilesDemo.java
 - 匿名内部类的方法就是直接new对象并且大括号内重写超类方法
 - 创建匿名内部类的时候干了三件事：看笔记。
 - 匿名内部类写出的东西结合了对象和派生类。new的是对象，大括号内是派生类体，在里边重写。
        参考射击游戏第七天action里的timer.schedule(new TimerTask){},---ctrl+左键TimerTask


##内部类的.class文件命名方式
        写一个内部类然后看工作空间可以发现。
 - 外部类名+$+内部类名.class
 - 如果内部类是匿名内部类-没名字,则把内部类名用数字123...表示
 例如：
		Mama$Baby.class
		NstInnerClassDemo$1.class
		NstInnerClassDemo$2.class
		NstInnerClassDemo$3.class
 - 当时说的命名规则1：只能包含字母、数字、_和$符，并且不能以数字开头，数字和$符在这里用到了，下划线在常量那里用到了。


3、判断if else或者 if	else if，不是根据干几件事，而是他有几种情况。

5、行为共有---超类；行为不一样---抽象方法

6、this.方法名()一般不用也没讲，只说方法名一般不会重复

7、Debug对射击游戏不合适，因为射击游戏是在窗口里运行的

8、定时器：java已经做好了
import java.util.Timer;-------定时器
import java.util.TimerTask;---定时任务


#--------------------------------------OOP.day08----------------------------------------


1、侦听器java做好了，是JPanel里的方法

2、java鼠标侦听器是抽象类但是没有抽象方法，其实就是java不想让你new对象，就是要你new派生类（匿名内部类）---当天上午92：00
--------我的理解：
	定时任务TimerTask里的run方法抽象，需要重写，是因为这个run方法我一定会用，既然要用定时工具那一定有定时任务-run；
	而鼠标侦听器里的方法我不一定每个都用，如果做成抽象我就必须得重写，但我可能用不到某个方法，所以不做成抽象方法；
	如果不做成抽象类，我可以实例化，但是new了之后没有任何意义，因为里边都是空方法，我要用的话要么重写，要么用匿名内部类，既然直接实例化没意义，那做成抽象类也就可以避免作出无意义的实例化。

3、处理射击游戏越界问题的两种方法：`此名字已被OOP笔记引用`
一、把越界的敌人删除
	public void outOfBoundsAction() {//10毫秒一次
		for(int i =0;i<enemies.length;i++) {//遍历
			FlyingObject f = enemies[i];
			if(f.outOfBounds()) {
				将f从enemies数组中删除(缩容)
	}
    }
}
在10毫秒内遍历敌人数组，在循环中把每个越界的敌人从数组中删除，有一个越界的就要进行一次数组的复制(删除缩容的本质就是数组的复制)，//假如40个敌人有20个越界，10s内遍历40次每检测出一个越界就要进行20次数组的复制，影响性能
二、把不越界的敌人整合到一个新数组中然后给enemies数组重新赋值
	public void outOfBoundsAction() {//10毫秒一次
		int index = 0;//1)不越界的敌人数组下标 2)不越界敌人的个数
		FlyingObject [] enemiesLives = new FlyingObject[enemies.length];
		for(int i =0;i<enemies.length;i++) {//遍历
			FlyingObject f = enemies[i];
			if(!f.outOfBounds()) {
				enemiesLives[index] = f;//将不越界的敌人放在enemiesLives数组中
				index++;//1)不越界敌人数组下标增一 2)不越界敌人个数增一
			}
		}
		enemies = Arrays.copyOf(enemies, index);//将不越界敌人数组复制到enemies中，index即为enemies的长度
	}
在10毫秒内遍历敌人数组，在循环中把每个不越界的敌人赋值给临时的数组，临时数组本身元素均为null，有一个不越界的就赋值到临时数组中去，最后在循环外把enemies数组重新赋值成临时数组，即把不越界的统一赋值给新数组，只进行一次数组的复制//假如40个敌人有20个越界，遍历40次每检测出一个不越界就赋值给临时数组，最后将enemies数组完全改为临时数组，10s内只需进行一次数组的复制

我还会想，如果没有越界子弹或者敌人，那第一种方法不更简单，第二种无论如何也要复制一次，但随着游戏的难度增加，越界的一定会越来越多，无需多虑

4、实现：注意实现接口的时候重写加public---参见16条两同两小一大
	接口是数据类型，是数据类型就可以被声明 
	**接口是完全抽象的抽象类**----接口编译也会生成.class---除了常量全都是抽象的
	接口也是一个超类
	接口可以向上造型
接口中：方法省略pulic abstract；数据省略public static final，省略后编译器自动添加

5、笔记中，设计规则第三点：符合既是也是原则---意思例如是即是得分又是奖励，就是同时有两种行为，不能继承多个超类，使用接口
		单根性：单一继承

6、以后会哪怕就一个类用一个方法，也做接口，易于拓展


#--------------------------------------OOP.day09----------------------------------------


1、凡是抽象的方法都是多态的

2、造型后能点出来的东西一般是少了，因为派生类的东西一般是多于超类的东西的,造型点出什么看引用

3、实现和继承都是父子关系

4、import java.util.Arrays;

public class test {
	public static void main(String[] args) {
		Aoo o1 = new Boo();
		//o1.text01;超类没有
		o1.show();//输出重写的--2
	}
}
 class Aoo{
	 void show() {
		 System.out.println("1");
	 }
}
class Boo extends Aoo{
	void text01() {
		System.out.println("3");
	}
	void show() {
		System.out.println("2");
	}
}

向上造型能点出来什么看超类有没有，超类没有派生类的有的点不出来。
能点出来的具体数据还是看派生类

5、碰撞是相互的，子弹和敌人碰撞以子弹或者敌人为参照物写都可以，但敌人也会和英雄机撞，方法体一样，所以写在敌人里好一些

6、写代码的时候，一般来说能用父类(超类，接口)就不用派生类。
设计没有什么标准，“复用性、拓展型、维护性” 好就行。

7、hero的命和火力是私有的，所以要做一个公开的命和火力怎增加的行为(方法)
数据要私有，公开不安全，别人能看到公开的，比如pos机刷卡

8、常量可以让代码更加清晰，因为常量名称比单纯的数字直观

##精华代码
 - **得分得奖励这里是精华**：接口的好处，多态的意义，造型的好处，强转的意义、instanceof判断!!


##多态之类型转换
 - 向上造型/自动类型转换&强制类型转换
 - 克晶老师：如果想访问的东西在当前的类型中没有，就只能类型转换成有你想要的数据的类型！
 - 强转要符合两个条件，避免异常/溢出要用if和instanceof判断。
		异常、异常：引用类型强转可能会异常。基本类型强转一定成功但可能溢出。
###引用类型强制转换之成功条件一
 - 满足**引用指向的对象，就是该类型**
 - 示例一：常见的迭代器强转
		Collection c = new ArrayList();
		c.add("one");
		c.add("#");
		Iterator it = c.iterator();
		while(it.hasNext()) {
``			String str = (String)it.next();
			System.out.println(str);
		}
``		解释：
		我们放入的是String字符串，而集合的设计为什么都可以放，所以底层已经将字符串向上造型
		而我现在要把Object类型的String，强转回String类型
		所以符合：引用指向的对象，就是该类型
 - 示例二：绑定数据的获取
		session.setAttribute(String name,Object obj); //绑定、修改数据
		Object session.getAttribute(String name); //依据绑定名，获取绑定值

		request.setAttribute("msg", "Hello!");
		...
``		String msg = (String)request.getAttribute("msg");
``		解释：
		getSttribute的返回值是Object类型，因为它设计的是什么都可以存。
		但是返回值对指向的还是我当时保存的String类型
		而我现在要把Object类型的String，强转回String类型
		所以符合：引用指向的对象，就是该类型
 - 克晶老师回复：转的时候是看具体指向的对象，这两个例子的具体是字符串类型。
		所以也就能再转成字符串
###引用类型强制转换之成功条件二
 - 满足**引用指向的对象，实现了该接口或继承了该类**
 - 以实现了接口为例，继承了类同理。
 - 克晶老师说强转是：大到小。我认为不严谨，因为我认为这第二种强转的两个类型没有大小之分。然后我又问了克晶老师，它说不必太纠结大小，它只是用大小来引入强转这个概念
 - 示例：**代码oo.day09-MultiTypeDemo.java**
		public class MultiTypeDemo {
			public static void main(String[] args) {
				Aoo o = new Boo(); //向上造型
``				Inter1 o2 = (Inter1)o; //o所指向的对象实现了Inter1接口
			}
		}
		interface Inter1{
		}
		class Aoo{
		}
		class Boo extends Aoo implements Inter1{
		}
``		详解：
		这个强转需要满足o指向的对象实现了Inter1才能成功：
		这里o指向的对象是Boo，关键在于Boo又实现Inter1又继承了Aoo；
		这样一来Boo在两个无关联的接口和类之间游刃有余，即可以造型为Aoo来使用Aoo的东西，也可以再从Aoo类型强转为Inter接口来使用接口的东西。
``		所以我认为，正是因为Boo的特殊性(即继承了Aoo又实现了Inter1)，让Aoo类型和Inter1类型可以利用二者都有的子类/实现类Boo来进行转换，而这Inter1和Aoo本身又没有直接地联系，所以叫强转！
###典型的ClassCastException异常：
 - 一直错误的思想是：子类引用指向父类对象就是强转，这是错误的。和'条件一'搞混了而已！
		Aoo o = new Aoo();
``		Boo o1 = (Boo) o;  ------ClassCastException异常
		class Aoo{
		}
		class Boo extends Aoo{
		}
####关于向下造型
 - 范传奇老师说：有继承关系的时候才有造型，强转更贴切的名字是向下造型。向上造型是自动的不用强转，向下造型需要强转(不要记强转这个词，记向上或者向下造型)
		--传奇第一天下午217：50s说的
 - 我认为他说的并不很对。向下造型并不能涵盖强转。
``	向下造型的意思明显是 小类型(子类/实现类)的引用指向大类型(父类/接口对象),这只是强转的成功条件一的形式
``	而强转的成功条件二形式，两个类型之间并没有什么大小之分，也就没有向下造型的概念。
 - **我认为强转应该=向下造型(强转成功条件一的形式)+强转成功条件二的形式**
 - **这是我的认为，没有啥权威说明，问了刘洋他说他感觉是这个样子**


##排除法快速找错
 - 方法代码多了之后打桩不知道在哪里找：以小敌机为例，先在run里剪几个方法，如果不报错那剩下的就没错，如果报错了就去看这个方法里面的代码，然后再剪方法里的一些，依次类推，排除不报错的，确定报错的，最后找到报错的原因。


#--------------------------------------OOP.day10----------------------------------------


1、删除越界--避免内存泄露
内存泄露是指内存数据垃圾没有释放造成系统内存浪费，导致程序运行速度减慢甚至系统崩溃等严重后果

2、实例变量都有默认值，局部变量没有默认值

3、方法区存类的信息，静态变量和所有的方法。

4、面向对象的"对象"和new的那个对象是一个意思。

5、类的鼻祖---Object

6、静态的先走，所以一般放上边

7、画图参数最后一个选择null就可以不用掌握

8、Debug演示时加static是因为他不想new。省事



#---------------------------------------SE.day01----------------------------------------

##---JavaSE---java企业级应用；API---应用程序编程接口
 - 学习java的庞大的类库，记印象、名称和用来做什么的就可以，具体怎么用可以查手册
 - 每一种语言都可以干你想干的事，只是各自擅长的领域不同，java擅长服务端，后台的业务逻辑，游戏有关的时技能伤害数据暴击什么的
 - 学完java买本安卓的书看一个月熟悉一下安卓类库就可以搞java了。安卓手机的开发者模式就是给我们用的，插上手机，手机就变成测试机了，打开开发者模式就可以跑/进行调试。


##Project-->clean作用
 - 清空原有的.class，并重新编译选定的项目
 - 有时我们写的代码没错但却报错，是因为在编译的时候，关闭程序什么的导致了小bug，重新编译就好了


##C&C++&Java
 - C语言：面向过程。  应用：硬件驱动...一般存在我们看不到的地方，比如驱动程序、机顶盒的东西，嵌入式的领域上
 - C++：面向对象。  应用：桌面游戏，比如暴雪公司的游戏，都是编译后直接生成机器码让cpu去执行，大型游戏运行速度快。
 - Java：底层是C语言，Java虚拟机都是用C写的


##文档注释
		文档注释是用于生成API文档的，API文档主要用于说明类、方法、成员变量的功能。
		看doc包-APIDocDemo.java
###注释类
/** 文档注释，是功能级注释。用来说明一个类的设计及功能，还可以说明常量及方法的功能。
 * @author mirage   提示作者，写自己的英文名。这个一般是一定要写的
		女生需要注意英文名不要乱起，老外的语言文化可能会以为你是...干啥的
 * @version 1.0   提示版本号，类的版本号。
		版本通常是由一个小数组成的
			整数部分是大版本号，大版本影响功能，增加了功能要修改大版本号。
			小数部分是小版本号，比如优化某些算法，改两个小bug。
		`查看成恒说的'版本号编号原则'`
 * @see java.lang.String   提示需要参考某个类，写类的全名。
		如果这个类要搭配某个类去使用，比如这个类用到了某个类核心的东西。
 * @since jdk8   提示由来，写始于哪个jdk版本，用的哪个版本开发的就写哪个。
		如果使用了哪个版本的特性，一定要写这个版本。因为特性是向下不兼容的，高版本的特性低版本不支持，要提示别人至少要在哪个版本以上才可以跑我这个类。
 */
 - 以上是常用的，还有很多：打一个@就出来了。
###注释方法
/**
 * 给指定的用户添加一个问候语
 * @param name 指定的用户名...   `参数和对应的含义，说明为什么加这个参数，这个参数有什么含义`
 * @return 含有问候语的字符串...   `说明方法返回的是什么`
 */
public String sayHello(String name) {
	return "你好！"+name;
}
###注释常量
/**
 * sayHello中的问候语
 */
public static final String INFO = "你好！";
###Export-->javadoc工具
		以下大部分为百度。传奇老师说文档注释可以加在类、方法、常量上
 - 由于文档注释是用于生成API文档的，而API文档主要用于说明类、方法、成员变量的功能。
 - 因此javadoc工具**只处理文档源文件在类、接口、方法、成员变量、构造器和内部类之前的注释**，忽略其他部分的注释。
 - 而且由于只有以public或protected修饰的内容才是希望暴露给别人使用的内容。所以javadoc工具**默认只处理以public或protected修饰的**类、接口、方法、成员变量、构造器和内部类之前的文档注释。
``		常量也可以啊。
 - 如果开发者希望javadoc工具可以提取private修饰的内容，则**可以在使用javadoc工具时增加-private选项**
 - 生成index.html文件，浏览器可以打开。
		在教室里的eclipse里打开的话容易卡死。Eclipse里的浏览器不好用，浏览器很大，电脑再不好运行就有问题。浏览东西还是用专业浏览器吧。
###查看index.html
 - “字段”中是解释常量
 - “构造器”中解释构造方法。如果没写构造方法的文档注释他就没内容
 - 等等
 - 传奇老师那个捕鱼的游戏也可以生成这个文件看一下。


##String
 - 在java中举足轻重，地位没人能憾动，可以逾越某些语法要求。
	地位--有特权：使用final修饰，不可被继承，可以用它但是不能拓展它，不然就不是特权了
 - String里面是char数组
 - 以字面量形式赋值虚拟机才知道要走常量池；new的话jvm是不走常量池的。
###字符串比较：
 - “==” 比较的是地址；
		==：基本类型比较值，引用类型比较地址值。
 - “equals“ 比较的是内容；(如果是没重写的equals，即默认的equals方法的比较规则同==，重写后可比较对象内容是否"相等"，java API提供的类大多都已经重写过equals)
###常量池：
 - Java为了提高性能，静态字符串(字面量/常量/常量连接的结果)在常量池中创建，并尽量使用同一个对象，重用静态字符串；
 - 对于重复出现的字符串直接量，JVM会首先在常量池中查找，如果存在即返回该对象。
 - 使用new形式创建的对象不会重用常量池中缓存的对象

##小项
1. java.xxx有很多包，各种领域的，我们用到的只是很少一部分，很多包这辈子可能也见不到。不从事某个领域可能一点都不会知道。
2. 王者荣耀：底层都是C/C++写好，安卓手机用java. 苹果手机用oc. 开发成本低。
``		好多游戏存档都有一个数据库，会看的话可以搞的，修改修改。
3. 安卓手机真正的操作系统是linux。root是Linux的超级管理。
	一键root的危害：一般各种管家的一键root功能，一旦同意了，那么这些软件就有了超级管理权限，这时候你的手机就是管家的了，所有的隐私都不是隐私。
4. 空白字符：空格，回车，Tab
5. return是可以单独写的，在无返回值的方法中单写return跳出方法的执行，return以下的不走


#---------------------------------------SE.day02----------------------------------------


1、StringBuilder 和 StringBuffer PPT有总结
StringBuffer是元老
考虑他的线程安全问题相当于在沙漠里怕被海水淹死

2、正则表达式只能规范格式，不能验证有效性。有效性可以用接收验证码的方式检验

3、正则表达式，也叫正规表示法，常规表示法。来源很早的科学研究，是计算机科学的一个概念，java认为好所以引入进来
  java中 ^[abc]{3}$=[]abc{3} --给定的正则表达式就算不指定边界匹配(^...$)也是做边界匹配验证的    
  PPT上是标准的正则表达式用法，在java字符串中不是那么用的

4、\w+@\w+(\.[a-zA-Z]+)+
    字符串和正则表达式都有转义符，但是内容不一样，所以字符串中要补一个\
   直接copy会自动补上\
    特殊的：\\----\\\\

5、object=东西，物件，对象
一切皆对象，什么都是东西
object里有极少的方法，是用来为程序服务的

6、二进制相关：
加1变成负数，是因为进1改变了符号位
包装类提供的互转操作 例：
int转byte是把二进制int的最后一个字节截取给了byte，第一位被byte当成符号位

6、我们平时上传照片后照片被改的名字：那一串数字：照片上传后改的名字是上传时间的毫秒数--15646831231867.jpg

7、java的属性：每个类的三个组成部分：属性，构造方法，普通方法。属性就是变量

6、六个基本类型的包装类，因为都是数字所以继承了Number，再往上是Object
char和boolean的包装类上边直接是Object
Number是一个抽象类，定义了数字之间的转换方法


##自动生成get-set方法的操作
 - 右击Source-->Generate Getters and Setters...


##自动生成构造方法的操作
 - 有参构造：右击Source-->Generate Constructor using Fields...
		fields：字段
 - 无参构造：右击Source-->Generate Constructors from Superclass...


8、toString本身只返回对象的地址，存在的意义应该是重写后调用返回对象的内容特征
System.out.println(对象）=System.out.println(对象.toString())
另外：System.out.println("p:"+p)=System.out.println("p"+p.toString())
连接字符串时不写.toString也自动调用p.toString()方法


#---------------------------------------SE.day03----------------------------------------


1、点项目名，f5刷新可以刷新出项目目录下的文件

2、缓存在cpu、硬盘、都可以有，内存是最大的缓存，缓存都是易失性的
OS=操作系统=电脑的主程序=电脑的综合管理系统

3、相对目录中的当前目录"./"是可以忽略不写的,默认就是在当前目录中

4、raf.close();//释放文件。文件流用完之后必须及时通过close方法关闭，否则会一直处于打开状态，直至程序停止，增加系统负担。正在用一个文件的时候不能删除也是因为这个。

5、实现一个接口以后，不知道里面有什么方法，可以点一下报错“x”字，Add未实现方法然后改下内容就好了。以后就这么做

6、软盘：保存图标是3.5英寸软盘的样子，软盘是最早的可移动储存硬件，比硬盘、u盘出现的早，通过软驱进行读写操作。已被淘汰。A、B盘就是以前的软驱

7、cpu纳秒级反应、硬盘毫秒级反应，百万倍(1毫秒=100W纳秒)差异。当天9.17视频说的，引出内存，内存和cpu速度相当

8、mkdir也是linux创建目录的标准命令
读mk=make +dir

9、回调模式，file包ListDileDemo2里有，指我只传了参数，没有主动调用那个方法，他自己内部调用。

10、之所以写入int值的对应而进制低八位，是因为write方法的参数类型是int，而计算机写入也是一个字节一个字节写的

11、为什么文件末尾是-1表示  如果是写入的也是-1不冲突吗：int型-1四个字节32位都是1，而写进去只是低八位，所以正常读一个字节永远读不出-1，因为一个字节只能0~255,想表示int型的-1必须得4个字节。也可以用别的数字表示，比如-2，256，等等，但是没必要写那么繁琐，-1最接近最好写。

12、为什么写入的是1但是记事本打开不是1，而写入的97记事本打开是a。因为记事本不把写进去的数字当作数字看，而是写其int值对应二进制的低8位


#---------------------------------------SE.day04----------------------------------------


1、复制文件时10k一组效率已经很好了，机械硬盘有读写极限的，就算改成1m提升也不大，过两天会知道java内部默认的也就8k----即缓冲字节流一次8k

2、字符集：就是UTF-8，GBK等

3、write只写低八位，一个字节

4、RegDemo.java：
Scanner以后会很少用，这是在控制台输入的，以后开发产品人家都是在客户端输入，不会在服务器输入- -。
统一用nextLine，年龄也是，输入字符串后用Integer.parseInt()转成int。
因为如果一直用Scanner也会出错---------------4.40分左右多点

5、byte[] getBytes() 括号里最好指定清楚字符集，不然按照系统默认的，而有可能会忽略系统默认的是什么，万一是GBK外国人访问基本不是GBK就乱码了

6、我即使指定了字符集在eclipse里打开有可能是乱码，因为eclipse按照eclipse默认的字符集打开，如果不一样就有可能乱码。

7、nextLine()和next()：举个例子，输入一行 abc cde efg  结合网上搜索和自己测试 
next()返回的是abc    返回的是从第一个有效字符开始到下一个有效字符结束，过滤掉有效字符前面的无效字符(空格、Tab、Enter),读取到有效字符之后把其后的空格、Tab、Enter视为结束符
nextline()返回的是整行 abc cde efg 返回的是一整行，以Enter为结束符


#---------------------------------------SE.day05----------------------------------------

1、IO:Input和output
流：想象成家里的自来水管，连接水厂和家里。水就是流中的数据。
数据源：水源，电源，键盘，文件。
节点流就理解成水管

2、文件流在new文件的那一刻，就算有数据了也全干掉---覆盖写模式

3、flush清空缓冲区，即时写出。
像聊天这样的就要用flush；
复制可以不用flush：因为用close方法关流时(查看close源码可知)其方法内部有自动调用flush。而如果在缓冲区(8k)没装满的情况下即不调用flush也不调用close则数据不会被写入，数据会一直在缓冲区。

4、所有流都有flush方法，(我觉得是因为其都继承父类OutputStream，父类中有flush方法。而范传奇说的不是这样，他说的我不理解，他说因为高级流套高级流再套低级流要关的话是关最后的那个高级流，而其flush方法是调用低级流的flush---15：43画图讲的)
但是只有有缓冲功能的流的flush方法里才会重写fluse的内容；
其他流的flush是空的方法
比如文件流对象也可以点出flush方法，但是查看其源码可以发现其并没有重写flush方法，源码为父类OutputStream里的。    15：43讲的

5、范传奇说winidow有个特性，应该每个系统都有吧：上次用java块读写复制文件之前用系统复制过一次，这时候文件已经存在缓存(内存)里了，所以用java复制的时候快了一些，因为数据在内存里。

6、流和raf相比：
流是顺序的读写，raf可以定指针位置随意读写；
流不只能读写文件，还可以读写其他设备(读键盘，网路等以后学)，但是raf只是专门读写文件的
两个类都有read和write但是方法内部不同
各有千秋

7、所有的字节输入流的父类：InputStream
   所有的字节输出流的父类：OutputStream
   字节流就是读写字节的流，文件流是字节流，且文件流是IO学习中唯一的低级流

8、io：OISDemo：
Person强转是因为源码返回值是Object
(对象流ois.readObject();要抛出一个没有发现类的异常，是因为其要判断来的字节是不是一个java对象，如果不是就会异常，比如我输入流一张图片，显然不是java的对象。。。我觉得以后就知道了吧，先记着)

对象流可以用来存档，将对象的数据写入硬盘，下次玩的时候还原

9、io：person实现的接口Serializable是一个签名接口
我们写接口的目的是为了约束派生类的行为，规定派生类行为，要求派生类必须重写接口内的抽象方法
签名接口：签名接口对编译器敏感，当编译器编译一个类的时候如果发现其实现了签名接口会隐含的在编译后的class文件里加入方法(把当前类实例转换为一组字节，即序列化的过程)，如果在源码当中体现则我们还得重写--——你写啊，这么麻烦

##序列化版本号
 - 实现了Serializable接口或继承的父类实现了这个接口的类：类左边警告点一下会出现add一个默认的序列化版本号和add(根据当前类去生成)生成一个版本号。选默认就行
 - 序列化版本号影响着反序列化是否能成功，即使我源代码没定义版本号，只要实现了Serializable接口，编译后的class文件里一定有序列化版本号。如果自己没定义，则编译器会根据当前的源代码接口生成一个long值作为序列化版本号
 - 当对象输入流把一组字节还原为对象的时候，他首先会检查还原的对象的序列化版本号和现在要还原的类的版本号一样不一样：一样则还原，不一样则不能还原
 - 在版本更新时，如果换了版本号以前的存档就通通不能用了，想用的话就改回来或者重新写一个对象。想兼容就不改版本号。新版本改掉的属性如果存档里还有那还原后就不要了，如果存档里有的在新版本还能用的就还原。-17：38分


##小项
 - 谷歌怎么离开中国的！！！？？？


#-----------------------------------SE.day06_苍binary-----------------------------------


###见刘苍松老师binary笔记


#---------------------------------------SE.day07----------------------------------------


1、Reader所有字符输入流的超类 Writer所有字符输出流的超类。字符流只适合读写文本数据。(相对于字节流也就是字符串转字节的那地方不用自己写了)；字符流就是自动的把字符转化为byte，用的就是二进制计算

2、所有的流都有一点缓冲,所以关流要关最外边的流,关里边的可能导致一些在外流缓冲的数据没完全读写完

3、PrintWriter查看源码知道其内部链接了三个流以及自身共四个流，各自功能看当天笔记的图

4、PrintWrter的自动行刷新的构造方法:
若第一个参数为一个流，第二个参数为一个boolean值，true时则具有自动行刷新
若第一个参数为文件名，第二个参数为字符集，则没有自动行刷新功能

5、java的异常处理机制很好

6、try只要捕获了异常虚拟机就当你解决了，catch里可不写,不写就当无视异常

7. 控制台的红字(System.err.println())黑字(System.out.println())每次运行位置显示的可能都不一样,是因为它们两种输出是并发(不是一个线程)的,每次运行被分配时间片都是随机的

8、Exception和Error都是Throwable的字类
Exception是所有异常的父类，表示由于网络故障，文件损坏，设备错误，用户输入非法等情况导致的异常(Exception e写在最后，用以在意料之外的异常处理)
Error表示运行环境出现的错误，比如系统崩溃，虚拟机错误，JVM内存资源耗尽等，

9、FinallyDemo2、AutoCloseDemo中：关于关流的异常处理
首先明确一点，关流要在finally里关，因为如果在try里关，那一定是读写等操作完毕之后关流，但是IO本身就有异常处理，如果发生输入输出异常那就走不到close了，直接跳到catch，所以要放在finally中，就算发生了IO异常也要走到finally中。

而放在finally中因为作用域的影响，流的定义就要在try外边。并且发现close本身依然要处理异常，则要继续try-catch见Demo2，并且关流的异常只加个try-catch就行了。(其实这里close依然有可能关不上，那就还得加finally。但是加了finally后可能还关不上，那还得加try-catch-finally...依次类推就递归了，其实一次关不上，次次关不上，所以一个try-catch就好。

1.7之前要像FinallyDemo2中一样自己处理关闭流的异常，且因为作用域的影响，流的定义要在try外面--15.52
在try的小括号中初始化流只有jdk1.7之后才能用，自动关闭流；其实编译后还是改成了FinallyDemo2中一样

10、finalize方法如果进行耗时重写的话，会把“GC”卡住，其他无指向的对象无法被释放

11、异常：
先看第一行红字，看异常是什么
(一堆的at真正出错的原因在第一个at(但是一般以后工作了前边的都是公司或别人的框架，进不去或者进去了也改不了))
再看从上往下看到第一个自己写的包去处理
一层层往外抛出，最后从main抛出到虚拟机(系统)中程序就被杀掉了

12、常用字符流：缓冲字符流(BufferedReader)：
读写字符时有缓冲字符流就不用缓冲字节流了，缓冲就是为了加快速度，一个缓冲即可
(BufferedReader br = new BufferedReader(isr,1024*10);重载方法，可指定缓冲区大小，默认8K)

13、转换流是真的做转换工作的所以在OSW或ISR括号里加utf8

14、PW有直接写文件的构造方法，直接写文件时内部其实存在4个流(源码可见)，参数用(文件名，字符集)
不直接写文件的流连接的构造需要自己写四个流，参数用(流名，boolean)，true时有自动行刷新，自动行刷新需要检测到换行符才读写一行自动flush，且要用pw.println方法读写，用pw.print无换行符

15、throw是主动抛出异常，如果调用者进行异常操作运行后就异常，throws提醒调用者可能会报异常，强制调用者运行前做异常处理
以前直接在main那里thows抛出异常就不报错了，是因为把异常从main里抛出到了调用main的JVM(因为是JVM调用了main)，让JVM来做异常处理，而且没有触发异常操作。若触发了异常处理则JVM会杀掉程序。


#---------------------------------------SE.day08----------------------------------------


1、RuntimeException:非检测异常，执行时期异常：其实可检测异常和非检测异常都是运行期发生异常，只不过是在编译器中警告不警告的问题。
非(不)检测异常：RuntimeException及其子类，子类如空指针、下标越界、类造型异常等，所以RunrimeException也叫常识性异常。不要求有处理手段是因为太常见，比如空指针，我们只要new个对象或方法就有可能会操作出空指针，即使不出异常，在new或调的时候也得处理来避免发生异常，那异常就随处都得写了。很麻烦。

2、e.printStackTrace();意义在于输出异常助于让程序员定位错误并改正代码；若不写的话系统因异常杀掉程序的时候自动调用。

3、Exception e 还有个方法是e.getMessage();可以获取一个字符串，即错误消息，一般提示给用户看的，告诉因为什么产生的错误。但是不是所有的异常都有message，比如空指针就没有--此方法不重要--9：43,exception-ExceptionApiDemo.java

4、苹果收费的安卓不收费，是因为安卓可以利用数据，上传苹果商店的应用要先把源码传到苹果，检测有没有对用户隐私监控侵犯


6、聊天室不做界面了，做的话可以研究一下UI的可视化界面

7、通讯协议
   TCP协议：可靠的传输，一块一块发送，每块发完确认收到然后回应服务器再发第二块，如果没收到或不完整则重发这块，数据是完整的
   UDP协议：不可靠的传输，只整体发一遍，爱收到收不到，速度快
    往往UDP模式比TCP模式多，比如视频、音频、游戏人物突然不动弹，卡了(网络通讯受到干扰，丢包了，网络通讯很繁忙，也需要即时性，服务器不会给你用TCP重复)
(丢包：通信中指通信数据包丢失，数据在通信网络上是以数据包为单位传输的，每个数据包有表示数据信息和提供数据路由的帧，这就是说，不管网络情况有多好，数据都不是线性连续传输的，中间总是有空洞的。数据包的传输，不可能百分之百的能够完成，因为物理线路故障，设备故障，病毒攻击，路由信息错误等原因，总会有一定的损失。碰到这种情况网络会自动的让通信的两端根据协议来补包。如果线路情况好，速度快，包的损失会非常小，补包的工作也相对较易完成，因此可以进四的将数据看作是无损传输。单是，如果线路较差(如用调制解调器)，数据的损失量就会非常大，补包工作也不可能百分之百完成。在这种情况下，数据的传输就会出现空洞，造成丢包。)

##系统体系结构
 - C/S：客户端(Client)和服务端(Server)
 - B/S：浏览器(Browser)和服务端，(其实bs也是cs)，浏览器相当于客户端统一，因为一个浏览器能访问很多服务端，不用分别安装不同服务端的客户端

客户端不能连客户端，主动发起连接的是客户端。

9、本机127.0.0.1=localhost
localhost：也叫local，正确的解释是：本地服务器。是不经网卡传输的，它不受网络防火墙和网卡相关的的限制。
127.0.0.1：在windows等系统的正确解释是：本机地址(本机服务器)。是通过网卡传输的，它依赖网卡，并受到网络防火墙和网卡相关的限制。
参考https://blog.csdn.net/qq_21831899/article/details/71170488

域名： 域名可解析为IP，通过DNS(域名解析服务器)
域名（英语：DomainName），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置），最初计算机少都用的IP，随着计算机的普及数字的IP不好记所以有了域名

网站名和域名：
 https:// www.3vjia.com---https://是网页传输协议；www是服务器名；3vjia.com是域名(A.B式的结构。A是可以认为是域名的名称，B一般指域名的类型)；www.3vjia.com叫网站名也叫主机名，参考：http://www.cnblogs.com/yaolin1228/p/8590533.html
 https://www.admin5.com/article/20170612/754553.shtml
 
localhost首先是一个域名(如同baidu.com)，也是本机地址，它可以被配置为任意的IP地址（也就是说，可以通过hosts这个文件进行更改的），不过通常情况下都指向：（如下）
IPv4：表示 127.0.0.1
IPv6：表示 [::1]

常见域名类型：
.com：用于商业机构，最常见的顶级域名，任何人都可以注册.com域名
.net：最初用于网络组织，例如因特网服务商和维修商。现在任何人都可注册.net域名
.org：非盈利的组织和协会，现在任何人都可以注册.org域名

10、端口号：
每个应用程序在使用网络的时候都会向底下的操作系统申请一个端口号
端口号是计算机分配给每个需要互联网的应用程序的号，收发数据的时候通过IP找到计算机，通过端口号找到要通讯的计算机的应用程序(类似于打10086的10086(IP)和客服号(port))。
客户端端口号也叫临时端口号，因为每次启动使用网络的应用程序的时候操作系统都会自动重新给他分配一个端口号，服务端在收到访问后，也会知道来自于哪个IP的哪个端口。

自己写程序的时候服务端端口号可以随便写，但有限制：不能重复；且2字节以内整数0-6W+；
大部分都喜欢用四位数：前1000肯定不要去用，这些密集得绑定着系统的端口；前3000-4000都不要用，一般绑定的是系统上和流行的应用程序的端口；6000-8000松散得绑定一些端口，可选范围就比较大了；建议前6000不要考虑，一般用8000靠后，基本不会重复  重复的话运行会报错

端口号是服务端决定的，服务端的端口号不能随意该，改了客户端就不知道连接服务端的哪个端口

11、理解：
Socket-可理解为电话
ServerSocket-理解为总机

12、linux终端看ip：/sbin/ifconfig------172.230.8.215

13、多态的返回：-15：43
OutputStream out = socket.getOutputStream();
首先，用所有字节输出流的超类OutputStream接收，用意是你不用关心我返回的输出流叫什么名，你只要当成字节输出流看就行了，返回的肯定是他的某个字类的
其次，这个OutputStream是一个抽象类，可能纠结为什么返回一个抽象类，其实不是，我们用这个抽象超类去接收的是他的子类，子类并不是抽象的。而用超类接收的用意则为"首先"所说

14、readLine()返回null表示流读取到末尾 在io的BRDemo.java里有说

15、当天的图注意看，对比昨天的图看


#---------------------------------------SE.day09----------------------------------------


1、死循环下边的为不可达代码，会报错

2、多线程：
计算机就是因为有多线程技术才变的丰富多彩
其实cpu一个时间只能完成一个事，但是纳秒级反应特别快，所以可多线程每个事都干一点，齐头并进；
单核心多线程和单线程处理事件的总时间是一样的，多线程可以同时看到效果；
多线程模式即并发运行
人眼30帧就不卡了，标准60帧

CPU提高性能的指标：晶体管的集成规模和震荡发生器的震荡频率(高低电压变换101010，震荡频率越快计算次数越多)
(G)Hz即震荡频率;摩尔定律(单位面积的晶体管数量每2-3年翻一倍)，而振荡频率(物理属性瓶颈)到达频率

则在一块CPU(一块面积)上做多个核心：
多核心时代-酷睿core:核心
一般一个核心对应一个线程，英特尔的超线程是利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器使用线程级并行计算，减少cpu闲置时间，提高cpu运行速度。(可百度：超线程)
处理器的指标几核几线程的线程是真正的物理上的多线程：cpu有几线程是真正意义上的cpu可以同时干几件事

3、进程是操作系统中运行的一个任务(一个应用程序运行在一个进程中)，操作系统给每个进程划分一个独立的内存区域，进程所包含的一个或多个执行单元称为线程，一个进程下的所有线程共享所在进程的内存空间。cpu切换进程时间开销大(因为跨内存空间慢)，而跨线程负荷小(因此线程也被称为轻负荷进程),所以同时开几个应用比开一个应用在应用里干很多事要慢。进程受控于操作系统，如果进程里一个线程都没有，就会被操作系统杀掉
------看PPT还有很多知识

4、并发原理：多线程"同时"运行只是感官上的一种表现，实际上线程是并发运行的。依靠线程调度程序--线程调度器OS将时间划分为很多时间片段(时间片)，尽可能均匀分配给每线程分配时间片。
并发调度器有两种：顺序调度和随机分配形式，java中是随机分配形式。
百度知：java虚拟机采用抢占式调度模型，优先让优先级高的线程占用cpu，若优先级相同则随机选择一个线程使其占用cpu

5、线程方法：start，调用start则线程就会被纳入到线程调度管理中，由线程调度器分配到时间片后自动执行run方法(run方法是Thread中要重写的方法，用来定义线程要执行的任务)
调用start方法的先后和执行的先后没关系，都是一瞬间的事，几乎是同时加入到线程调度管理中，不一定先进去的被先分配时间片

6、Thread其实实现了Runnable
创建线程的两种方法：
ThreadDemo1、继承Thread,(其实写成匿名内部类更方便),这样写的类不能继承别的类。(如果将来需要临时创建一个线程用继承用匿名内部类还是不错的)
ThreadDemo2、实现Runnable，这样如果需要继承超类方法的话，子类就可以去继承超类

优缺点：
方法一：缺点：继承线程就不能再继承其它类来复用方法，并且任务和线程有耦合关系；优点：用匿名内部类代码更简单
方法二：优点：用接口可以再继承其它类来复用方法，并且线程可以重用。

关于耦合关系：
用继承是直接将线程的任务定义在了线程中，导致线程只是为了执行这个任务，不利于线程重用
用接口是单独定义线程任务，在用线程的时候再传参给线程。线程是可以重用的。节约资源。(一条线程应该是有很多复杂的东西组成的，所以重用线程有利于节约资源开销)
-------------此条全部内容再当午饭前讲的

7、PPT：线程状态图：Runnable是可运行状态，Running是运行状态。被CPU执行的线程进入Running状态，时间片用完后回到Runnable。XX Block是阻塞状态，有如图三种Sleep阻塞IO阻塞Wait阻塞(这个不常用了)，当一个线程进入阻塞状态，cpu立刻转到别的线程

8、Server-在等待客户端连接的while(true)中：//调用start()时t纳入到线程调度器中，t不是参数，而是任务，所以不存在循环来一个t会取代上次的t的问题，线程任务已经纳入到了线程调度器中。

9、thread-CurrentThreadDemo.java
首先线程重写了toString方法，所以输出的不是句柄。
Thread[main,5,main]表示：Thread：表示是个线程；里边分别是线程的名字、线程的优先级、他所在的线程组(线程组不强调)
运行main方法的线程一般称为主线程。线程名字可以改，但如果不是特别需要关注的线程不需要改。

10、了解线程信息thread-ThreadInfoDemo.java：首先获取主线程Thread XXX = Thread.currentThread()；
id：唯一标示，以后有很多个线程的时候可以用id区分；是根据跑起来的顺序一个一个编的：主线程是1，其他的每次运行有可能都不一样，因为JVM还有很多线程    (如果不在一个线程组(就是线程池)，线程名字可能会一样，而线程ID一定不一样)

返回方法is开头的一般都是布尔型-行业规范(潜规则)
isAlive：线程是否活着；isDaemon：线程是否守护线程(后台线程)；isInterrupted：线程是否被中断了

11、理论上线程优先级越高，获取CPU的时间片的几率越高---理论上。(比如影响用户体验功能的不能卡)
线程默认优先级是5；10最先执行，1最晚执行。------关于优先级和执行次数的关系，不好查。


#---------------------------------------SE.day10----------------------------------------


1、守护线程放的任务：不关心其什么时候结束的，跟着进程的其他线程走，所有都停了他也停的任务。比如GC就是运行在守护线程上的。网络通讯也可以放在守护线程上。守护线程走的时候和其他线程都一样

2、sleep()和join()方法都是进入被阻塞状态的方法，用时都需要处理(try-chtch)中断异常InterruptedException e；防止线程的阻塞状态被中断方法(interrupt())中断

3、thread-JoinDemo:在run方法中throw是模拟 图片未加载完就显示 的异常(throw一个非检测异常不需要在方法上写throws--exception_JoinDemo),这时把异常抛出到run方法之外 那么如果出现异常就会将线程杀掉，只杀线程(因为run()是线程去运行)，不杀整个程序------------------------------------------看第2条：那怎么在download中调用show的中断方法interrupt()---------————！！！？？？不用看录播

4、关于JDK8的要求。要把开关isFinish放在main外面定义成属性，--10.42为啥我改成在main里不加final还报错，不用看录播了

5、synchronized比喻为上厕所锁门，使排队运行。
解决多线程并发安全问题(抢，带来的混乱)：多线程在操作同一段资源的时候，这个资源是：临界资源；
当多线程在操作同一段资源的时候则会发生多线程并发安全问题(形成：抢)
解决即是将抢变位排队，方法是上锁。

thrad.SyncDemo：
yield：主动让出时间片，下次有可能又给他，所以也存在概率
在成员方法上直接使用synchronized，那么同步监视器对象就是当前方法的所属对象，即方法中看到的：this 

thrad.SyncDemo2：同步块：有效的缩小同步范围可以保证并发安全的前提下提高并发效率。
synchronized(this)中的this指的是当前对象，new的对象叫shop，t1和t2调用的都是一个shop，this就是同一个shop。(若new两个Shop，分别调用不同的对象的buy，就相当于进了两家店，锁的都是各自自己的门)

thrad.SyncDemo3：
方法分为成员方法(所属于对象)、静态方法(所属于类)
所以在thrad.SyncDemo3.java中，在static dosome上锁，分开new对象分别调用方法，依然有同步效果。是因为静态方法属于类，不管用哪个对象调用，都是属于类的同一个方法。
synchronized修饰静态方法就不再关注调方法的是哪个对象了。(成员方法和对象有关，静态方法和对象无关)
静态方法锁的同步监视器对象为该方法所属类的类对象(Class的实例) ；
在JVM内部，每个被加载的类都有且只有唯一的一个Class的实例与该加载类对应。以后讲反射的内容中会介绍Class类

thrad.SyncDemo4："synchronized"出去工作的是时候叫"同步锁"，也叫"互斥锁"
一个类的几个方法都有"synchronized"修饰，则方法是互斥的
若都锁，则A、B方法均有锁机制，走到带锁的方法，会看对象有没有被锁，发现对象被锁则等待
若A方法锁，B方法不锁，当执行到A时给对象上锁；当执行到B的时候发现B没有锁机制，也就不需要关心对象有没有锁。则A、B可同时执行
（一个对象有多个方法：排队现象的流程是，看方法有没有锁机制"synchronized"，有则看对象是否被锁，锁则等；没锁则就不用看是否对象被锁，则不等直接进）

6、关于StringBuilder(无synchronized修饰)和StringBuffer(有synchronized修饰)的使用，看是否在多个线程的情况下修改同个字符串。若单线程则不用考虑并发安全问题，节省性能开销则用stringBuilder()


#---------------------------------------SE.day11----------------------------------------


1、Server关于客户端断开连接后抛的异常。linux和windows执行的方式不大一样
linux的客户端断开连接服务端检测到null直接退出
windows的客户端断开连接服务端readLine方法报异常，先走catch后继续执行下边的

2、解决server的并发安全问题，上锁对象为allOut数组
多个线程操作同一个数组，形成"抢"，则会发生并发安全问题：
若两个客户端几乎同时连接，创建两个线程，第一个客户端走到扩容数组后，还没来得及把输出流pw放入数组最后一个，时间片用完了；恰好第二个客户端也走到了扩容数组，而他时间片足够，所以把自己的输出流pw放入了数组的最后一个。这时第一个客户端轮到了时间片则继续进行把他的pw放入数组最后一个，则造成数组空了一个，且空位后面原本的第二个客户端的pw被第一个客户端的pw替代。                 ----此安全问题详细可参看11：35

3、集合：
所有集合的接口：Collection
集合放的是元素的引用，若把基本类型放进去如X.add(1); 则要自动装箱转成包装类。
(可参考integer-IntegerDemo.java,包装类的自动拆装箱；以及SE.day10:在JVM内部，每个被加载的类都有且只有唯一的一个Class的实例与该加载类对应)//(百度：泛型要求能包容的是对象类型(泛型类型只能引用类型)，而基本类型在java里不属于对象。但是基本类型都有其包装类型，也就是对象类型)

空集和null，以杯子为例：
空集是杯子里没东西
null是有没有这个杯子


4、add：有返回值为boolean添加成功则返回true：boolean add(E e)，E-泛型，后边讲(现在当成Object用，什么都能往里边放)
   不可重复集HashSet：不可重复，若添加了重复的元素就会返回false。
   可重复集ArrayList：没有添加不成功，返回均为true
 reamove：
   remove方法在ArrayList中只删除一个元素，找到符合删除的元素后后边的就不看了
   remove方法有返回值，返回true则删了，返回false则没删：假设集合里根本不存在传进去的元素，则返回false

5、collection--Point.java,ContainsDemo.java
集合中contains的判断依据取决于集合中类型的equals，若有比较为true的，则集合认为包含该元素。在这里我们重写了。有一些我们自己造的类型(Point)默认的是Object里的equals方法(则和"=="的比较规则一样，不能比较对象内容,只能比较对象地址和基本类型的值)


6、16：40的内存图很棒,在草稿纸上当面试题做的,勿眼高手低：
字符串拼接一定会创建新对象
不同方法的栈不一样，方法执行完毕，所有变量和没引用的对象清楚

7、addAll()：把给定集合元素放到当前集合当中去
不同类型的集合可以进行并集操作(collection_CollectionDemo3)；
若并入HashSet后会有重复元素，则重复元素不并入，不重复元素并入；
addAll有返回值为boolean，若当前集合元素发生改变则返回ture；

8、 HashSet内部顺序和添加顺序不一样，所以不能通过下标提取元素；
HashSet和ArrayList均可以通过(统一的遍历集合元素的方式:)迭代器模式(collection-CollectionDemo3)进行提取等操作


9、建议集合里放同一类型的元素，这样取的时候用向下造型接收就可以。
   不然的话要用Object取，之后还要判断是什么类型来分类接收(collection-CollectionDemo3)


#--------------------------------------SE.苍day12---------------------------------------

 - 接口的方法不能直接用，演示接口的方法用实现了接口的类来演示；今天用实现类演示List接口，ArrayList和LinkedList  都实现了List接口，演示的方法其两个类都有


##迭代器&增强for循环(for each)
``		for each 快捷键：打出for之后Alt+/选foreach，会自动从本行代码之前找最近的数组或集合生成for中的代码。
		collection-IteratorDemo.java
 - **迭代器**：
		先获取遍历该集合的迭代器
``		Iterator it = list.iterator();
		`问  hasNext()：如果仍有元素可以迭代，则返回 true。
``		while(it.hasNext()) {
			`取 
``			String str = (String)it.next();} 
 - **for-each**:
``		for(String str:list){   }    for(元素类型 元素变量:遍历对象){   }
		foreach语句底层是由Iterator实现的，编译器会重写为标准迭代器的形式
 - **java API规定：不要在遍历期间使用 集合的remove()方法**，要用迭代器的remove()。
		collection-IteratorDemo2.java
		原因：CSDN-'关于使用迭代器对集合进行遍历时，不能对集合进行修改的论证'  已转载
			简述：迭代器是通过集合获取的，如果在使用迭代器进行对集合的遍历时，对集合自身产生结构上的变化的时候（add.remove,clear等），例如：遍历时对集合当前向的下一项做了删除的操作，当再一次调用next（）,就会出现混乱。  源码解读看CSDN
 - for each循环 和 标准的迭代器接口循环 的**唯一区别**
		collection-IteratorDemo3.java
``		for each循环不能删除元素。若在遍历期间删除元素，不能使用增强for循环。要用标准的迭代器接口循环。用迭代器接口名.remove()。
		推测：因为遍历期间删除元素要用迭代器的remove()。而for each的迭代器是在底层实现的，取不到它的迭代器接口。        但是：我百度到并且文档中存在一个方法：Collection<E>接口的iterator()方法：返回在此 collection 的元素上进行迭代的迭代器。我没有深入实验，但是稍微试了一下在for each上使用会出异常，按说不应该。回头研究！！！？？？


##泛型
		collection-IteratorDemo4.java
 - 泛型意思是：<>这里默认放什么类型都可以，放入一个类型即会约束元素类型
 - 泛型约束集合中的元素类型。用泛型后迭代器接口不需要加括号强转，for each循环可以把Object写为对应类型。
 - 项目注解中"自动类型"加引号，是因为实际上并不是自动转，而是编译器帮助写。
 - java编译器推荐使用泛型，不用泛型会出现黄线：编译警告
 - **JDK7**开始之后的版本，new对象时可以省略泛型的类型，直接写成空括号: <>。(JDK7之前="new"后边的<>是<String>)
		范传奇建议写全:“是啥就是啥。”<String>

##ArrayList和数组的区别
		苍老师描述：
 - ArrayList底层(本质)就是数组，但数组没有方法；List在数组之上添加了算法，封装了一些方法，使用起来更加简便
 - AraryList提供的通用方法，没有专业方法快；如果拿数组写一个专业方法，运行性能一定比ArrayList快。
		飞机大战用ArrayList写更简单，但是没挑战性，并且执行性能一定会低一些，不过看不出来
 - 看'数组&线性表&链表详解'


##数组&线性表&链表详解
		百度百科"线性表、顺序表、链表、头结点、头指针、尾结点、尾指针等"
		以及https://blog.csdn.net/foreverhuylee/article/details/38780051
###A：数组
 - 概念：在内存空间(物理层面)连续储存一组数据的数据结构。
 - 访问原理：访问数组中的元素可以按照下标索引来访问，速度比较快，如果对他进行插入操作要移动很多元素(就得new新数组)，效率很低
###L：线性表linear list
		重要：涵盖很多以下线性表知识https://blog.csdn.net/IT_u3d/article/details/79920303
 - 概念：在逻辑层次上连续的储存数据的数据结构。
 - 线性表有顺序储存(顺序表)和链式储存(链式表) 
 - 原理：由一系列结点组成，结点可以在运行时动态生成。
 - 结点：线性表中的每一个元素称为结点，结点由两部分组成：
``			数据域：存储元素信息
``			指针域：prior/next存储前驱结点或后继结点的地址
``		因为有指针域，所以才方便进行增删。链表也才可以随机储存，不强迫在一片连续的内存空间。
####L1：顺序表
 - 原理：由数组实现。ArrayList底层(本质)就是数组，所以ArrayList是顺序表。
		顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。
####L2：链(式)表
 - L2-1：单(向)链表：每个结点只有一个指针域，存有指向后继结点的地址；表中最后一个节点的指针值为null
		https://blog.csdn.net/qq_24118527/article/details/81317410
			数据结构中，有时在单链表的第一个结点之前附设一个结点，它没有直接前驱，称之为头结点。
			头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针（即第一个元素结点的存储位置）。头结点的作用是使所有链表（包括空表）的头指针非空，并使对单链表的插入、删除操作不需要区分是否为空表或是否在第一个位置进行，从而与其他位置的插入、删除操作一致)。
			头指针在头结点前边，一个链表中，可以没有头结点，但是一定有头指针，头指针是对单链表的标识，如果没有头结点，则头指针指向第一个结点
 - L2-2:：双(向)链表：每个结点有前后两个指针域(即有指向前驱结点的地址，还有指向后继结点的地址),首结点的prior和尾结点的next都是null
 - L2-3：循环链表：
``			循环单(向)链表：与单链表的区别在于，表中最后一个节点的指针不为null，而改为指向头结点(第一个节点)。从而整个链表形成一个环。
				判断循环单链表是否为空，可以判断头结点的next域是否为空。头结点的next指向链表第一个元素，为空即说明链表中没有元素，即为空。
``			循环双(向)链表：与双链表的区别在于，头结点的prior指针指向尾节点，尾节点的next指针指向头结点。
 - L2-4：静态链表：以数组描述的链表，回头再议
 - 拓：环形链表
		链表中有环。环形链表可以不是双向链表，也可以不首位相连。看0和6这两个符号想象：0就首位相连，6就是尾部连接到中间的某个结点上。(好像不常见，CSDN有相关描述。)
###比较：
 - ArrayList：本质是数组。数组实现的，是顺序表。
``		查询性能好，修改性能慢
		查询快：因为知道了第一个，就知道了所有的地址(OOP.day03：数组的引用指向数组的第一个元素)。它们是连续在一起的。
		修改慢：如果要改变长度就要搬家(另外再找地方，创建改变后的数组)。
		所以苍老师说：ArrayList尾部追加快，头部插入慢。头部插入慢原因就是要整体往后挪
 - LinkedList：链表实现的。是循环双向链表：首尾相连，增删元素性能更好，尤其首尾增删元素效果最优。
``		查询性能慢，修改性能快。
		查询慢：随机存储，物理不连续。
		修改快：因为链表查询指定元素需要遍历很多指针域才能找的到，但是增删只需要改变其某两个结点的两个指针域的地址


###Debug追踪ArrayList的操作
		collection-ListDemo03.java
 - 在'//利用Debug工具查看容量'注释下一行打断点
		Debug的时候会在断点所在行执行前停住
 - 选Debug As 用Debug的方式运行，切换到Debug视图
 - 左上角Debug窗口，选ListDemo03.main(String[])line:37
 - 右上角的的那个Variables窗口，展开list-->Variables水平往右有个视图图标Show Logical Structure 点这个，使展开的list为三角号elementData、菱形modCount、方形size的样子(显示为物理结构)
		可看到三角号elementData--Object[10] 说明数组长度10  即List里边封装了Object数组，长度为10
``	-->然后上边有个电话样子的图标，Step Over(F6) 表示走一步
		走一步list列表就会增加数
``	-->增加到10的时候，第11执行的时候数组容量变成了15
		原数组就扔了，会被GC清理
 - 结论：Debug追踪ArrayList内部封装数组，**初始长度为10**，每次**扩容1.5倍**


##eclipse恢复界面(重置视图)的操作
 - 第一种：new window
 - 第二种：window-->perspective视角-->reset perspective重置视角



##Collection接口和List接口的方法
	List是Collection的子接口
 - Collection接口：添加元素add("xx")  子接口中也有这个方法
 - List接口：list.add(index,"xx")插入元素   list.get(index)获取元素  在Collection接口没有



8、没有明确使用倾向的时候就选ArrayList。--collection-ListDemo06.java

9、collection-ToArrayDemo2.java;
将集合转换为数组，需要new一个数组去装集合中的元素，然后返回数组
若原数组大小小于集合元素，则返回一个和集合元素大小相等的新数组
若原数组大小等于集合元素，则返回原数组(创建长度正好的数组,两个引用引用同一个对象， "ary ="可省略)
若原数组大小大于集合元素，则返回原数组，但会将填入元素后边的一个原元素改为"空":null,用来表示填充到了这个位置 
检查是否是原数组可用双等于比地址

10、collection-ArrayAsListDemo.java:将数组转为长度不可变的List集合。长度不可变，也就意味着不支持add和remove方法，但支持set和get方法(此集合和数组共享空间，set的话则都会改)；
这就是一个当作集合用的数组，若要用add和remove则可传参新new一个集合，new集合支持传参(list)(参考.java最后)


#---------------------------------------SE.day13----------------------------------------


1、排序：
只对List排序
Set不排序，因为大部分Set的实现类是无序的(我百度了Set也可以排序，回头可以再百度看看)

Comparable的排序默认是以每个字符的unicode编码对应的数字从小到大的顺序排(中英文都是)

2、java.util.Collections：集合的工具类，提供了很多静态方法，用于操作集合
	对比：	Collection：所有集合的顶级接口


4、对代码的侵入性：当想使用某个方法的时候，这个方法要求我为他改很多代码，修改的越多，侵入性(生活中也叫代价)越强
牵一发而动全身，一处改处处改。所以要有一个良好的设计架构，维护性强。
举例：
collection-SortListDemo1对自定义的类排序，自定义类一定没有实现Comparable接口，那就不建议去实现，因为这样对我们的代码有侵入性：因为这个接口一旦实现，其内部代码则会进入到我的自定义类中，可能会导致我的其他代码或设计要做相应的更改以适应这个接口的内部代码。
CSDN:一句话让你明白代码的侵入性:
当你的代码引入了一个组件,导致其它代码或者设计,要做相应的更改以适应新组件.这样的情况我们就认为这个新组件具有侵入性//后期更换新组件或者不用这个组件了依然还要改很多代码
同时,这里又涉及到一个设计方面的概念,就是耦合性的问题.
我们代码设计的思路是**"高内聚,低耦合"**,为了实现这个思路,就必须降低代码的侵入性.

应当用sort的一个重载的方法，见SortListDemo2中，这种方法做到了最小侵入性(可以这么说吧，但我觉得就是没侵入性；或者严格意义来讲所有方法组件都有侵入性)，如果后期不想用这个方法了则直接删除这一(大)句话即可。

5、比较两点的大小：这里用的是比较点到原点距离来看大小

6、队列用在开发当中的某些应用场景，用来解决特殊问题。
比如高并发的时候用队列可以缓解线程的阻塞(比如网上很多人买票，订单创建后加入队列-订单创建成功，之后队列里再排队出票)
如果只是用来存一组元素那就用数组和集合，因为这两个更灵活，而队列的存取有一定的要求(先进先出)

7、队列继承自cllection：
queue.offer=queue.add，底层代码offer方法里返回的就是add方法，建议用什么接口就用什么接口里的方法名
队列存取遵循先进先出原则，即从队尾追加，队首出队。
双端队列接口Deque继承自队列Queue：offer(入队)和offerlast(从末尾入队)，poll(出队)和pollFist(从队首出队)一样；另有offerFirst(从队首入队)和pollLast(从对尾出队)以使操作更具有指向性。

8、栈：存取遵循先进后出原则。用双端队列来实现
offerFirst和push代码是一样的；pop和pollFist和poll代码是一样的。
栈中用push(入栈) pop(出栈) ； 栈顶：栈的第一个元素；
栈最典型的功能是后退：如计算机目录的后退就是用的栈，前进后退就是两个栈来回弹

9、Web容器概念:里面装的是一个个的webapp(Web应用),每个webapp可以当作是一个个网站。
作用：帮助我们管理webapp，帮助我们和客户端进行沟通，以及帮我们处理一些沟通的细节问题，比如上层的应用层协议HTTP协议和底下的传输层协议TCP协议。这些东西的解析传输等工作斗由Web容器代劳
webapp:中有业务代码,大量的素材,给用户看的东西等。

tomcat=雄猫 是一个常用的Web容器   (Tomcat服务器是一个免费的开源的Web应用服务器。，由Apache和Sun及其他一些公司和个人共同开发而成。)
范老师要求 接下来的项目tomcat写20遍以上，架构师是干框架的
WebServer项目对我们是至关重要的项目，带着我们了解底下的HTTP协议是怎么通讯的，以及很多基本的知识。这些知识是以后用tomcat它帮我们屏蔽掉的东西，tomcat帮我们屏蔽掉了大量的底层繁琐细节。应聘很喜欢问这些底层的东西。

WebServer建议写好之后到毕业之前至少写20遍以上。以后应聘可以说我模拟做过一个简单的tomcat，底下的啥啥啥和自己以后可以拓展啥啥啥的

10、HTTP：
我们和服务器通讯，上层的应用层协议用的是HTTP协议(https是加密的http协议，先不说)
一般我们使用的网络协议：     (要是说网络拓扑，有七层结构啥的..还有物理层、连接层啥的...有兴趣自己看)
   传输层协议：把数据从一端传到另一端，告诉两台计算机之间是怎样发送数据的--------比喻说话声波、手语
               计算机相互传输的时候，底下的传输层一般都是TCP，UDP协议。(视频传输什么的那些细节不聊)
   应用层协议：规定两台计算机怎么你来我往，以及你来我往的数据是什么意思---------比喻沟通技巧、汉语
                应用层协议太多了，HTTP是其中之一。详细看WebServer的http.txt
计算机在传输交流传输数据的时候，底下必须要建立在可靠传输协议基础之上。所以HTTP虽然没有严格规定使用TCP，但基本上我们用的都用TCP协议。TCP在上边的笔记已经了解：TCP是可靠的传输(一块一块发送)。
所以接下来我们要了解HTTP：
                                     ---------------！！！！！！！！！！！！！聊天室哪里用到了TCP？????
客户端浏览器是现成的产品，都遵从好了HTTP协议，所以我们服务端也要遵循HTTP协议。(要遵从契约精神，有可能某些不遵从但是成功了，但这不通用。就像违法不一定会被制裁，可能还没被逮到)

11、接下来我们要构建一个web容器，然后构建一个webapp(这样才能通过浏览器访问这个应用(网站)看效果)
现在常用的是HTTP1.1协议，但我们从1.0开始实现。有些差别后边会说。而且我们有1.0的中文文档

12、如果看所有的HTTP协议细节参看文档，文档的制定者是w3c(万维网联盟)：这个组织定义了很多互联网相关的协议，比如HTTP协议。w3就是www我们叫3w外国人叫w3
HTTP1.0的中文文档在达内开发文档服务网站里有

11、Maven项目就是java项目，只不过它集成了Maven插件，Maven是阿帕奇(阿帕奇：Apache公司)提供的面向项目的管理工具。阿帕奇公司：美国的一家开源组织，政府资助。推动了软件开发的进程(比如tomcta，Mawen等等后边会接触很多东西都是阿帕奇的)。
Group Id：组织名称，一般写公司域名。不能写人家已有的：比如oracle.com  涉嫌的问题
Artifact Id：这个公司旗下的某一个项目。

有的同学尤其是家里的笔记本创建了Maven项目会报错，是因为Maven项目没有配置，它需要配置连接上Maven的服务器
src/main/resources:放项目所用的一些资源。如图片音频
src/test的两个包放的是还在测试，不是真正发布的内容。
我们只用src/main/java来学习，这个理解成以前的src目录即可
每级(".")的包是隶属结构，子公司，项目，不同的业务领域等


##URL：统一资源定位符。
 - URL的组成部分：
	1. 协议、访问协议类型、或称服务方式：协议后要跟"://"如：http://   ftp://
	2. 主机地址(服务端的地址信息)：两种写法:
		一：'host:port': 服务器的地址+端口  比如：http：//127.230.8.215：80  缺点：不好记
		二：域名：baidu.com  比如：www.baidu.com	域名和地址是一样的，因为大量的记忆IP地址+端口号并不现实，域名好记，所以有了域名。域名会通过DNS(域名解析服务器)解析成 IP地址+端口号 即写法一
		老师扩：http协议默认使用的端口号是80,先不强调
	3.路径和文件名(主机资源的具体地址)：表示信息再主机中的路径和文件名。
``		**看SE.day14笔记'URL补充'、'抽象路径'**
		如果缺省文件路径，则标识定位于Web服务器的主页，其文件名通常是index.html
 - 第一部分和第二部分用"://"符号隔开；第二部分和第三部分用"/"符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。


##DNS(域名解析服务器)
 - 百度百科：DNS(Domain Name System,域名系统)，万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记注能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析(或主域名解析)。
 - 稍作了解：全世界的DNS都会做一个统一的操作，当某国用户输入的域名在本国DNS库上找不到后会发一个命令请求美国的DNS服务器(所有DNS的根结点)，然后它去找，若美国也没有则把域名下派到其他国家的DNS，其他国家找到后反馈给美国再反馈给某国。
		中国有墙。中国有个做法：美国说以后如果有情况可以利用DNS制裁中国，其实中国每次请求美国的DNS时候都会自己记下来IP备份


#---------------------------------------SE.day14----------------------------------------

v1-
1、WebServer因为涉及到非文本数据的读取，所以不用字符流，用字节流，一个字节一个字节读取。
并且http协议规定，客户端和服务端之间发送的http协议中相关的内容，只有英文数字和符号，其他什么也没有，所以肯定每个字符一字节。  用字节流读过来之后转成char输出(目前发过来的都是文本,后边有二进制的部分再说）
(这里不能用BufferedReader的.readLine()读取一行的方法的原因：这是缓冲字符输入流。我们这里虽然是字符，但后边可能有图片音频，所以不能用字符流。)

2、注调while true，只连接一次启动线程即可。因为现在的客户端是浏览器，不受我们控制，浏览器认为它连接的服务器
就是要给他回应，服务器不回它它就一直连 - - 。而这时候我们还没写回应的内容，所以先注调。

3、CR：回车，将光标移动到行首；LF：换行，将光标移动到下一行相同位置。回车键Enter其实是CRLF，跳到下一行的行首

4、HTTP协议等相关内容要去看每天的项目中的txt。
HTTP协议要求客户端和服务器之间的通讯规则：它们之间总是采取一问一答的方式进行通讯。服务端永远不会主动连接客户端并发送任何内容。一问一答后则断开连接，因为他的交互性不如聊天室那么强(浏览网页一般我们点进去一个地方都会看半天，没必要一直保持连接状态浪费资源)
HTTP1.0的时候，称短连接。
后来随着网页的素材越来越丰富，如图、背景音乐什么的，用短连接的一问一答后断开的规则来接收丰富的网页就已经不适应了，(打开网页发现客户端发现有个图片，一问一答后断开，又发现有张图片，一问一答断开，发现还有张图片，一问一答又断开...)
于是HTTP1.1之后，我们和服务器建立一次TCP连接后，可以多次请求与响应，直到服务器把所有页面的内容都给我才断开连接。资源消耗小。(访问的模式依旧是一问一答，所以我们以1.0协议为基础实现我们的程序，将来加几个新的头就可以完成1.1协议。1.1和1.0无非就是构造一个页面花费的时间会长一些，但并不影响我们的使用)

##URL补充
		看当天老师画的图。以及看SE.day13中的笔记'URL'
 - 三部分组成：协议+服务端地址信息+抽象路径
		老师说的，网上没有抽象路径的说法，说的都是路径及文件名。


##绝对路径、相对路径和抽象路径
 - 绝对路径：文件在系统中的客观位置。从根目录开始一直到该目录的全程的路径。不变的
 - 相对路径：文件的位置相对于当前目录的路径。相对路径的绝对路径是随着用户工作目录的变化而变化。
		在eclipse中运行程序时，相对路径中的当前目录指的是当前程序所在项目的项目目录
 - 抽象路径：转化为特定系统的路径，比如UNIX的目录分隔符是/正斜线，windows的目录分隔符用/或\反斜线都可以。而抽象路径则是使路径名和系统无关。抽象路径名转换成路径名的时候，在相邻的两个目录名中间加入一个系统默认的分隔符。即抽象路径的分隔符并没有什么实际意义，而是在具体使用时候进行系统相关的转换，如果当前是windows系统就把路径的分隔符转换成"\"，如果是Linux的就转成"/"。这种抽象的目的就是为了保证系统无关，也就是根据不同的系统执行不同的转换操作。     -----先这么理解吧，好像是两部分组成，回头有时间好好问问

##'盘符'的概念
 - DOS(Disk Operating System磁盘操作系统)、Windous(视窗)系统对于磁盘存储设备的标识符一般用26个英文字符加上一个冒号:来标识。
		由于历史的原因，早期的PC机一般装有两个软盘驱动器，所以，"A:"和"B:"这两个盘符就用来表示软驱，早期的软盘尺寸有8寸、5寸、3.5寸等。而硬盘设备就是从字母C:开始一直到Z:。
 - 对于UNIX，LINUX系统来说，则没有盘符的概念，但是目录和路径的概念是相同的。
		目录是文件或文件夹。路径是由目录组成的。路径是一串目录。

#v2-
6、v2_ClinentHandler在线程中用StringBuilder，不会形成抢，不要多虑，只有两个线程共用一个方法形成抢的时候才需要考虑线程安全。

7、私有方法：
所谓的属性私有化，行为公开化。一般说的是属性对应的get，set方法公开化，即操作私有属性的行位公开化，不是说所有的行位都公开化。因为我们还要考虑封装性，不让外看见实现细节。这个方法如果是要外界让他干活的，那就public，若只供自己用，谁也不需要知道的话，那这些方法就是死有方法。
(比如去饭店告诉厨师点个菜，并不需要看他做菜的各种方法：切菜，颠勺，下料等)
例如：v2_HttpRequest中解析请求的方法。外界没有必要要求单独解析个请求行、消息头什么的。这个不需要对外提供。

8、key-value：键值对。查询条件-查询内容
map_MapDemo，如果Map<key类型,value类型>，如果value类型是个包装类，是不能用基本类型接收的。比如这里的Integer，是不能用int接收的。否则会报空指针异常：原因是用基本类型接收包装类会触发自动拆箱，会补一个代码调用.intlue()转成基本类型(int value = map.put("语文",99).intValue();)而这时如果key不存在，整个put()方法是并没有返回值的，这时候map.put("语文",99)为null，而null.intValue()就会出现空指针。
//(百度：泛型要求能包容的是对象类型(泛型类型只能引用类型)，而基本类型在java里不属于对象。但是基本类型都有其包装类型，也就是对象类型)

9、了解：淘宝搜商品的时候，如果你是第一个搜可能会卡顿几秒，如果是第二个搜一下就会出来，原理就是第一个搜索后，就会把这个商品放到map里去了，下次再搜直接去map里找


#---------------------------------------SE.day15----------------------------------------


v3-
1、v3_HttpRequest中，下面只设置了几个get方法，get客户端发送过来的内容，没必要设置set方法。保证封装性。
而最后getHeader方法是自己写的不是source的，是因为source的是整个消息头headers，这样外界可以get到消息头的整个HashMap，没必要；而且可以调用map的clear和put方法，不安全；所以自己写了个传参方法，传入消息头的名字(key)，从而get返回名字对应的内容(value)
(难道如果用source里的get，返回的不应该是新的map吗?这样调用clear和put方法，和原本的有关系吗？) 
---------------！！！！！！！！！！！！！！！！！！！！！！！！！！也有一个好处就是要什么返回什么，不会一下都给出去，相对隐私。具体的以后追究！！！！！！！！！！！！！！！！！！！！！！！！！
(拓：查看文档发现map的remove方法：
V remove(Object key)：从此映射中移除指定键(key-value名为键值对)的映射关系（如果存在），存在则返回kry关联的旧值value。
V remove(Object key,Object value)：仅当当前键被映射到指定值时，才移除指定键的项)

##HashMap的原理
 - map.png图 & Key.java中有详细笔记	11.16号11:30
 - 哈系表由**数组实现**，数组的长度是hashcode()算法中进行计算的元素。数组**初始容量默认16**，扩容时重新计算每个元素的位置。
``		所以扩容时很耗费性能，我们要避免扩容。
		Map在new的时候可在小括号中写初始长度
``		可以通过传参规定初始长度。比如：已知元素大约有75W->则可设置初始长度100W
			可以先让程序跑一段时间，看Map的数据量经常维持在多少。然后再设置初始长度，减轻以后的开销。
``		Map浪费1/4的空间，降低链表出现的几率
		有可能会出现key不同但是计算的hashcode值一样，这时就会产生链表。
		通过计算使用3/4是介于空间成本和查询速度之间最好的性价比。比如75W元素需要能装100W元素的空间。
 - 文档：HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作(即重建内部数据结构)，从而哈希表将具有大约两倍的桶数(我通过Debug追踪发现每次**扩容2倍**)。

##HashMap的顺序
 - HashMap的内部存储顺序和put的顺序不一样
		Map<String,Integer> map = new HashMap<String,Integer>();
 - 有序的HashMap：LinkedHashMap
		Map<String,Integer> map = new LinkedHashMap<String,Integer>();
		LinkedHashMap内部使用一个链表维护遍历顺序，使其保持与put元素时的顺序一致。只是遍历的时候有用，内部还是用散列算法保存的。要求顺序的遍历才需要，实际不常用

#v4
3、ArrayList,LinkedList,HashSet,HashMap它们都不是线程安全的，并发使用时的解决办法看map_SyncDemo
源码可看Collections.synchronizedList()是内部new了一个线程安全的，把数据换进去了。其实存在这个方法的目的是，我们就不用去记那个线程安全的叫什么名字了。比如.stringBuilder()的线程安全的叫.stringBuffer()，如果多了不好记

##HashSet
 - HashSet之所以不是线程安全的，是因为HashMap不是线程安全的：
		看源码可知：HashSet就是HashMap，它只用了Map的key这一列，是一个只有key这一列的HashMap。使用散列算法放入元素。
 - 百度知道：HashSet是使用HashMap来实现的，他的绝大部分方法都是通过调用HashMap的方法来实现，因此两个集合在实现本质上是相同的。
		百度：所有实现了Collection接口，以及Map接口的都是java的集合
 - 百度百科：用于向收集器中储存或快速检索数据
		HashSet没怎么仔细讲，出现在：collection_CollectionDemo1和3

5、浏览器的主要作用就是把服务端发过来的一大堆代码转成可视化内容(图片等是告诉浏览器图片名和地址，让他去服务器下下来)
v4_webapps_myweb_index.html：元数据

6、index.html中说的元数据：
知乎：元(meta)：本原，体系
      元数据(meta data)："data about data"关于数据的数据，一般是结构化数据(如储存在数据库里的数据，规定了自断的长度、类型等。//如这里写的<meta charset="UTF-8">规定了展示的字符集，避免中文乱码)。
元数据是指从信息资源中抽取出来的用于说明其特征、内容的结构化数据(如题名，版本、出版数据、相关说明。包括检索点等)，用于组织、描述、检索、保存、管理信息和知识资源。
百科：数据源(Data Source)：数据的来源，是提供某种所需要数据的器材或原始媒体。是指数据库应用程序所使用的数据库或者数据库服务器


#---------------------------------------SE.day16----------------------------------------


v5-
1、7、百度知创建maven时JDK默认使用JDK1.5版本；v5_HttpResponse中使用JDK7自动关闭特性将jdk改为JDK1.8。参考(SE_Exception_AutoCloseDemo)

2、功能拆分的目的：容易换，可维护性强。

#v6
 - root-根。建root文件：放共用的页面
##为什么从v6开始每个WebServer都40+兆
 - **v6开始在WebServer的webapps下，建了一个web文件，里面是学子商城的东西，请求路径由myweb/index.html改为web/index.html**
 - 起因：我们在v6的webapps下，添加了一张图片，之后访问我们myweb/index.html页面，就显示图片了。
 - 发展：传奇带我们看了一下：浏览器F12-->Network-->All-->Name-->index.html&logo.png-->Headers：
		这里是服务器发给浏览器的响应
			Request URL:请求路径
			Request Method：GET  发的是GET请求
			Status Code：200 OK  状态代码
			Response Headers：响应头
				Content-Lenght：xxx 页面/图片的大小(请求的内容的大小)
				Content-Type：text/html
		这里就发现了问题：状态码都是200 OK，先解决状态码问题，引入一个404，找不到资源就显示404
							图片的Context-Type也是text/html，但是它明明是图片，缺告诉浏览器这是个页面。
 - 我们的状态码只有200 OK 以及Context-Type固定是text/html。浏览器会根据响应头中的Context-Type值来理解其请求的资源类型。这就会导致页面乱版
		v7&v8 rademe：现在响应头中的：Context-Type是固定值：text/html 这会导致用户在请求一个复杂页面(包含大量样式，脚本等资源)时，客户端(浏览器)无法正确理解其请求的资源类型，导致显示页面不正常的情况。
		有的浏览器不听你的，它感觉这是个图片就解析成图片，觉得是音频就解析成音频。但是基本上的浏览器都是听我们的，我们的Context-Type是啥它就按照啥解析。
 - 高潮：引入学子商城，看乱版成什么样了。所有的Context-Type都是text/html
		学子商城是在开发文档里下的全部资料
 - 结束：先解决状态码问题，之后在v7-v8中解决Context-Type问题，v8之后访问我们引进来的学子商城就不再乱版了。
 - 一个学子商城40+兆，所以从引入v6开始从此的每个WebServer就40多兆了
		老师的笔记是把学子商城去掉了之后再上传的。


3、v6-HttpResponse状态行空格单独拼接可能是避免有的同学遗漏，一起写的话可能是怕下面有呆子漏写。

4、favicon=网站图标
网页中F12-Network-All中的favicon.ico红色，所以服务端会显示有一个资源未找到。
(解开循环后发现有一个显示资源未找到，运行了几次后发现好像就第一次连接请求这个，再连就不请求了，回头清空缓存试以下！范传奇说是浏览器行为，不可控)

##什么时候显示404
 - 假设在请求的页面中有一个素材没有，那么只这个素材不显示。在F12中显示404；
 - 只有在地址请求的资源直接不存在(页面不存在)时才会显示404页面。

6、v6_HttpContext:静态的属性应该在静态块中加载/初始化(查询"静态块"可回顾此知识，静态变量和静态块搭配用)
范老师总结为什么设置成静态的原因：200对应的就是OK，404对应的就是NotFound，都是HTTP规定好的就这样的，不管哪个响应发的时候都是这样的。
	静态属性和普通成员属性的区别：成员属性是从属于对象的，就是大家都得有，但是值不一样的，就要作为成员属性定义。静态属性全局就一份，是从属于类的，值都一样的，这些就是静态的。
静态和常量的区别：常量的值完全不可以改；静态的是全局就一份，要改全都改。(其实常量有静态常量(用static final修饰)和非静态常量(不加static，只用final修饰)，静态常量减少内存开销)
不同的响应将来发送的响应头是不一样的，所以响应头不能用静态的，要定义成成员属性。

v7

#---------------------------------------SE.day17----------------------------------------


1、控制台问题：下标越界、请求网站图标、连续显示好几次"一个客户端连接了"(连续连接)。都是浏览器行为，不可控的。下标越界原因(空请求)在注解中有介绍，处理方法后边会讲

v8-
2、java的转义符用来转义"、'、回车等编程中冲突的字符
正则表达式的转义符用来转义字母的表示等，比如\d 表示任意一个数字字符，而编程中就需要写成\\d
PPT中的正则表达式字符表示的不全，记住：
 .表示任意一个字符，要表示.字符用\.     (代码写\\.)
 (?表示匹配前面的子表达式0次或多次，)要表示?字符用\?     (代码写\\?)
以后在操作matches()、replaceAll()、split()的时候，如果有异常可以百度正则表达式所有语法检验是不是需要转义表达

v9-
3、做空请求的异常处理，因为java没有空请求异常，所以我们自定义一个空请求异常，记得异常都继承Excption

4、自定义异常没什么业务逻辑，保证以下四点即可：1、把类名写清楚。2、继承自异常。3、添加版本号。4、添加构造方法。

##equals()的使用注意
		防止null.equals()的空指针异常
 - 建议用：自变量.equals(变量)  这种形式
 - 原因是若用：变量.equals(自变量)  变量在变化，如果变量为null，那么用null.equals()会报空指针异常

6、v9_HttpRequest中对空请求的处理：自定义一个空请求异常，并且空请求异常我们自己不 处理。一直抛到ClientHandler即可。

v10-
JSD1809_XML
XML-学会读写XML-看PPT    New-Other-XML-XML File
##XML:
 - 可扩展标记语言，W3c制定的标准，纯文本(不受平台系统、编程语言的限制，只要字符集对就行)，独立于软件和硬件的信息传递工具。用来存储数据，进行平台之间，软件之间的共享传输。
HTML是XML的分支(HTNL秉承了XML的优势,并且HTML里的标签都有含义了，用来展示页面，单独构成了一个体系。XML的标签根据自己的需求自己定义，作为数据传输共享来用)
数据共享：我们写程序的时候，经常要把程序和程序里的数据分隔开，往往把数据单独拿出来定义成一个文件，在文件中保存。让程序在启动的时候，它都不知道自己的数据是什么，而读文件的时候，文件里让用什么数据就用什么数据去运行。//我理解的是比如说我们几个人在玩一个游戏，我把我的XML发给它们替换掉，那它们就能读取我的XML就能获取我里面的信息。

(配置文件：将一些数据写死在程序中，会造成移植不便，并且如果要从代码中改数据需要重新编译(业务逻辑什么的都没有变，只为了改个数据重新编译啥的没必要)。将信息放入文件中，只需要在文件中改动数据，程序执行时读取该文件以获取信息。让项目方的一个维护人员改代码他可能不会改，但改个文本文件应当会改。-------------这个文件就是一个配置文件)

###XML文件用作配置文件：
在我们聊天室那个项目里，若将IP地址和端口号分行放在文本里，然后运行的时候去按行读取，这就是一个简单的配置文件。
而如果说我们的数据很复杂，不是几行就能搞定，可能还存在一些嵌套关系，那如果再写一行两行就不太理想。
那这时候我们就用XML来保存信息了。

(外包公司：通俗易懂的解释：我是个包工队，我手里没项目，你们谁有项目我给你们干。装修公司，自己没房，谁有房子我给你装修。)

<?xml version="1.0" encoding="UTF-8"?>   XML的第一行，是XML的处理指令，必须这么写。给XML的解析引擎看的
XML解析引擎：读XML文件的程序。规定版本和使用的字符集

讲XML的时候一直在说两个问题，第一是便于不懂编程的人操作，第二是不需要重新编译。第二点不需要重新编译是考虑到客户的体验，即使只是几秒的时间，若客户端每次浏览不同网页都需要修改代码重新编译运行，那么我们每次都要等几秒也是很影响体验感得，平常我们搜索内容浏览基本都是1秒内出现结果。

8. XML元素=XML标签：
属性只能加在开始标签上，属性的两部分：名字="值"；
属性的值用双引号单引号都行，一般用双引号。这两种情况用单引号：属性的值含有单引号："1'.'0"；属性的值含有双引号：'1"."0'    跟写作文一样

开始标签和结束标签之间可以包含两种东西：其他标签和文本。开始标签中可以添加属性。属性之间空个格。
XML大小写敏感，开始结束标签名大小写要一样。

有开始标签就要有结束标签，特殊的：标签中没东西但标签里有属性-可以简写结束标签：如：<a id="1" /> 在">"前加"/"

XML中必须要有一个根标签：所谓根标签就是不被其他元素包含。并且根元素只能有一个。如PPT中，不能定义平级的根标签

实体引用：XML里的转义字符，比如大于小于号和标签符号的冲突，格式：  &xxx;  PPT有

CDADA片段：格式 <![CDATA[文本内容]]>  之中无论写什么都会被当做一个文本 (假如一段文本中有很多的转义字符，那不方便并且看起来很乱，就可以用这个)
注释：<!-- -->

XML的标签名随意
一般属性用来说明当前标签的特性，子标签用来表示包含关系。
若标签没有下级内容，则可以把信息定义为属性：
  <emp id="1">
    <name>张三</name>
    <age>22</age>
    <gender>男</gender>
    <salary>5000</salary>
  </emp>
和
<emp id="1" name="张三" age="22" gender"男" salary="5000"/>
两种方式均可

8：XML的解析：可以看下PPT
SAX：逐行扫描，边扫描边解析，速度快，占资源小(移动设备上里面有很多XML内容基本都是用SAX解析的)(网络传输要求速度的话用这个)。对整个XML没有把控。
DOM(文档对象模型)：W3C组织推荐的一种方式。按照层次关系解析成一个个Node对象(节点)，把整个XML读完，生成整个XML树形结构，可以遍历和修改节点(又可以读又可以写)。资源消耗大，解析时间长。

因为DOM可读可写所以我们以DOM解析的形式学习XML的读写(启下条)

9、jar包：
(接上条)但是DOM只是W3C推荐的一种模型，具体的实现用第三方程序员提供的 使用DOM模型解析XML的 一套实现类
使用第三方类库不能直接import(因为不是java官方本身虚拟机支持的类库)，需要导入第三方类库的jar包(里面有写好的项目，有很多的类提供我们使用，是一个压缩包)

jar是java提供的压缩包,java虚拟机天生支持直接从jar包里读取里面的那些类。便于发布。第三方在提供自己的类库的时候，都会打成jar包提供上来
(以前下载jar包要去各种网站去找，很费事，比如下个domsj，则需要去dom4j的官网下载)
maven最大的优点是：一统江湖，让所有第三方的jar包都传到maven一份，用的时候直接在maven上找即可；并且maven解决了包依赖的问题

包依赖：下了一个XXX.jar，用其中类库的某个类，这个类在实现它自己的一个功能的时候发现这个功能已经有另一个jar包的类实现过，那它就直接引入那个jar包里的那个类去干活。但我们不知道这个，我们工作当中只把直接用的那个jar下下来了，导致运行的时候程序报错：ClassNotFoundException，原因很不好找，看源码需要花很长时间。

**maven把包和包的依赖关系解除了**：maven要求组织在上传jar包的时候，要说明这个jar包里边的类有没有用到其他jar包里的东西，如果有，把他们之间关联一下，说清楚它们之间的关系。这样当用户从maven上下载jar包的时候，maven会自动分析它用到其他jar包里的东西，maven则连同这个jar包一起下载下来。

然而apach-maven的这个中央库我们是用不了的。。因为他在美国，大中华局域网有墙。
但是阿里云有maven中央库的镜像库，我们只需在eclipse里把maven的库的地址不要配在默认的阿帕奇官方，而配成阿里云的即可。具体怎么配有苍老师的文档。
不过阿里云有个缺点:不支持本地索引，我们所有搜索的东西必须通过阿里云的官方网站去搜索我们要下载的jar包的坐标，然后粘到我们的maven里才能去下载。
(教室导jar包：学校苍老师搭了个小的maven的库，把我们学校里学习用到的jar组建了一份：达内开发文档Maven快速上手_在线jar组建"坐标搜索"_进去左边搜索"dom4j"后出现此jar包坐标，copy到eclipse_maven_pom.xml_源代码根标签中添加子标签<dependencies><dependency>导入的jar</dependency></dependencies>。(dependencies需要手动添加，dependencycopy的时候有)。几个jar几个<dependency>。保存后它会去maven库里找这个包下载下来。和daom4j同时下下来的那个jar就是和他有依赖关系的jar。
家里导jar包：用阿里云的)

注意:
dom4j = dom for java   log4j  4读音和for一样,所以变成一个单词for用了4
o2o p2p 的2也是to的意思   iphone4s是：iphone for Steve   纪念乔布斯(Steve Paul Jobs)

pom.xml_Dependencies:若支持本地索引，可以直接在这里Add...搜索。但是阿里云不支持本地索引,所以这个插件对于我们没用

10、(CSDN)解析XML的四种方式：
XML是一种通用的数据交换格式，它的平台无关性、语言无关性、系统无关性，给数据集成与交互带来极大的方便。XML在不同语言环境中的解析方式都是一样的，只不过实现的语法不同而已。
SAX解析和DOM解析：这两种属于基础方法，是官方提供的平台无关的解析方式；
JDOM解析和DOM4J解析：这两种属于扩展方法，它们是在基础的方法上扩展出来的，只适用于java平台。 
DOM4J性能优异、功能强大、极端易用使用，开源。连sun的JAXM也再用DOM4J,目前许多开源项目中大量采用DOM4J。如果不考虑移植性，那就采用DOM4J。
(所以范传奇说我们用DOM解析方式，实际上我们是用的DOM4J解析方式，的确是DOM模型)

11、DOM4J解析XML：   注意ParseXmlDemo的import导包都是导dom4j的包
使用IO就要处理异常，涉及防止文件流没发现文件的异常、关流关不上的异常、IO流输入输出的异常等等。

SAXReader生成的Document对象里面就是用一个树状结构把整个XML内容组建好。


#---------------------------------------SE.day18----------------------------------------

v-10
1、conf里的xml文件在：Home_apach-tomcat_conf_web.xml,这是tomcat里的xml文件，该文件定义了所有的资源文件后缀名和对应的MimeType类型(Content-Type对应的值)

2、每个tomcat版本统计的mapping个数不太一样，差一两个没关系，但总之有一千多个

3、HttpContext里的initMimeMapping()就是昨天讲的解析XML，看一下JSD1809_XML项目就很好理解。

4、JSD1809_XML_WritexmlDemo：生成XML，是生成了一行。生成一行有生成一行的好处：
缩进是为了好看，给人看方便。但是如果是两台计算机传输数据的时候，计算机看的没有必要缩进，越精简越好。字节量越少传输速度越快。
Ctrl+Shift+F(Source_Format)：自动格式化(自动缩进),XML、HTML和java代码都支持自动格式化。如果不行要把输入法切成英文

同样的Dom4j是可以直接生成带换行缩进的效果的XML的：
XMLWriter(OutputStream out)方法允许传字节流，XMLWriter(Writer writer)方法允许传字符流。(这里可能看不懂，回顾一下。OutputStream是所有字节输出流的超类，Writer是所有字符输出流的超类)
这两个构造方法还有两个重载的方法：
XMLWriter(OutputStream out, OutputFormat format)
和XMLWriter(Writer writer,OutputFormat format)
第二个参数是可以指定输出格式。格式不需要自己去new，因为OutputFormat本身有静态方法可以生成有预定义格式的效果：
OutputFormat.createPrettyPrint()	//创建一个漂亮的输出---见WritexmlDemo
给计算机看不要生成这样的，多出很多没用的空白字符，影响效率(积少成多)

v11-
5、浏览器的缓存：为了减少网络访问提速的。有时候浏览器拿到页面之后刷新网页，浏览器以为还是这个页面，就直接把原页面一下子展现出来。但是如果我们服务端修改了HTML代码，浏览器再这样就会影响测试。可以清理缓存。也可以右击查看页面源代码看他的源代码有没有变成我改的。(如果是修改了服务端java代码那得重新编译运行代码才行)

6、进一步解析url部分中：
我们按照"?"、"="、"&"、拆分url：有同学问那如果在注册输入框里输入问号咋办：首先这些符号我们平时注册的时候是不让用的，实际上即是用了也是会被转义的，转义规则是SE.day16里的实体引用


#---------------------------------------SE.day19----------------------------------------


1、HttpRequest中进一步解析url，两个if判断：
按?拆分的时候判断： if(data.length>1) {：判断长度是因为：我们刚开始做测试的时候，在HTML中所有的输入框都没有给名字的时候，点注册，这时候url显示的是：  localhost:8088/myweb/reg?   这时候按照？拆还是只有一项。
按=拆分的时候判断： if(paraArr.length>1){ ：判断长度是因为：输入框的名字是有了，但是我没有填东西就注册提交了，这时候url的参数部分是显示:   ...reg?username=&password=&nickname=&age=  ，这时候按照=拆分依然是不能拆成两项的。

v12-
回顾FileDemo.java：在eclipse中运行程序时，相对路径中的当前目录指的是当前程序所在项目的项目目录
v13-


#---------------------------------------SE.day20----------------------------------------


v14-
1、重构结构：
将来写程序的时候经常需要重构，解决掉一些代码冗余。
重构的基本规则：1-如果只是在一个类的内部有重复代码--抽方法。重复调用这个方法即可	2-如果多个类都有一段重复代码--抽超类，继承即可	3-如果这几个类都有这个方法但实现不一样--抽超类，做抽象方法。

2、HttpServlet：实际上forward()方法不是在servlet里边的，在这只是先写个注释记一下在这里写的用处，不做过多的解释。以后学Tomcat才能知道这个东西。
其实在forward()里，request这个参数其实我们根本就用不上，之所以传是因为以后学Tomcat知道在Tomcat里有这个forword()方法，通过request.get...在那里操作。在这里只是把这三个参数都留下了。以后学就知道了。

##反射
		SE_reflect/ReflectDemo   -参见PPT
 - 我们现在一直在写代码的时候，要想实例化某个类必须要 "类名 参数 =new 构造方法"  这种形式来进行，这种实例化对象的方式，是在编码期间就决定了我要new谁。在编译期new出来。
		计划着怎么干
 - 而java有一个很酷炫的机制--反射：java的反射机制允许我们实例化对象、调它的什么方法，从编译期挪到运行期来干。一切等程序运行起来之后听你的。
		随机应变地干
 - java就是因为有反射机制，所以才会有现在这么多非常方便、灵活、高效的框架可以使用。
		框架是什么：我还没有写代码，框架里边的功能他都写好了，那框架怎么知道我要写一个功能将来会调用他。框架是把大结构写好，剩下的事先干着，遇到的时候再说...这就是用的java反射
 - 如果我们使用反射，那么ClentHandler就不用在编码期间必须知道哪个请求对应哪个Servlet，一切在运行的时候说。
 - **反射是把双刃剑**：很灵活，但是增大开销。
		按计划行事的优点是按部就班，缺点是不灵活。
``		反射的优点是随机应变，但是没有计划，需要注意的事情更多。
		反射应当是在程序中锦上添花的存在，写程序大部分还是要计划行事，需要随机应变的时候再用反射。反射的使用要适度。
 - eclipse在我们编写代码的时候是利用了java反射来提示的
		我们在编写代码的时候，刚刚写好的一个类，在另一个类中调用并"."它的方法，eclipse会在我们输入"."后提示这个类有什么方法，那么eclipse是怎样知道我刚做好的这个类有这些方法的呢。eclipse同样是要加载这个类用反射机制来提示的

##获取类对象三种方式
		SE_reflect/ReflectDemo
 - 第一种：类名.class  若明确要获取的类对象的时候用，要带上类名，直观，但是把代码写死了
 - 第二种：使用Class的静态方法Class.forName(包名.类名)
		需要传入的完全限定名为一个字符串参数,所以不是写死的,是在程序运行起来后再加载指定的类。
			要处理的异常：ClassNotFoundException 可能存在找不到指定类名 的异常
		使用forName获取的Class对象的.get方法，可以get出加载的类的一切信息：
			getName()返回类名，getConstructor()返回构造器，还可以返回注解等等，需要的话去看文档
 - 第三种：类加载器ClassLoader
		后边应该会用，现在课上不主要讲  搜索笔记'类加载器||ClassLoader'


##java加载一个类只加载一次
 - java虚拟机在第一次执行forName的时候发现要加载的类，会去加载并生成Class实例并返回给我们用；而在以后执行forName的时候如果发现传入的类已经加载过，则会直接把第一次加载好的类对象返回给我们
		回顾笔记'方法区'，两个方法调用方法区里的同一个方法，是分别执行计算，分别在自己的栈堆中做变量计算等等


##Class.forName()和newInstance()方法
		一个加载、一个实例化
 - forName()是将类的.class字节码文件加载到jvm中，并对类进行解释，执行类中的static块。
		静态块属于类，在类被加载期间自动执行，只执行一次
``		同时返回一个类对象，可以get这个被加载类的一系列信息
		要处理的异常：ClassNotFoundException 可能存在找不到指定类名 的异常
 - newInstance()是实例化当前Class所表示的类的一个实例。但是它要求该类有默认的无参构造方法。返回值为这个实例。
		拓展：如果传入的类没有无参构造方法。那就要先get它对应的构造方法：
		Constructor xx = yy.getConstructor(parameterTypes)，xx是返回的构造器；然后调用xx.newInstance()方法，这样就实例化了一个使用指定构造方法的这个类(之所以先指定是因为一个实例只能使用一个构造方法--构造方法的作用是给成员变量赋初值，是在创建对象(实例化类)时被自动调用的)。
``		parameterTypes：参数类型，(这里指传入指定构造方法的参数的类型)，意思就是传个类型，其实就是传个Class的实例。写法和ReflrctDemo1讲的一样：
			写法一：Class的每个实例都可以表示一个类型，可以写xxx.class  写死
			写法二：Class.forName("Java.lang.String")  写活

			！！！？？？暂时无法解决：若xxx为基本类型，比如int.class是什么意思，基本类型还有属性吗。改成Integer.class报异常NoSuchMethodException)		解决：搜索笔记程祖红'java语言中，任何类型在方法区中都有一个对应的class对象，包括基本类型也有。'


##Class和Object的区别：
 - Class：继承自Object,叫做类对象；在Java中，每个.class文件都有一个相应的Class对象。
		也就是说，当我们编写一个类，编译完成后，在生成的.class文件中，就会产生一个Class对象，用于表示这个类的类型信息。一般在反射中使用。
 - Object：是所有类的父类，封装了所有类的一些共性方法


##getDeclaredMethod(name,parameterTypes)方法
		reflect_ReflectDemo3和ReflectDemo4
 - 参数是(方法名,方法的参数类型)
		需要通过方法名和方法参数才能确定一个方法，方法参数是区分重载方法的。如果是无参方法，可以不传第二个参数。
 - 怎么传入一个类型：
		以String类型为例
		原话：咱们之前说过，每一个Class实例都可以表示一个具体的类型，而这里传的实际上也是Class的实例，那就用描述String的Class实例就行了。
``		怎么传String的Class实例：
		方式一：String.class 这种方法写死了
		方式二：Class.forName("java.lang.String")纯加载，这种方法写活了，可以按需要传
 - 为什么这个方法传一个参数也型，两个三个也行
		并不是因为它定义了很多个重载的getDeclaredMethod()方法。
``		而是因为**JDK5的一个特性：可变参数**
		见ArgDemo.java；确定参数+可变参数(写后边)		不是每个班都讲
		成恒：可变参数是作为数组处理的

#v15-
8、线程池   ---看PPT
什么时候用线程池:
	1、发现要频繁得创建销毁线程：每个线程的生命周期都很短暂，而又在频繁地创建销毁
	2、线程数量过多：线程多了，所有线程占的内存量就比较大，内存溢出，操作系统就会直接把程序杀掉了---宕机
扩：
并发问题：业务逻辑如果不是特别复杂的话，单台服务器一般能同时承受2-3百并发。
高并发问题：一台服务器承受不了，要用集群服务器。。。(比如魔兽一个城一个服务器)
(宕机：台湾计算机术语，在大陆就叫当机，即通常说的死机。来源--down音译，指电脑不能正常工作)

线程的频繁创建和销毁带来的问题：给线程调度带来压力：线程频繁地创建销毁会浪费无谓的空间：线程调度不仅要关心CPU时间分配给谁，还要管理创建新线程和去销毁用完的线程    ---这都是不可取的

线程池帮我们解决的两个问题：
	1、让线程重用
	2、控制线程的数量    (控制线程数量的意义，计算机一直在用它超高的运算速度欺骗人的感官，当线程多了速度慢下来就会影响人的体验感。若有1000人玩游戏，服务器最多只能承受300人，则只允许300人同时玩，其他人排队。这样300人可以有好的体验感，不然1000人都不会有好的体验感)

所有的池(常量池、线程池...)的作用基本都是：重用和控制数量

9、四种线程池：
第一种：Exevutors.newCachedThreadPool()：缓存形式的线程池，弹性很好(收缩好)，不关注线程数量，更主要关注的是重用行。如果线程数量的峰值不会超过硬件的可承载范围的时候，可以用这种。原理是：比如一下来了100并发，那他就new100个线程，之后线程池给所有空闲下来的线程都会给他设置一个时间，在这个时间内若还没有被利用过，那就杀掉。(需要的超过现有的就扩，小于现有的就缩)
第二种(最常用)：Exevutors.newFixedThreadPool(int nThreads):创建一个可重复固定数量线程的线程池。这种线程池内部维护着一个队列，遵循先进先出原则。一个任务执行完后从队列里取出一个任务执行。
第三种：Exevutors.newScheduledThreadPool(int corePoolSize):可以安排在给定延迟后运行，或者定期执行
第四种：Exevutors.newSingleThradExecutor()：实际上是一个单线程模式，线程池里就这一个线程，有时需要一个一个排队干的话就得使用这种模式

线程池的停止：
	1、调用线程池的shutdown()方法，线程池不再接收新任务。并在执行完已经纳入到线程池的任务后，停止线程池
	2、调用线程池的shutdownNow()方法，只要调用，马上停止。


##小项
1. 正常情况只要有异常都要try-catch，在演示中有时为了省事经常直接throws，不要奇怪

#---------------------------------------SE.day21----------------------------------------


1、Date：看PPT
Date在Java1.0发布，在1.1以后他的大部分的操作时间的方法就不建议用了。只存活了一个版本。(他的大部分方法声明为过时，调用的方法如果过时，则方法上会出现横划线)
我们只知道和使用DateDemo里的Date方法就可以了，剩下的方法都不再使用了。
我们现在使用Date，只用它来表示一个时间就可以了，相当于一个存时间的容器。所有对于时间的操作，全都不使用

2、Date过时原因： 因为存在的两个问题：

时区问题：
现在我们使用的时间，即世界公认的使用时间，是格林威治时间(英国伦敦郊区格林威治天文馆，整天看着星星发布准确报时)，地球是圆的，是有时差的。我们在东八区，比格林威治时间早8小时，所以要在那基础上加8小时。
Date使用的是当前系统的时区，早期的windows和linux版本的差异：
早期windows系统：当前系统时间，不是记录的格林威治标准时间，而是直接记所在时区的时间
linux系统：当前系统时间统一都是格林威治标准时间，安装系统的时候要选时区，显示的时候按照格林威治标准时间+时区来显示当前时间
--这就在造成了一个问题：Date在获取回来系统时间之后，还要不要加这8小时。当时Date没有考虑到这个问题，所以在跨平台的时候会出现很多问题。导致Date里的操作时间的方法不用了，我们现在只用来表示当前的系统时间。

千年虫问题：
其实是个bug，历史遗留问题，遗留了20多年。源自于软件上开发语言里的设计问题，因为当年的计算机硬件水平不理想
现在我们计算、保存时间是用一个long值来表示，记得是1970年元旦到现在的毫秒。
一开始的时候不是这样的，"年月日时分秒"统一的每个都占1个字节，因为一开始的计算机硬件水平不高。
千年虫问题从C语言出现的时候就有了-70年代 (java底层就是c所以date存在了千年虫问题)
这时候硬件水平很低，处理日期不可能用long值保存。那时候空间是寸土寸金，为了尽可能的去节省空间，于是想了个办法，用两位数字去保存,计算的时候用两位数去计算，显示的时候加上世纪去表示就可以了。但是到了99年就会发现问题了：它得往前进位了，往前进位的话99年进一位在计算机内部其实是00年，那么比如在进行年的计算2000年-1980年其实是0-80。造成数据计算紊乱。
当时说这个先不过多考虑这个问题，因为当时想经过20多年计算机会有翻天覆地的变化(摩尔定律)。但是最早使用计算机的行业都是和数字非常敏感的行业，比如金融：银行核心的业务现在可能还维持在七八十年代的水平，银行的原则就是只要这个东西稳定没bug，一般是不会主动去换软件的，因为如果换一个新开发的软件，万一有bug就坏了。因此在99年的时候，它们使用的软件依然是存在千年虫问题的，进位后将对金融算术造成紊乱。
但是千年虫的爆发没有想象的那么严重，因为硬件水平提高了，内存可用的范围更广，在当时采取了一些措施将日期改为了四位数，以及还有备份机制等等，使2000年进位时所有犯错的东西都进行了恢复，没有大规模爆发

(拓：Intel刚开始发布的集成化CPU叫8086(现在大学里单片机课程，单片机里使用的CPU典型的就是8086) ，然后又有了80186、80286、80386、80486。到80586的时候就不使用这个命名了，叫奔腾处理器(就是所谓的多媒体电脑了，有奔腾1代-2代-3代-4代，4代就到了原先说过的那个物理瓶颈了(查询关键词"瓶颈"))，然后出现了酷睿CPU)
(90年代的80386就是土豪的象征，那时候范传奇的哥的80386电脑配的是8M的硬盘。8M的很了不起了。99年传奇老师的PC硬盘4.3G，内存64M。win98-关机3分钟)  （我自己还百度到一个 2038年问题，是32位系统的问题）

2、以后在使用API的时候，如果被划了删除线，说明是过时的方法，比如：Date.getYear()

3、impleDateFormat记住三点即可：
	1、会写日期格式字符串
	2、记住format方法：把Date转成String
	3、记住parse方法：把String转成Date

4、date_test中，回家按照他写的优化一下(优化完删除句话)
Date date = new Date() 的时候可以传一个日期参数进去，那么这个date就表示这个日期了，等同于new完之后调用date.set()

5、Calendar_add、Test2 中的add日方法中，用DAY_OF_YEAR、DAY_OF_MONTH、DAY_OF_WEEK、DATE 经过测试都可以

6、Lambda：
lambar表达式出现的意图是让我们Java能以函数式编程(后边再慢慢理解)
对于我们来说lambar表达式直观的感受是：它可以让我们用更方便更简单的方式让我们去创建匿名内部类

java有一个好的规范：所有能用lambar表达式快速创建的接口，在它的源码上边都加了一个注释：@FunctionalInterface(点开Runnable的源码就能看见)

lambar表达式是java-JDK8出现的一个特性：凡是一说Java的特性，几乎都是编译器认可，都不是Java虚拟机认可。意思就是lambar表达式最终编译器还是会给他改成原来的传统形式，只是说这件事不用我们干了，对于我们来讲更方便简单了

7、传奇老师再见语录：17.35找工作回头来听，医保是要有的，社保和退休工资有关。


##-----------------------------------范传奇HTML整理##------------------------------------


(有开始标签就要有结束标签)注释标签:<!-- -->
必备的三部分内容:标签html:这里面包含其他标签,至少要包含head脑袋和body身体
1、标签head中包含的内容有网页的元数据，样式，脚本等内容。这些都不是在浏览器中直接展现给用户看的元素。把一些配置的信息放在这里。

2、标签body中是放展示出的东西

3、标签meta元数据,属性charset="UTF-8"告知浏览器当前页面时用的字符集是什么

4、标签title网页标题

5、标签h1--h6显示各级标题，1最大6最小 属性 align="center"：居中

6、标签center里居中(这个标签在html5以后不用了,用css来居中文本,这里临时用不然要扯很多)说绝对定位这个东西有点问题,也有黄色警告

7、标签input输入框  属性type="text":这是一个文本输入框  属性size:输入框的长度 属性name="":输入框的名字叫什么
   属性type="button":这是一个按钮,value=""展示按钮上的字 属性事件onclick="alert('点你妹啊')"点击效果=提示框
   属性type="submit":这是一个提交按钮,专门提交表单
8、标签tr：行   td：列  td的属性:colspan="2" 合并几(2)列   align="center"：居中

9、标签table:表格  属性:border="2" 边框和厚度  也可以改颜色后边学

10、标签form:表单,项目里有解释 第一次用是v11。method可以不写，不写默认是get。并且get和post写大小写都行


#-----------------------------------Web.day01_HTML01------------------------------------

##XML&HTML的区别
 - XML：可拓展标记语言：标签名可以随意写
		成恒：XML-自定义标签语言，想写什么标签就写什么标签，自由定义，自己指定规则。除非加入一些xds，dtd进行约束，否则可以随便写。只要不违背xml基本的规则：每一个节点都要有结束、根节点有且仅有一个、节点嵌套。
``						-------**重点在于将数据组织起来进行传递**。
 - HTML：超文本标记语言：标签名都是固定的，不能乱写
		成恒：HTML-预定义标签语言，里面的标签都是预先定义好了的。比如<a>就是超链接标签，<p>标签是段落，不能写没定义的标签。
``						--------**重点在于呈现内容**
 - 纯文本(Text)：不包括字体大小颜色，只包括字符
 - 超文本(word)：指不仅仅是文本，还包括：文本样式和多媒体(图片、音频、视频)相关内容


2、Open with：Sysetm Editor---用系统编辑器打开，就是系统默认的浏览器打开

3、现在Http最高版本是http5(H5),也是十几年了

4、回车键在html里识别的是空格,要想在页面表示回车用<br>

5、属性align不写默认是left

6、demo04中的标签：加粗、斜体、删除线、下划线这几个标签都作为了解即可，因为这些都是和样式相关的东西，和样式相关的东西在CSS里都会再提供一套。-------凡是和样式有关的使用的话是推荐使用CSS的。(所以这几个标签有的也给警告不推荐使用)

7、访问站外资源 : 
也叫盗链, 好处: 节省自己网站资源；坏处: 有访问不到图片的风险----防盗链(稍微改个地址字母就行)

8、关于<img>的alt属性和title属性，经过个人实验，如果不给定alt属性，那么title会赋给alt，当图片不能正常显示的时候会显示title文本，鼠标悬停也会显示title文本。
那么alt就没有存在的必要了吗？存在如下情况：
如果图片不能正常显示，可以让alt="图片加载失败"，让titel="图片表达的东西-比如 波雅·汉库克"。这样不懂的人至少能知道图片加载失败了，如果只设置titel可能就有些不明所以。

图片如果只设置宽度则高度等比缩放

9、demo05：元素的宽高：
<html>：的宽高是浏览器窗口的大小
<body>：的宽高比窗口大小小一丢丢，上下左右各少8个像素。因为我们做的东西都在body里面，为了美观这样来做

/经实验，给元素设置宽高的时候，用px都可以实现，如果用%来赋值，这个%是相对于此元素的上级元素来说的。上级元素如果没有确定的宽高则下级元素的%赋值方式不生效。实验中还发现，html语言中body没有宽高的属性，要给body赋值宽高要用css
##关闭工程和隐藏(过滤)工程的操作
 - 关闭工程：选中一个或多个工程后右击-->Close Project或Close Unrelated Projects
 - 隐藏(过滤)工程：Filters and Customization 过滤和定制-->Filters过滤-->勾选Closed projects


#--------------------------------Web.day02_HTML02&CSS01---------------------------------


1、demo02：target="_blank :目标在一个空白页面--点击超链接后打开一个新页面跳转

2、跳转地址： # 代表当前页面

3、加锚(demo02-03)：如果跳转的不是标签，那么就单独加一个<a id="top">锚，比如文本；如果跳转的是一个标签，那可以在这个标签里加id，比如图片<img id="girl1">;  

4、form表单：
<input type="submit" value="xxx">  提交按钮 value默认="提交"
<input type="reset" value="xxx">   重置按钮 value默认="重置"
<input type="button" value="xxx">  自定义按钮  value默认值

5、demo7时间选择器，每个网站基本都是这样的，一行代码就可以搞定。如果要求自己做一个别的风格的可能1000行代码都写不完，刘国斌工作的组员那时候写了半个月

6、文本域的cols是：规定文本区的宽度（以平均字符数计）。

7、dome08-基线对齐：图片和文本框在一起显示，图片的下边线和文本中字母的基线对齐

8、定义列表用的不多，一般涉及到层级的通过嵌套来实现。嵌套可以任意实现N层嵌套

9、学习表单就是学习控件，把前端和后端联系起来的就是表单

10、demo06-<th>：表头--加粗并居中 

11、<a>标签：中不加任何属性就是文本


#-----------------------------------Web.day03_CSS02-------------------------------------


1、demo09：块级元素的边距意思是它指定范围之内不能有东西。所以上下左被顶开，右边40不能有东西但现在还看不出来，因为他是块级元素各占一行，行内只有它，以后会学怎么把别的东西弄进去

2、边框的各种样式可看 达内文档-CSS文档-CSS边框 文档，最常用实线solid

3、为什么行内元素外边距是左右相加，块级元素上下外边距取最大。为什么行内元素边框不影响高。意义何在

4、为什么叫伪类选择器：一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，他又会失去这个样式。。。查的加自己盖了点，仔细想想这么说也沾点边吧

5、任意元素选择器，也可以叫所有元素选择器： *{} 把所有元素选中


#-----------------------------------Web.day04_CSS03-------------------------------------


1、border-radius:26px;设置圆角，值越大越圆。到宽高的一半开始就为圆形且不变了。
   执行方式是从四个角开始向四个边线的xx个px范围内磨圆

2、demo03:字体类型显示不出来很正常，因为字体是有版权的，linux本身就开源的不挣钱，所以不会弄那么多花钱的字体。
	字体可以写多个，按照先后顺序，能显示哪个显示哪个。

3、margin外边距：0px可以直接写为0

4、overflow:hidden;解决粘连问题和它本身的功能没关系，只是用这个可以解决粘连这个小bug


#-----------------------------------Web.day05_CSS04-------------------------------------


1、浮动定位：left是从左向右找位置，right是从右向左找位置。
一行装不下换行时(例如left),在上一个元素的下边缘从右向左找位置，存在被卡住的可能。

2、浮动元素 clear:right/left/both  意思是元素的左/右/两侧 不能存在浮动元素，如果元素浮动了，不希望后面的元素顶上来，那就可以添加clear属性

3、当元素的所有子元素全部浮动，则自动识别的高度为0，通过给元素添加overflow:hidden解决
（目前为止overflow:hidden解决了粘连以及浮动影响的高度问题）

4、HTML字体有最小像素12px，知道就行。

5、去掉ul的点 --> 在ul里写list-style-type:none;


#------------------------------Web.day06_HTML&CSS课程总结--------------------------------


1、几个人一块做一个页面的时候，不能用标签名选择器，不能影响别人的代码

2、可以这么写margin:40px auto;

3、滚动截图工具：FastStoneCapture

4、z-index：可以控制层叠元素的顺序，谁在最上边。见demo01
默认z-index:0; 值越大离用户越近(最上边)，越小越远。可以设置负值
设置相对定位绝对定位涉及到层叠问题的时候，哪个想显示在最上边可以设置这个值最大。


#----------------------------Web.day07_JS苍01，斌在08基本重述-----------------------------


1、没有编译器的语言：脚本语言，直接解释执行的语言。
有编译器的语言：编程语言；  (没有编译器也就不能在运行之前进行语法检查，写错了就写错了)

2、<script>标签引入外部脚本的话，在这个起始结束标签里边不能再写别的脚本，写了白写不能用（demo02）

4、上午笔记：特殊值用于表示变量没有引用对象的情况。他写错了--11.29

5、两个非常重要的宿主对象：
window对象：代表当前浏览器的窗口	文档：Window 对象表示浏览器中打开的窗口。
document对象：代表浏览器里显示的那张网页-->html	文档：每个载入浏览器的 HTML 文档都会成为 Document 对象。

6、JS有兼容问题：
兼容问题体现在宿主提供的对象不一样。浏览器提供的宿主对象有兼容问题，而且兼容问题是比较严重的，因为每个浏览器不一样。所有浏览器内嵌对象都兼容，没有兼容性问题。

7、JS的方法(API)可以看JS文档

8、创建String对象的语法有两种：
- new String(s);	例：var ss= new String("abc") 这个方法不常用
- String(s);	例：ss="abc"   直接赋值 一般都用这个
	/别听刘苍松的，不要不加var直接赋值，可以百度区别，和全局变量局部变量有关。

9、id是唯一的,开头不能写数字

10、ondblclick   db：double   双击事件。班里谷歌浏览器不支持---浏览器兼容性问题。
其实很少有双击的情况，所以它没支持这个功能

11、demo05-06
用id在document对象中找到div元素->var div = document.getElementById("msg");
innerHTML 读写div元素内部的内容->div.innerHTML = msg;

12、JS中的数组准确说不是数组，它和java中的ArrayList一样
数组声明：var arr = [];
数组中插入元素：arr.push(8)和arr[arr.length] = 8  一样
数组中可以放不一样的类型 ，都是对象

13、JS代码分号可以不写，一行就是一行。如果一行代码有多句，那必须写分号。
建议一直写分号，好习惯


##小项
1. Chrome浏览器按F12后右击刷新可以清空缓存并硬性重新加载


#----------------------------Web.day08_JS02重述07苍内容&...------------------------------

js打桩调试的两种方法：弹出框： alert();控制台输出信息console.log()    (log-记录，日志)

1、null是对象类型的特殊值	undefined是未定义类型

2、undefined 和数值计算，undefined转为NaN  且计算结果也为NaN---任何数和NaN计算结果都是NaN

3、字符串转成数值：paseFloat()和Number()一样

4、控制台<·undefined 是没有返回值的意思

5、demo04_ JS中判断是否为一个数--判断是否为NaN用： isNaN()--true则不是一个数

6、demo05注意，输入框的内容都是字符串，在js中进行 "- " "*" " /" 运算时字符串会隐式转换成数字，但是进行"+"法运算时是字符串相加，这时代码中要先parseFloat()或Number()转成数字。
不要用parseInt()，因为paeseInt是整数计算，而输入的可能会有小数

7、chrome浏览器会自动为页面当中添加了Id的元素获取元素，自动加一行var id = document.getElementById("id")
代码，即id名是可以直接用的，不用去写这个了。--从demo05开始省略，写熟了就不写了。但只有谷歌chrome才可以

8、demo06- xx.innerHTML加的是HTML内容，即这里是可以直接添加标签的，如：  myul.innerHTML="<li>aaa</li>;
xx为几乎所有的元素，即几乎所有的元素都有innerHTML。文档说的是Element.innerHTML,Element对象表示HTML元素，我理解为所有HTML的元素都有这个属性

9、修改或添加元素，"=" 是覆盖，"+=" 是追加

10、正则表达式，var reg = /规则/模式; 模式：i忽略大小写 g；全局查找
忽略大小写"i"：不加区分大小写，加了大小写都行
全局查找"g"：比如 a abc abcd 查找a->如果不加g只会找到第一个，加上g之后就能查到所有的


#------------------------------------Web.day09_JS03-------------------------------------


1、on开头：
 - onsubmit:当提交时
 - onclock:当点击时
 - onblur:当失去焦点时
 - on:当...的时候，在...的时候

2、demo02中onsubmit="return ...+...==2"而不用"return ...&&..."判断的原因：
这里写onsubmit是判断登录是否跳转页面，如果不判断那么只要点击登录就会跳转；
而用"&&"的话，如果上来就点击登录，那么&&前的方法执行一次返回flase，&&后的方法会被短路,这就有个小bug，点登录时页面不跳转，但是只有第一栏显示格式错误，第二个方法被短路所以第二栏不显示格式错误。

利用"return ...+...==2"的原理是因为布尔值类型隐式转换数值：true=1，false=0；

解：事件取消
**在任何一个事件中执行return false**；这个事件就取消掉了。理解：
return一个false(假)，那么就会取消这个事件。比如
onclik="return flase" 点击的事件为假。则取消点击要触发的一系列事件，阻止鼠标的点击事件
onsubmit="return flase" 提交的事件为假。则取消提交要触发的一系列事件，组织表单的提交事件

3、demo03-js创建自定义对象：
java中是要创建一个类再new对象。而js中没有类的概念：直接声明一个方法
 - 通过this.的方式给他声明属性并且赋值
 - 添加方法也是通过this.的方式给他添加方法

4、js关于面向对象的东西我们用的并不多，这是前端的东西，我们工作范围是后端。如果涉及比较复杂的内容的话公司会有前端工程师，面向对象的思想通常是在实现某些复杂功能的时候才会用到。简单的如果用面向对象反而会让整体逻辑变得复杂
所以面向对象的这些东西(demo03和dmeo04的创建对象)，了解即可，面试也不会问。

5、window对象是内置对象，js自带的。window对象内部的属性和方法称为全局属性和全局方法，调用时可以省略"window."
例如 isNaN() parseInt() parseFloat() Number() 这些方法都省略了window.

6、window的常用属性 - history 历史，指当前窗口访问过的页面历史
平时看的浏览器的历史记录是整个浏览器访问过的所有页面

7、demo05，用location.href=""  获取和修改浏览器访问的地址
这种方式的地址字符串中www.可以省略，http：//不能省略

8、屏幕垂直像素screen.height 和屏幕可用垂直像素screen.availHeight   两者的差为屏幕下方的任务栏
(linux的这两个垂直像素差为上边工具栏和下边任务栏。windows好像可以把任务栏移到两侧，那就也会有两个水平像素差)

9、demo07的eval()，很牛逼，文档里说是JS Functions(全局对象)的顶层函数(全局函数)
 eval()- 可以将字符串以js代码的形式执行

10、demo07的<style>！！一定要回顾！很解惑 涉及空白符影响，易忽略边框宽高的修改 ，浮动和行内块
 - 边框宽高的修改：
一般加边框要注意修改(减去)相应宽高的像素，因为加边框影响宽高。
但是！按钮！不一样，按钮加边框不影响宽高，是往里面加的。

- input不用行内块，用浮动的原因：
用行内块的话，还在文档流，受代码换行造成的空白符的影响，按钮之间有空格。
而使用浮动，脱离文档流之后就不受这些空白符的影响，全都贴到一起，再修改外边距即可。

另外，上下相邻的两个元素加外边距时：用行内块不脱离文档流，上下实际距离是两个元素的边距取最大值；用浮动脱离文档流实际则是相加

##浮动和行内块的用法区别：
		目前已经确定的：
 - 行内块不脱离文档流，**受代码标签换行等空白符的影响**，解决方法可以让元素的开始标签紧跟上一个标签的结束标签，在属性之间代码之间换行，可以用上级元素的text-align:center让行内块居中(这个没试，按理可以，在文档流)。
 - 浮动脱离文档流，不受代码标签换行等空白符的影响，但是不能用上级元素的text-align:center居中，多个浮动元素要想居中需要将他们放进一个文档流的上级标签中，比如放在一个div中，让div去对齐
 · 另外，上下相邻的两个元素加外边距时：用行内块不脱离文档流，上下实际距离是两个元素的边距取最大值；用浮动脱离文档流实际则是相加
	/在文档流才能用文本对齐：text-align:xxx	/有些做出来的效果有莫名其妙的间隔，也看不出原因，就有可能是空白符影响的。比如我做pal5q的时候，上边的导航栏就受了标签换行的空白符影响，导致几个导航元素在计算好的宽度内装不下。可以用上述方法解决。


#------------------------------------Web.day10_JS04-------------------------------------


1、给元素对象添加样式：  div.style.样式名称="样式的值"; 
 - .style可以给任何样式赋值 比如.color .border .backgroundColor .marginTop

 - CSS的属性与JS访问CSS属性的对应关系为：
	赋值时CSS中很多像background-color，border-radius这样带"-"的。
	在JS中，所有的带"-"的要把"-"去掉，然后"-"后的首字母大写，驼峰命名的方式写代码
 -！ 这种给元素对象添加样式的方式属于添加内联样式，优先级最高。优先级最高，则除它自己之外的其他的样式都改不了它。


demo03！需要温习，有利于写网页
2、demo03
要图片实现的横向轮播，应该让图片横向排列。但是不能用浮动和行内块，因为图片在父元素div中，无论是否浮动或者行内块，div一行都装不下，一定是被挤成纵向排列(自动转行)。
两种解决方案：
 - 通过相对定位挪成一排，
 - 改为绝对定位，则三个图片都重叠在div内，第一张不动，让第二张距离第一张一张图片距离，第三张距离第一张两张图片距离。
用绝对定位(脱离文档流,全都重叠在左上角)只需要改left值，相对定位(从初始位置进行位置偏移)需要改left值和top值
影响下边的元素所以用绝对定位。（注意，我试了一下，虽然相对定位的图片不脱离文档流，但是三张图片都在div里，div就占那么大地方，里面的元素不脱离文档流但是也不会影响到和div同级的元素的显示，应该可以说子元素的文档流应当都在父元素内）！！！？？？？？？回家查以下文档流，文档流的范围，父元素子元素文档流等等！！！！1？？？？？？！！！！！

3、day09_demo06&day10_demo03:
onload：如果页面初始化时要对页面中的元素进行读取或者修改，那么一定要写在onload里面。毕竟元素还没加载出来的话是操作不到它的。

4、demo03
字符串转数字的两种方式的区别：(可在浏览器控制台Console.log()测试)
自动的隐式转换： 例："180px"-80  只要不是纯数字结果都是NaN，说明字符串"180px"转为了NaN
显示转换：例：parseInt("180px") 结果是180   parseInt("px180") 结果是NaN  
	原理是从第一个数字开始取，取到不是数字为止。如果第一个不是数字则NaN

5、demo03 
  onmouseover=... onmouseout=...  鼠标移入和移出事件
鼠标移入停止定时器，移出开始定时器	-关联的定时器是图片停顿显示2s的定时器，不是图片滚动的定时器，所以图片滚动的时候鼠标放上去不会停
没有方法能让已经停止的定时器继续走，只能重新启动。

每次刷新页面后第一张感觉停顿时间比别的长一点点，是因为轮播的过程也在每一张的停顿显示时间之内，第一张不需要滚动过来，停顿多出来的那点时间就是后边图片滚动的时间。

此时还有个bug：当切换别的页面后，这个页面会停止渲染，但是时间的定时器还在走，代码逻辑还在走。当你回来之后它会把之前没渲染出来的一起渲染出来。(就是呼呼呼地把没渲染的跑出来，把失去焦点和获取焦点事件注掉，就能看到这个bug了，但是我发现，用失去焦点和获取焦点这个事件来解决这个小bug并不很合适，因为它那个小bug不是因为焦点，而是这个窗口有没有在桌面上。用焦点解决的话，当窗口显示在桌面上鼠标焦点不在窗口轮播也会停，和我们平时上网的时候是不一样的)

6、demo03，还有个小bug，失去焦点和获取焦点不是对称的，有可能会连续两次获取焦点，这样会造成失去焦点的时候它还在走，获取焦点的时候因为存在两个定时器而走的更快了。解决方法是在每次获取焦点的时候，都先关闭上一个定时器，然后再打开一个新的定时器，即使上一个定时器已经关了再关一次也没影响。
！！！！！我也不知道怎么操作才能让他连续两次获取焦点！！！！！！！！

7、setInterval(showtime,1000);是加载完等一秒才开始执行？还是说因为执行js代码的时候没加载完元素！！！？？？

8、web08课堂笔记和09知识回顾获取年月日十分秒代码多了个d,改为：
d.toLocaleDateString();
d.toLocaleTimeString();

9、课堂笔记里，通过name属性查找元素：name属性是表单里控件的属性，提交表单的时候对应name和value的值

10、demo06创建元素对象：
A.目前知道的两种在页面里添加的元素方法：
 - 一种方法今天的笔记里有：先创建元素对象，然后可以把元素追加、插入到页面-demo06
 - 另一种方法：看笔记day08_8-xx.innerHTML="<li>aaa</li>

B.元素对象只有一个，如果创建了一个元素对象，添加到两个地方，那并不是在两个地方都显示，只会在最后指定的地方显示

C.弟弟元素这个名字是表示位置的意思，在弟弟元素的前面插入元素，插入的是同级元素且在它前面。

D.插入元素是不是只能写id？删除元素老师说不止能写id，只要能获取到的元素都能删，比如把demo06的li都删，我试了下不会弄！！！？？？利用课堂笔记####查找页面中的元素-来获取元素行吗

11、demo07通过给省份option加value，使用value来确定显示的省份下的城市。
！！！？？？为啥用value？我试了不能用id，好像和onchange有关！！！？？？看看onchange文档  课堂笔记好像说了"onchange(value值改变事件)"  看一下   月考题9.可以看看答案！

12、demo08
让图片在父元素div框的随机位置添加，不仅要脱离文档流，还要定位置，所以修改成绝对定位

Math.floor()和parseInt()的区别：
Math.floor()--向下取整，floor：地板，数学涵义：求一个数的地板。
	Math.floor对正数的小数取“舍”，对负数的小数取“入”；
	Math.floor(-5.2) -> -6     parseInt(-5.2) -> -5
parseInt()：把任意字符串转换为整数(丢弃小数部分。必须以数字开头)，返回一个整数。可以解析字符串。也可以向下取整
	praseInt属于类型转换，会对字符逐级判断，占用内存较高；

然后，网上说Math.floor()只能对数字向下取整，然而我在360浏览器试了(王哥说360浏览器是穿着马甲的Chrome，控制台确实没看出来啥不一样的)后边跟数字的字符串 '数字' 也可以，但是跟 '数字+非数字'输出的是NaN  我认为这里是发生了字符串向数字的自动隐式转换，说得过去

13、！demo08中第一次使用添加图片元素：
创建：var img = document.createElement("img");
地址：img.src="../imgs/2.gif";
样式：img.style.left=Math.floor(Math.random()*960)+"px";
     img.style.top = Math.floor(Math.random()*960)+"px";
添加：d1.appendChild(img);
......


#-------------------------------Web.day11_JS课程总结&...---------------------------------


1、课堂笔记页面相关:
给元素添加文本内容  d.innerText = "<h1>abc</h1>";它最终显示的是纯文本。这种写法存在兼容性问题，有的浏览器可能会不支持。所以一直在用.innerHTML 
.innerHTML涵盖了.innerText

2、demo01 this的使用10.17
这里事件不是动态绑定，是把事件源this当作参数传过去，是谁触发的传的就是谁。

3、alert() 传入字符串或者数字就弹出字符串或数字;
传入变量就弹出变量的信息；
demo01: alert(xx.nodeName)弹出变量xx的元素名(标签名，节点名，node-节点。实验了下如果不是个元素则显示undefined) 

4、demo01  隐藏ul
js代码中获取不到内部样式和外部样式，只能获取到内联样式。
两种方式：
A. 可以给所有的li在标签中加style内联样式隐藏。然后在js代码中获取样式内容。不推荐将css代码和html写在一起。
B. 通过js代码让页面中第二层的ul隐藏。 选这种，先在ul标签中加class。并且写在onload里面。
一个好的设计思路应该是：css代码和html代码、js代码等 分开写

5、demo02：
element.clientHeight/Width   返回元素的可见高度/宽度   element：元素
document.body.parentElement.clientWidth
document.body.parentElement.clientHeight
得到html的宽高，即窗口的宽高    /缩放的话宽高值也会跟着改变(因为是像素，缩放就是缩放窗口容纳的像素)

onresize窗口尺寸改变事件。事件中写的代码用来实现每次窗口尺寸改变的时候，把画面尺寸改变成和窗口一样；
demo02中有使用到典型的事件的动态绑定

6、demo03获取全选的选中状态checked的两种方法
A. 给全选加id，在js中通过id.checked获取
B. 给全选的onclick事件传出事件源this，在js中接收。
两种差不多，都可以，用的第二种

7、event：事件对象	demo04中第一次使用  demo05中详细使用
参看课堂笔记;  /文档解释：Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。事件通常与函数结合使用，函数不会在事件发生前被执行！

demo05：键盘按下事件，linux系统有可能被输入法影响：键盘按下不同的键输出的字符编码可能是一样的值。切换一下输入法就可以了。

通过event对象获取事件源存在兼容性问题，有的支持event.target，有的支持event.srcElement   chrome两种写法都支持	target：目标
解决兼容性的写法-->var obj = event.target||event.srcElement;    demo05有

利用event.target更新了day09的demo07计算器-->demo07s

通过event对象获取的事件源和this的不同看一下我在demo06t1和demo06t2的测试，回头再研究//uc浏览器收藏：基于js中this和event的区别，这里面好像有具体的答案，关于我这里两个冒泡实验的。

8、demo06事件传递，事件冒泡-->课堂笔记

看笔记整合：###js中的事件

9.关于body里的背景元素	-> pal5q_test
 文档里所说背景元素作用在除了外边距的盒子模型，但是我发现这一说法对body不适用(实验对div适用，除了body应该都适用)，不管给body加多少外边距，背景元素都会忽略，背景元素设置在body中更像是作用于整个html里。问了国斌老师他只说了句：body比较特殊。！！！！！！？？？？？？待以后深究。

web11的课堂笔记把鼠标大战僵尸的步骤写在了web10中(因为用web10回顾了知识，老师没注意)，也传了上去，把鼠标大战僵尸的步骤移到web11笔记中即可。笔记整合中已经改好了


#----------------------------Web.day12_JQ01苍，斌在13基本重述-----------------------------


jquery.com官网下载JQuery。
JQuery官网说的是：JQuery是一个快速的，小的，以及功能丰富的JS库
JQuery口号：write less,do more ->写的少做得多。  比如：onblur->blur  onclick->click  value->val
innertext->text innerHTML->html

1. html网页加载顺序：
百度'html加载顺序'，参考CSDN： https://blog.csdn.net/m0_37550086/article/details/77513676
html文件中的代码**从上到下**运行，先解析head标签中的代码
	1.head标签中会包含一些引用外部文件的代码，从开始运行就会下载这些被引用的外部文件
		当遇到script标签的时候浏览器暂停解析（不是暂停下载），将控制权交给JavaScript引擎（解释器）如果<script>标签引用了外部脚本，就下载该脚本，否则就直接执行，执行完毕后将控制权交给浏览器渲染引擎
	2.当head中代码解析完毕，会开始解析body中的代码
		如果此时head中引用的外部文件没有下载完，将会继续下载
		浏览器解析body代码中的元素，会按照head中声明一部分样式去解析
		如果此时遇到body标签中的<script>，同样会将控制权交给JavaScript引擎来解析JavaScript
		解析完毕后将控制权交还给浏览器渲染引擎。
		当body中的代码全部执行完毕、并且整个页面的css样式加载完毕后，css会重新渲染整个页面的html元素。
 - /详细可看云笔记
 - 所以在js、jq中添加对html的操作的时候，才要在页面加载完成事件中写。
 - 所以苍老师说把JQuery写在body标签内靠后，这样页面的主要内容可以先让用户浏览。
	
2. JQuery 很牛逼的一点是所有功能都写完了，进行适当的压缩后，大小只有一百来k。所以JQuery对网页加载速度是几乎没有什么影响的。

苍松用的是：jquery-3.1.1.min.js  这个85k，老版本1.2的是100多k  min是用一些算法压缩了原始的jquery，把js文件中的所有空格、不需要出现的符号去掉，方法名都改成单一字母。体积很小，但是人就不是很方便看懂了。
day13最后demo07中，国斌老师说3.1.1版本不如1.4.2稳定，隐藏显示上滑下滑的效果不大一样，所以让我们用1.4.2。笔记下载里有,压缩版和非压缩版。

现在有个很流行的做法是把所有的JScript标签写在body最后的位置上，好处是网页都显示完了才加载JS脚本，不对阅读产生影响，网页主要是阅读。小问题就是没加载完JS没有动态的效果，点击菜单等也没反应。互联网开发中这个做法很常见
国斌老师上课的时候,js都是写在head中,是因为我们写的都很小,不会对加载造成影响。但是JQuery的大小80多k已经能对加载速度产生影响了，所有第三方的js引用都写在最下面。

3. JQuery是函数式编程，苍老师说什么是函数式编程：一个方法完了调下一个方法调下一个方法一直链下去的编程方式叫函数式编程，我们在学stringBuilder的时候他的append()方法就可以一直点下去。(append().append().append()...)。我查了一下并没有这么简单，范传奇也提过函数式编程，查询"函数式编程"可看到。以后深究。

5. $函数->  $()  JQuery为了让程序员写函数简单点短点，它定义函数就一个字母->$	(克晶：函数=方法=过程)
$函数最重要的功能是帮我们找对象
参看课堂笔记："$() 函数用途""  

6. $函数的使用必须写在 script引入JQuery 标签的后面，因为只有引入了JQuery才能使用$函数

7. DOM和HTML满意解释
笔记图dom.png:网页部署在服务器(WebServer)上,浏览器发送http请求完，html网页文件下载到浏览器。html网页在浏览器里有一个非常复杂的渲染过程，会在浏览器里创建一个树状结构，树状结构的根源素是document对象。document对象对应整个HTML。
一句话：网页加载到浏览器，渲染以后的数状结构叫DOM。
DOM和HTML不能简单的等同化：HTML特指在服务器部署的那个静态的网页(HTML文件)，浏览器运行了以后叫DOM
所以课堂笔记才说JQuery封装了Dom (和CSS,JS等, 提供了更加简便的操作API)；
所以JQuery操作的是Dom，不是HTML，虽然JQuery代码是写在HTML文件中，但真正执行是在浏览器中执行。
查阅资料知道：JS不止是操作DOM，在浏览器里面操作DOM仅仅是js的一个应用场景。

8. "JQuery和Dom对象相互转换" 参看课堂笔记

9. test01:验证$(function(){})
$(function(){}) 在页面加载以后执行的方法。/ 相当于window的onload事件。
此函数可以多次注册，页面启动加载完会全部执行。而window.onload只能注册一次，写多个则只执行最后一个

###ready和onload的区别
> 来自百度
- JS中的页面加载完成事件：
	window.onload             页面加载完成后执行方法----写法：onload= function(){...}
- JQuery中的DOM结构绘制完毕事件： /这么说更谨慎吧
	$(document).ready()    DOM加载完成后执行方法---写法：$(function(){});
- 执行时间： 
	window.onload 必须等到页面内包括图片的所有元素加载完毕后才能执行。--------------------晚
	$(document).ready() 页面中所有DOM结构绘制完毕之后就能够执行，不必等到加载完毕。----早
- 编写个数不同：
	window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 
	$(document).ready()可以同时编写多个，并且都可以得到执行
- 简化写法
	window.onload没有简化写法 
	$(document).ready(function(){})可以简写成$(function(){});
		/$(window).load(function(){  } )  等价于js中的  window.onload=funciton(){  }
- 总结
	- $(document).ready()方法和window.onload方法有相似的功能，但是在执行时机方面是有区别的。window.onload方法是在网页中所有的元素（包括元素的关联文件）完全加载到浏览器后才执行，即JavaScript此时才可以访问网页中的任何元素。而通过jQuery中的$(document).ready()方法注册的事件处理程序，可以在DOM完全就绪时就可以被调用。此时，网页的所有元素对jQuery而言都是可以访问的，但是，这并不意味着这些元素关联的文件都已经下载完毕。
	- 举一个例子，有一个大型的图库网站，为网页中所有图片添加某些行为，例如单击图片后让它隐藏或显示。如果使用window.onload方法来处理，那么用户必须等到每一幅图片都加载完毕后，才可以进行操作。如果使用jQuery中的$(document).ready()方法来进行设置，只要DOM就绪时就可以操作了，不需要等待所有图片下载完毕。很显然，把网页解析为DOM树的速度比把网页中的所有关联文件加载完毕的速度快很多。
	- 另外需要注意一点，由于在$(document).ready()方法内注册的事件，只要DOM就绪就会被执行，因此可能此时元素的关联文件未下载完。例如与图片有关的HTML下载完毕，并且已经解析为DOM树了，但很有可能图片还未加载完毕，所以例如图片的高度和宽度这样的属性此时不一定有效。要解决这个问题，可以使用JQuery中另一个关于页面加载的方法——load()方法。load()方法会在元素的onload事件中绑定一个处理函数。如果处理函数绑定给window对象，则会在所有内容（包括窗口、框架、对象和图像等）加载完毕后触发，如果处理函数绑定在元素上，则会在元素的内容加载完毕后触发。
	- $(window).load(function(){  } )  等价于js中的  window.onload=funciton(){  }

10. 标签属性：name和id
name是给服务器用的，提交表单让服务器解析；id是唯一标示，是我们编程的时候用的

11. 几乎所有的(其实就是所有的)JQueryAPI方法返回的都是JQuery对象，这时可以连续调用JQuery对象提供的API方法-----函数式编程

12. demo10中，苍老师用到了this，说：this 代表响应"当前"事件的dom元素。我觉得他说的比原先国斌老师说的好理解。

13. demo10中hide和show里的参数 表示的是隐藏和显示的过程毫秒数


#----------------------------Web.day13_JQ02重述12苍内容&...------------------------------

看看选择器的总结

1. JQuery和JavaScript中事件的动态绑定写法： ->练习 1_base_selector

	JS里的动态绑定写法：
		b1.onclick = function(){...}
	JQuery里的动态绑定写法：
		$("#b1").click(function(){...}

2. "子元素选择器" 看课堂笔记&练习5&5_Childtest
	这个选择器就是从css来的，css中的文档解释:选择属于其父元素的某个子元素的每个<xx>元素
		比如：div:first-child  选择符合： 是div的父元素的第一个子元素的每个div元素
		按照老师的解释：这个比较好理解
		div:first-child  选择符合： 是div 是子元素 且是所在层的第一个
		form div:nth-child(n) 选择符合： 是form的子孙元素 是div 且是所在层的第n个元素
		from>div:first-child  选择符合： 是div 是from的子元素 且是本层第一个
	总结一下：
		这个子元素选择器其实应该是和我们原先所学的选择器都一样。
		只是在把 : 前面的选择器选择到的元素 用 : 后的要求再选择一次

3. 练习6表单选择器中   (课上的6个练习，17号补传上去的)
.length属性： 获取选择器里面选择到的元素数量  
    例：alert($(":radio").length); 弹出radio 元素的个数
.each()方法：把选择器选择到的所有元素遍历一遍，遍历时的this代表选择器选择到的元素
    例:$(":checked").each(function(){alert(this.value}; 弹出所有checked元素的value值。
    this代表当前遍历的js元素对象(或说DOM对象，一样),也可以转成JQuery对象：this.value-> $(this).val()
    :checkde 选中的单选、多选、下拉选   

4. demo02：children() 得到元素的所有子元素。
    这里用$(this).而不用this.是因为children()是JQuery的方法。
/文档：筛选_查找_children([expr]):取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。

5. demo05：注意通过css添加样式和html属性添加样式。所写的代码是不一样的。
css的单元格边框间距为0  border-collapse:collapse;
CSS中这样写：table{
			border:1px solid red;		/边框间距为0其实table就不用加border样式了
			border-collapse:collapse;	/因为和td、th的border重合了，被覆盖掉。	
		}
		td,th{
			border:1px solid red;
		}
html的cellspacing：单元格之间的间距和单元格与边框的间距
day02_demo04通过html中table标签属性这样写：<table border="1" cellspacing="0">  

6. 查看课堂笔记的"修改和获取元素的"文本内容/heml内容/属性：
    $("#abc").text(？);  $("#abc").html(？);  $("#abc").attr("class",？);
    ？="xxx"   写内容是修改，不写内容是获取。

！！！？？？回头实验一下，js中是不是也和这个类似。(innerxx  .xx)

7. demo05，数量的加减按钮，onclick事件传入参数加(正)1减(负)1，方便得达到实际效果。灵活，很棒。

8. function num(x){}中得到事件源(按钮) 用event.target，而不用this是因为只有动态绑定事件中才能用this。
而我们num(x)事件虽然是在js中写的，但是是以var numtd = $("HTML元素字符串"）的形式把字符串解析为Dom对象添加到页面去的，这不是动态绑定。(以点"."的形式才是动态绑定吧)

9. demo05的each()参看第3条笔记。children()参看第4条笔记。

10. demo05中 判断如果money不能为金额 也不能为空字符串
之所以判断是否为空字符串是因为，遍历到总价那一行的时候，这行的第4个td是空串。空串用isNaN判断不出来是否是数字。
！！！？？？回头可以做个实验加强验证一下：跨列合并后第x个元素能不能检测出来，检测出来的nodeName是什么。空串能不能判断出来是数字，用isNaN("")，number("") 能不能转成数字。

11. demo07加相对定位的原因时下面会用到left top 定位

12. demo07：
 - hide(3000) show(3000); 括号里的参数表示的是执行过程的毫秒数。day12_demo10中第一次用到过。

 - hide(1000,function(){...})方法中时间参数后的方法叫做hide()的回调方法。会在执行完这个隐藏方法后调用function(){}方法，我试了hide()中只写方法不写时间也可以。这一页的方法试了几个都有回调方法。
	以后遇到这种类似的方法都可以尝试一下有没有回调方法。

13. jquery-3.1.1版本和1.4.2版本隐藏显示上滑下滑的效果不大一样，所以让我们用1.4.2。说3.1.1这个效果不好，1.4.2更稳定一些。


##JQuery和JScript设置样式的写法
``	**demo08是在MySQL.day01早上讲的，雪花作业**
 - 在JQuery里设置样式是xx.css("样式名称","样式的值")
		连续设置多个样式是xx.css({"样式1名称":"样式1的值","样式2的名称":"样式2的值"}) 
		demo08练习中size+"px"会自动转成字符串的。
 - 在JavaScript里设置样式是 xx.style.样式名称="样式的值"
		好像不能连续设置多个，只有day10和day11学的用的，demo中只一个一个设置
 - 这两种添加的都是内联样式
 - day12_demo中,苍老师用到了Jquery设置样式，并说：真正工作不在JQ中写css，因为内联优先级最高，除了自己谁也改不了，只是为了演示才这么写。


#-------------------------------------MySQL.day01---------------------------------------
教室的MySQL默认字符集utf8/默认搜索引擎InnoDB


2、整套解决方案：
 - SQLServer，微软产品，一般应用在微软的整套解决方案当中：微软有自己的web服务软件，自己的操作系统，自己的数据库(SQLServer)..一整套产品。 它的服务器用的都是自己的东西-->这就是一套的解决方案
 - DB2，IBM产品，一般应用在IBM的整套解决方案当中：IBM也有自己的web服务软件，自己的操作系统，自己的数据库(DB2)..      (IBM的操作系统一般应用于银行等对安全性要求性比较高的信息，交互性很差，安全性很高(功能少))
      / 功能越多越不安全：功能越多就要越多的接口，接口越多就越容易暴露更多的漏洞。 安卓比苹果安全性低就是因为安卓功能多，公开的权限多，而苹果少。

3、每个网站对应一个单独的数据库(database),每个库多个表。

4、老师用的数据库是MariaDB。课堂笔记有提到MariaDB
MariaDB和MySQL其实是一样的，分支的时候源码都一样，以后更新不一样而已。
MariaDB命令行显示的是：MariaDB [(none)]>
none说明没有选择数据库，选择一个库后none会变成use的数据库名，如：MariaDB [db1]>

##字符串：varchar(长度)
		参阅'char()和varchar()'
 - 长度：字符的个数。是可变长度(多给点没关系)：若写的是10，存的是3，则只占存进去的长度。
``		经实验：但若写的是3，存的是10，则只存进去前三个字符。
 - 另外，查看表详情知，int长度是11，正是正负21亿，其中第一位是'+' '-'号，后10位是数字，若存入的数字超出int，则显示最大or最小值


##windows中使用set names=gbk解决mysql在窗口乱码的问题
 - 解决：使用windows系统尤其是win10系统的同学，如果执行含有中文的sql语句时报错，则要先执行一下set names=gbk；
 - 原因：两次编解码的字符集(方式)不统一。
``		数据服务器是具备网络访问能力的，我们写的sql语句也都是通过网络数据传输的(只不过是自己传给了自己)。
``		sql传输的过程为：客户端(终端也是客户端)-->DBMS(数据库管理系统,比如MySQL)-->磁盘
``		在终端写好的SQL语句会先通过网络传入给MySQL，MySQL判断出来SQL语句是要保存什么内容，之后存入到磁盘中。
``		而传输时只能传输二进制010101，所以需要进行编解码，两次传输就需要进行两次编解码。
		---16.41
 - 创建数据库和创建表的时候指定的字符集是MySQL和磁盘之间传输的字符集。set names=gbk;是设置MySQL的解码方式。之所以用gbk是因为**win10里命令行默认编码是gbk(linux默认是uft8)，而且还没法改**。所以让解码字符集为gbk，以适应命令行的解码方式。
 - 成恒：如果使用win10的命令行，要频繁地执行set names=gbk；作用是告诉数据库这次地数据通过gbk的方式来处理，以适应这个命令行窗口。而且这个只是个变量，即每次重启数据库都要再执行一次。所以建议用window尤其win10的用可视化的第三方工具操作mysql，避免乱码。
 - 深入问题可百度：set names=gbk


##小项
1. 写代码时的**空格**：只要能区分开就可以不用加空格，比如‘单词字母’和‘括号运算符等符号’可以区分开，就不必要加空格。而连续的单词都是字母，则要用空格区分开，且空格一个或多个都行。


#-------------------------------------MySQL.day02---------------------------------------


1、触发自增：要让主键为null或0
可以全表插入主键写null或0；也可以指定字段插入不指定主键，即主键为null

2、``符号用于修饰表名和字段名 例如：`t3` `id` `name` ，创建的时候可以加上，也可以不加。查看表详情的时候可以看到这个符号是用来修饰表名和字段名的。

3、数据冗余：比如部门，很多人都在一个部门。若只有一张表，那部门名就会大量重复。而拆分为两张表，将部门名设置在一张表上，而员工表只设置一个外键，写入部门表对应的id即可。这样即解决了冗余问题。(虽然外键的数字也会重复，但重复量少了很多，只重复数不重复文本(部门名)。占的内存会比部门名少了很多)

4、执行sql语句的时候，回应的ERROR说明sql语句的语法有错误。
而如果语法没错误，只是没有所写的条件，比如xx='乱写一堆'。
则会回应QueryEmpty set 或者Query OK, 0 rows affected 等等。通过这里才能确保语句有没有按计划执行成功。

5、事务：
 - 没有事务保护：操作数据库的过程为，客户端写sql语句->MySQL解析->磁盘  数据库的数据最终保存在硬盘当中
 - 有事务保护： 1.sql语句使MySQL开启事务，之后提交过来的sql语句不会直接被写入磁盘，而是先在MySQL的内存中执行，第二条也是，以此类推。当sql语句为 提交/回滚 时，内存中的数据写入磁盘/直接清掉内存数据。
      (在客户端向MySQL依次传递:开启事务 业务(减钱AQL和加钱SQL) 提交/回滚   MySQL先在内存中走一遍业务,如果全部成功则提交到磁盘,修改磁盘数据。否则回滚。)
     判断成功或失败看返回的生效行数，或如下：
注意：开启事务后，在一个命令行客户端操作的数据是在内存当中的，查询的也是内存上的改变，若想要在开启事务中查询磁盘中真实数据有没有被修改，需要另开一个命令行。

6、truncate:删除表并创建新表  和使用delete清空表不同的是，自增数值本身是从历史最大值基础+1，用truncate会使自增数值清零从1开始，而delete不会。
    语法和drop table xx; 相似，为：truncate table xx;

7、分配用户权限相关SQL，我们几乎用不到，也不难，用到的时候可以查资料学。
我们现在连接mysql的时候自己访问自己的数据库用户名都是"root"最高权限的用户，工作之后分配的用户名所拥有的权限并非是全部权限。 比如看不了工资。


##PPT数据库数据类型
		整个刘国斌课上好像是唯一一次用到PPT：DATABASE_02_'数据库类型'这一页
 - 标黄色的：是常用的，白色的了解即可。
 - 其他数据类型：直接砍掉,我们根本用不到
 - 浮点数类型：DECIMAL  超高精度浮点数
 - 字符串类型：CHAR：用的少，char效率比varchar略高，但是因为现在设备性能已经很高了，效率差距可以忽略不计。
		业界默认的规则：短的字符串用varchar，长的用text。
		参阅'char()和varchar()'
 - TimeStamp时间戳：不赋值(即赋值为null)则显示当前系统时间
``		2038年是我们保存的时间的毫秒数长度受限的时候，临近的时候只需要改一下他的类型，改下长度即可。没那么可怕


#-------------------------------------MySQL.day03---------------------------------------


1. 查询数据：select查询多个指定字段信息用逗号分隔，where后边跟多个条件用and连接。

2. limit: 可用limit 0,1 取最值

3. 数值计算: 取余的两种写法  例： 7%2  等效  mod(7,2)

4.  SQL语言的HelloWorld 语法：select 'helloworld';
用select '';可以方便地测试一些函数，比如日期函数

5. 日期相关的，用到的不多，不需要背下来，了解就可以。用到再回去看。

6. 统计数量count(字段名)，字段名一般写*  如果写单独的字段名，若字段名存在null值，则null不计入数量。


#-------------------------------------MySQL.day04---------------------------------------


1、常用关键字的执行顺序select ..... from 表名 where普通字段条件 .... group组 by .... having聚合函数条件.... order顺序 by.... limit限制(分页)... ;      /回头百度更详细的顺序

2. 关于where后不能跟聚合函数的问题：

 - 首先明确：having要和分组查询结合使用。  因为having后跟聚合函数条件，聚合函数是进行多个数值运算的函数，而要使用多个数值的计算结果作为条件，那么理应是计算分组内的数据作为条件才有计算的意义。
    （是否使用having 要看条件是不是集合函数，是就用having，不是就用where。）

 - 解释1 - where后不能跟聚合函数条件，因为聚合函数条件(having xxx)要和group by结合使用，where写语句是在group by 之前执行，都没有group by 当然就不能使用聚合函数条件。   /注意这里说的是"聚合函数条件"，而不是"聚合函数"，聚合函数不作为条件可以跟在select后使用	

 - 专业解释2 - 聚合函数也叫列函数，他们都是基于整列数据进行计算的，而where子句则是数据进行过滤的，在筛选过程中依赖"基于已经筛选完毕的数据得出的计算结论"是一种悖论，这是行不通的。
        更简单说，聚合函数要对全列数据实行计算，因而使用集合函数的前提是：结果集已经确定；而where子句还处于"确定"结果集的过程中，因此不能使用聚合函数。

/ 所以老师才说having后面写聚合函数的条件，虽然也支持普通字段的条件，但是不推荐使用
/ 在group by 后的关键字，应当都可以使用聚合函数

3. 子查询 第8题 很重要
 解决 考虑并列 问题的大致步骤：
    一：先按照数值查询，用limit 0,1取值，这样从源头出发，即使有多个字段的值都一样，但我取的是值。并不在这一步直接取字段
    二：根据第一步取得的值查询字段，这样查询获得的字段可以有多个。避免了从第一步直接取字段产生的无法取并列字段的问题；
    三：根据第二步的字段查询题目要求的此字段的相关信息，用in(第二步) 这样取值。当查询字段的值为多个的时候使用in关键字，这样就可以取得in中的多个并列字段的相关信息。

4. 把子查询写在from的后面当成一张虚拟表，这种用法 必须起别名
从结果当中再次查询可以用这种方式。虚拟表(别名表)不真正存在，只是一个结果。
/我咋感觉虚拟表这么多余呢，select xxx from (select yyy from emp where deptno=10) nt;
直接写成select xxx from emp where deptno=10 不就行了吗。

##等值连接和内连接
 - 等值连接和内连接查询结果一样，得到交集数据，推荐使用内连接，因为内连接的关联关系写在where前面，更符合逻辑思维。而等值连接是把关联关系写在where后面，看着就别扭。
 - 内连接：之所以叫内连接是因为有一个省略掉的 inner  内部的
 - 外连接：左外连接和右外连接， left 和 right 是相对于join来说的，表明结合到左边还是结合到右边


#-------------------------------------MySQL.day05---------------------------------------


1. 作业 第5题 很重要 用并列问题的第二、三步解决。
/ count() 括号里不能写*，因为40号部门没有员工，但是有40号部门，count(*)=1，可以写e.任何字段，比如e.ename  因为员工表里按部门分组查询任何40部门的字段都是null，xxx=null，这时候(e.xxx)=0，这样才对

2. select后可以跟 e.* 可以这么写，关联查询中用    /e-表名，别名
count()括号里不能写e.* 不支持这么写。  /大概是因为e.*需要计算，count()也需要计算，学了这么久好像这些计算的关键字中都只是一层计算

3. 自关联    作业17题
自关联的查询方式： 把一张表当成两张表 通过内连接把两个表连接起来查询
内连接不存在关联的交集查不到，有一个没有上级领导，要用外连接 left join 

4. 多张表的连接       作业18题，在17题的自关量基础上关联另一张表 - 三张表
select ... 
from a join b on a.x=b.y
join c on c.z=a/b.m
join d on d.n=a/b/c.o
join ... 
...;

5. 课堂：表设计之关联关系  一对一  第3题
表关联查询所有信息select一个*即可

6. 课堂：表设计案例：权限管理：是 多对多关联关系 的拓展性内容。  /很重要的。
需要掌握的是多张表的关联，需要有主表和关系表，要知道为什么有这些表
用户表和权限表是肯定要有的，之所以抽出一个角色表是为了让用户和权限之间的关系管理起来更方便一些。如果没有角色表，那么用户表和权限表的复杂度就高了很多，一个用户要关联很多的权限，维护表就变得复杂麻烦了。
三张表多对多所以也就需要两张关系表


#-------------------------------------MySQL.day06---------------------------------------


1. 面试题，很重要
交易类型和关系其实是存在冗余问题的，亲戚，朋友，支付宝，微信等。但是这是笔试题，没有必要把这些冗余单独建表，不然本来两张表查询，要变成四张表，做题会很麻烦。
如果发现了这个问题，体现出来了解这个事就可以了，可以在答题纸上写：如果需要考虑数据冗余问题，则把交易类型和关系单独建表。避免冗余出现。

2. 视图好处：
 就是写的那段sql语句，重用sql语句可以提高开发效率
 数据库管理员可以用视图隐藏敏感信息，给你的用户名不能访问包含所有信息的表，但可以让你访问没有敏感信息的视图。

3. "复杂视图"： 看课堂笔记
只能查询不能修改：原因是因为修改没意义，显示的数据都是原表统计数据出来的数据
"数据污染"看课堂笔记

4. 默认约束的字段赋值写null就是null；只有不赋值才是默认值

5. 查看是否有外键约束：
 - desc xxx; 查看表字段  
	key列有 PRI(primary主要的  主键约束)  
	       UNI(uniqueness唯一的，独一无二的  唯一约束)
	       MUL(multiple多重的，多样的  外键约束？(外键可重复))
	如果有同时存在 PRI>UNI>MUL
	这个MUL，老师的意思这是外键标示，然后说了下一种方法。我百度了，key列的这三个东西和索引还有关系。收藏在了UC里
 - show create table xxx; 查看表详情 可以看到外键约束相关的关键字

6. 外键约束的名称，作用：
一个表可能和多个表有关系，一个表可能有多个外键。
由于外键约束可能有多个，所以在删除的时候必须通过名指定是删哪一个，这就是外键名的作用。

7. 外键约束17.42总结补充：
将来工作，外键约束使用的并不多，因为加了外键约束之后会对测试有影响，比如删除的限制。然后其实数据库里的数据是通过java代码添加进去的，我们完全可以通过java代码取控制哪些东西能添加，哪些东西不能添加，通过代码逻辑是可以实现外键约束的功能的。没必要在数据库这一层对齐外键约束，约束之后测试起来还麻烦。

8. 查看笔记下载中的索引介绍图 以及课堂笔记
数据库里的数据会在磁盘当中保存到一个个的磁盘块里。磁盘块(以后再深究这个东西)就类似于字典的每一页数据，每个磁盘块只有几k的数据。那数据量大了之后，磁盘当中的磁盘块数量也很大。每个磁盘块里除了保存要保存的数据之外，还保存有下一个磁盘块的地址，因为磁盘块是零散地保存的，并没有什么顺序。如果没有索引，查找数据的话是一个磁盘块一个磁盘块地去遍历查找数据。
添加了索引之后，就创建了如图的一个树装结构，每个磁盘块中保存紫色的键值，蓝色的指针，黄色的除了主键之外的数据。保存的每条数据是键值+黄色的。这时查询举例：查找主键值为60的数据，首先进入到第一个磁盘块，和其中的主键对比，若没有则比较60和磁盘块中主键的大小，若大于35就去35后边的p3找，进入下一个磁盘块，进行同样方式的查找。 降低了磁盘块的访问数量，提高了查询效率。

什么情况加索引：数据量大的时候加，但是由于每个电脑的执行效率不一样，所以这个量要通过加索引查询和不加索引查询比较时间试出来。如果觉得查询太慢，就加索引试试，效率有提高那这个索引就可以用，没提高就没啥用

9.  执行sql语句，返回的时间是查询时间，不是输出时间。0.85sec

10. 索引的字段长度：如果写3，就是从字段中取前3个字符作为创建索引的依据。如果不写就是以整个字段作为索引的依据。
一般不写字段长度，一般都用整个字段。除非字段里的内容都是这样的形式：adfaxxxx  jljixxxx  iosuxxxx 前边不一样，后边都一样的，只需要用到前几个字符就可以。

11. 非聚集索引的磁盘块中只保存磁盘块的地址没有数据（因为数据只需要有一份）	/数据只在主键那里有一份就可以了。所有的非聚集索引最终都指向聚集索引的数据当中
 / 那么如果没有主键，没有聚集索引呢，非聚集索引中也是没有数据的吧，都是指向数据保存的那个磁盘块中的吧。应该是这样，可以搜索一下聚集索引和非聚集索引的解释看一下。

12. 创建索引之后，对数据库该怎么操作还怎么操作。只是查询的时候更快了。

13. 事务的ACID特性，是保护事务正确执行的四大基本要素。需要背下来，面试之前看一看。
一致性：从一个一致状态(两个账户执行转账业务，从两个人的钱都没改变)到另一个一致状态(到两个人的钱都改变)
隔离性：可以同时开启多个事务，但事务和事务之间不受影响
持久性：执行完之后，数据会真正的保存到数据库文件当中，永久生效。

14. 查看数据库自动提交状态  show variables like '%autocommit%';
解释：其实事务开或者不开都是存在的。只不过数据库默认的自动提交状态为开启状态。
之前说：由客户端把指令发送到mysql数据库，如果不单独的执行begin的话，指令会直接操作数据库里面的数据(磁盘里的数据)。执行begin开启事务之后会先在内存里执行(打个草稿)，然后一块执行进磁盘中。
实际上：事务是一直存在着的，只不过他是自动提交：就是传过来一条，在内存当中执行完，立即就进入磁盘。这样有事务和没事务就没区别，在不在内存中操作没区别。
auto：自动 commit：提交
修改自动提交状态的两种方式：begin/commit 和set autocommit=0/1
将自动提交状态为关闭之后，剩下的操作和之前学的都是一样的。指令在内存中执行，只有当执行commit之后才会提交到磁盘。

15. 有个别同学的电脑，可能由于数据库版本的问题，导致查看数据库自动提交状态查不出来，但是不影响其他的操作。了解

16. group_concat() 组连接，会把分组查询到的数据连接到一起。
如果直接分组查询，只能显示每个组的第一条。
组连接就是仍然显示一行，但会把组内所有的数据拼接到一起。
涉及到组连接的题目需求中会有个关键字：显示到"一行"，在"一行"中显示

group_concat():括号里多个字段名用逗号隔开，并可以任意加,'xxx',字符串

17. 对于面试有的东西不会，但有印象，就说：之前用过，很长时间没用了，但是如果工作中要用到查询一下资料笔记就会用。


#----------------------------------MySQL.day07_JDBC01-----------------------------------
#结合课堂笔记，课堂笔记详细有解释。

	！单词：
Demo01: DriverManager：驱动管理器  conn：连接器  execute：执行(可执行文件exe就是他的前三个字母)
Statement：声明
Demo05: Stream：流  resource：资源

1. 接口：只有方法的声明，没有方法的实现

2. 创建mavan项目的时候，如果不勾选create a simple perject(skip跳过 srchetype骨架,原型 selection选择)
会让我们去选择一些骨架(工程模版)，勾选则创建一个完全空的工程

3. Group Id 和Artifact Id 和version 这三个信息组成了一个工程的坐标。
坐标：用来定位的，让别人找到自己。
	将来工作了之后，可能一个大工程需要几个子工程结合到一起去使用，这样的话你所开发的内容就可能被你的团队同事去访问。
我们在下载jar包的时候，搜索复制的坐标，就是那个工程的坐标。
把坐标粘贴到maven中。所以说maven的一大功能就是管理jar包的。
而且如果没有maven，还有可能我们知道了依赖什么jar包，但是这些jar包有的换了版本，有的版本和依赖或被依赖的就不能搭配，maven也解决的这个依赖问题。

	/我觉得这个坐标可能就和我们一串复制下来的WebServer不能一起用maven导入有关系。而用普通的项目导入，那样这个坐标还有用吗，这么多工程都是一个坐标，怎么定位。问了刘国斌之后，他还是没有解答。不过我终于有了清晰点的头绪了。

4. ctrl+a全选，ctrl+i将选中的代码格式化。比ctrl+shift+f好用，不用切换到英文输入法。不过windows系统不知道存不存在输入法问题，如果不存在那还是ctrl+shift+f节省时间。

5. pom.xml：dependency 依赖的意思，就是这个工程依赖什么工程，里面写依赖的工程的坐标。

6. Demo01  com.mysql.jdbc.Driver不直接在froName("xxx")里敲，先在外边敲出来，敲的时候会有提示。

7. 今天的这些代码，导包均导java.sal里的。不导com.mysql.jdbc的。
因为我们这些代码要在以后换数据库之后也能执行，如果导mysql的当然不行。


##数据库.properties配置文件
###数据库配置文件的写法
		名字不必一定这样，在DBUtils中能读取出并对应设置上值即可。
 - 注册驱动：Driver驱动=com.mysql.jdbc.Driver包名.类名
		方法一：可以先在java类空白处敲个Driver，alt+/提示出来。
		方法二：查看''数据库配置文件的写法'的补充'
 - 数据库连接地址：url=jdbc:mysql://localhost:3306/newdb3
		jdbc-接口:mysql-连接的数据库厂商的名称://localhost-连接地址:3306-mysql的端口号/newdb3-mysql里创建的数据库的名称
		连接地址：数据库是具备网络访问能力的，连本机也需要用地址的方式去连
		控制台成功输出则连接成功   /输出的是句柄xx.xx.xx@x。。 没重写toString方法吧
 - 用户名：username=root
 - 密码：password=
		没有密码后边什么也不写
 - 初始连接数量：initSize=1
 - 最大连接数量：maxSize=3
###个别同学在通过JDBC连接数据库的时候会出现中文乱码问题的解决办法：
 - 打开配置文件.properties，在url后面添加： ?useUnicode=true&characterEncoding=UTF-8
		成恒：最好加上，如果不加可能会出现乱码问题
 - 没有乱码的同学加上也没问题。  没解释为什么！！！？？？
###数据库配置文件的问题
		这个配置文件用 new file  后缀写properties  / 属性，特性
 - 为什么后缀用properties
		这个properties只是个名字而以，之所以叫这个后缀是因为后面用到的类叫Properties。配置文件并非只能是xml文件。起到配置作用的文件应该就是配置文件。
 - 为什么不用xml
		因为我们只存几个键值对，没有标签没有树装结构。用xml的话又要写标签又要用dom4j读取，又要写dom4j的一串。很麻烦。王哥说以后工作了，数据库的配置文件里信息也就是现在写的这几个：驱动、连接地址、用户名、密码、连接池的数量
 - 为什么用Properties
		文档：Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 -看demo05.java
 - 配置文件字符集ISO-8859-1
		国斌老师说配置文件中写中文会直接显示成编码。如果想显示中文，则右击这个配置文件的properties 把编码改成ISO-8859-1 
 - 为什么用ISO-8859-1
		文档：从输入流中读取属性列表（键和元素对）。输入流按 load(Reader) 中所指定的、简单的面向行的格式，并假定使用 ISO 8859-1 字符编码；即每个字节都是 Latin1 字符。对于非 Latin1 的字符和某些特殊字符，可以使用 Unicode 转义以键和元素的形式来表示它们。
		王哥说ISO 8859-1 是外国常用的字符集。像中国常用gbk。。我也纳闷为啥不都用utf8.。可能统一就容易泄露资源？文化入侵？ - -  如果是中国写的java可能就是gbk了。
 - 读取配置文件的数据：用反射的形式获取输入流。
		demo05.java！
		InputStream ips =DBUtils.class.getClassLoader()    /类加载器ClassLoader()
								.getResourceAsStream("jdbc.properties");
		获取一个叫做类加载器的东西，加载类文件通过流(Stream)的方式获取(get)资源(resource)返回一个输入流
		文档：getResourceAsStream(xxx)是类加载器的方法，返回读取指定资源的输入流。

9. 执行sql语句太长的话，为了代码方便而折行。
字符串折行需要注意，折行后不方便看字符串的空格，尽量在空格可加可不加的位置折行，比如紧挨()括号外的位置

10. Demo01：.close() 关闭资源，连接对象、执行对象都需要关。
直接关连接对象其他的也能够关上。

11. Demo01代码只能执行一次，因为执行一次后SQL语句创建的table就已经存在了。
可以在SQL语句中加if not exists 解决。    /这个可以在命令行那里用吗

12. Demo02 @test-单元测试  这是专门进行测试用的  (需要add一个叫JUnit 4 的东西,感觉是jar包吧)
写在方法的上边，这个方法就变成可执行的了，就类似于main方法。
一个类中只能有一个main方法，但是用单元测试可以写多个。这是专门进行测试用的
执行方法：鼠标点击方法名(让光标在方法名上)，左边有蓝色的条表示这个方法已经被选中。
		在方法名上右击Run As执行单元测试方法。如果没有在方法名上点则整个类所有的单元测试方法都会执行。
单元测试的好处就是一个类中可以有多个方法可以测试执行。

13. execute() 课堂笔记中有
execute()方法的返回值为布尔值,返回值表示是否有结果集。
只有查询的SQL语句才会返回结果集。查询的结果会放到一个结果集对象当中。但是这个返回值一般不用，因为这个方法推荐执行DDL(数据定义语言)，而DDL的语句(create drop alter truncate)都是没有返回结果的。
SQL语句执行的成功和失败看控制台的结果，代码顺利执行完则成功，报异常则失败。

14. Demo03： rs.next()  原理
rs是查询的返回值结果集 结果集是ResultSet类型		ResultSet意思就是结果集
ResultSet对象中有一个 "游标" 的概念。游标刚开始哪条数据都没指，相当于0的位置。
rs.next(): 当调用他的next()方法的时候,他会先判断有没有下一个，有下一个的话他就返回一个trun，并且把当前游标往下挪1格。
第一次执行.next()，有下一条，则把游标指向结果集里的第一条数据，这时rs.getString("ename")、get.Double("sal")则获取到第一条数据的ename和sal字段的内容。然后执行System.out.println(xxx)输出
之后while循环再次执行到rs.next()，往复判断执行，依次类推。直到rs.next判断没有下一个，返回false，while循环条件不成立，则while循环执行完，走下面的代码。

记住只要见到ResultSet，就是while循环遍历。固定的这种写法，没有别的写法。
(我试了一下，如果只有一个数据，也可以不循环，其实都是一个道理，就是用.next()控游标，如果不写循环，就得每次要查下一个数据的时候都得写代码xx.next()移动一次游标。文档说：最初，光标被置于第一行之前)

文档：接口 ResultSet表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。
ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。

15. DBUtils：数据库的工具类。封装增删改查重复的代码--封装连接代码。
虽然 得到SQL执行对象 也有点一样的代码，但连接了不一定就执行吧。。反正连接和执行是不同的功能。

18. 起变量名的时候，如果就像起一个和对象一样或很像的名：用alt+/ 变量名
	例如：BasicDataSource 后跟b 按alt+/ 会出来basicDataSource 等
	后跟d 按alt+/ 会出来dataSource  basicDataSource  等等


#----------------------------------MySQL.day08_JDBC02-----------------------------------


##自定义模板代码的操作
 - window-->preferences-->Java-->Editor-->Templates: new
		Name是召唤代码的代号
		Description是对代码的介绍/解释
		pattern是对应的代码
		Insert Variaable...cursor:代码出现后光标的位置。先将光标放在pattern里想要出现在的位置,然后双击cursor
 - 快捷键：Alt+/
 - 常用的代码就可以用这种方式定义成模板代码


##修改快捷键的操作：
 - 导包的快捷键 Ctrl+Shift+O(字母)  linux可能有冲突
 - window-->preferences-->搜keys-->搜import：找到In Windows：在Binding列修改 比如Ctrl+Shift+I


##sql注入风险
 - 使用Statement创建SQL执行对象：若sql语句中需要拼接用户输入的变量时才存在sql注入风险
 - 解决方法：
	不用 Statement ，Statement是在执行(ResultSet rs = stat.executeQuery(sql);)的时候才拿到sql语句，即在执行到语句的时候编译。
	用PreparedStatement：写sql语句的时候先用占位符 ? 把位置占好，**用?代替变量**  然后用 预编译的SQL执行对象 PreparedStatement；预编译在执行创建预编译的SQL执行对象 PreparedStatement stat = conn.prepareStatement(sql);的时候就已经把sql语句的逻辑给固定，固定之后再添加往里边添加内容的时候只能以值的形式往里面添加。这时语句的逻辑就已经不会再受改变了。在执行到创建对象的时候就编译了！
 - **原理**，学完成恒讲的#{}/${}知道了，语句的逻辑固定就是说**问号的地方只能写值**。而不能写语句。
 - .setString(1, username); - 设置的类型(替换的位置,替换的内容); 替换的位置就是要替换的?的位置
###SQL注入风险的原理
 - 例如：select count(*) from jdbcuser where username='libai' and password='123';
	username和password应当是用户输入的变量
			(sql注入风险：本来变量这里是让写一个值，但是你写进去的是一段sql语句。影响了sql语句原有的逻辑)
	若密码中输入 ' or '1'='1 则sql语句变成了:
	select count(*) from jdbcuser  where username='sdfsdf' and password='' or '1'='1'
	影响了语句的逻辑。而 '1'='1' 是衡等的
		(在命令行的话任何衡等都行,不必须是字符串衡等, 1=1、2=2、or true 也行 但这里代码已经是password='' 在 ' ' 中间插密码，密码就已经规定了是字符串。所以是用两个字符串衡等)
	衡等的话where后边的条件就和没加一样 相当于` select count(*) from jdbcuser;`而Demo中判断条件是利用查询的`count(*)>0`,这时如果表中有用户，那count(*)>0 成立，从而绕过认证登录成功。
 - 老师说sql注入风险很容易解决，十年前还可以钻这个漏洞，现在基本不存在。
####我认为：
 - 单在登录的时候，可以让判断条件为`count(*)==1`,表在创建的时候随便插入两条数据。这样后边再用sql注入的话，count(*)就是>1的，一定不会等于1。之所以插入两条是因为如果初始只插入一条，那也可以注入成功。
 - 而除了登录业务还有很多业务。比如说就是查询信息，返回的`count(*)`是用来显示符合where条件的个数的；或者要查询的是符合条件的信息，直接select * from xxx... 这时如果绕过了认证，那么所有的*就输出去了。
 - 除此之外还有很多，可以百度 sql注入案例 sql注入原理等深究。
###PreparedStatement解决sql注入风险的原理：
 - 内部代码通过for循环，将字符串参数通过提取每一位上的char字符进行遍历，并通过switch()...case条件语句进行判断，当出现换行符、引号、斜杠等特殊字符时，对这些特殊字符进行转义。此时再插入 ' or '1'='1 经过程序后台进行转义后，真正的sql其实变成了：...password='' or '1'='1' ,显然这样查询出的结果一定为空。


##批量操作考虑内存问题
 - Demo05 for循环插入100条语句，如果不考虑内存大小的话语句数量可以无限大
	但需要考虑内存，添加到批量操作的时候并没有执行，而是等到最后一起执行。
	如果要插入的数据量很大，那么添加导批量操作时，内存有可能不够用。

 - 解决办法：加个if判断，每隔多少句执行一次。最后在if外再执行一次的目的是避免遗漏：若一百条数据，20条执行一次那最后就没了，如果不是20的整数，那最后就避免遗漏就很重要了。


##三目连续取两次sanner
 - Demo06 判断如果输入的是0就让他等于1，要用if 见Demo06
 - 不能用 三目：int page = sc.nextInt()<=0?1:sc.nextInt() 
	老师原话：这种写法取两次值，不行，得拿个变量单独接收一下。麻烦，不如用if。
		用单独变量接收的话是这样吧：
		int page0 = sc.nextInt();
		int page = page0<=0?1:page0;
 - 原因：
	我的理解：连续取两次值时不行的，因为.nextInt()接收的是控制台我输入的下一个整数，如果判断<=0的话，那我输入<=0可以直接变成1，但我写的值不是这个范围内(>0)，那么他就会取:后的，在这里就是再接收一下控制台我输入的整数，那我还得输入个整数才可以，而且这次输入就没有判断了，会直接赋值给page，这样并没有达到需求。


##什么时候需要获取自增主键的值：
 - 现在有两个表：球员表 球队表  都是主键自增
	当我插入球员的时候要知道他球队的id，而球队的id是自增主键，他加到多少我要直接写是不知道的。
	！！！？？？只能获取自增的主键吗？


##参数：Statement.RETURN_GENERATED_KEYS用法
		返回生成的key  (自增主键)
 - 写在sql语句使用的位置后边:
		/Statement写在执行的时候 -Demo08
		stat.executeUpdate(sql,Statement.RETURN_GENERATED_KEYS);
		/PreparedStatement写在创建对象的时候 -Demo09
		PreparedStatement stat = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS); 
 - 执行都是ResultSet rs = stat.getGeneratedKeys();  然后while循环


##小项：
1. "批量操作"的意义：看课堂笔记


#------------------------------------Servlet.day01--------------------------------------
###看笔记图，看课堂笔记，看PPT
###day01工程讲Servlet；day01-lab工程是下午的日期练习


##Servlet？
###课堂笔记的问答：什么是Servlet？ 
 - 答：老师说是sun公司制订的一种用来扩展web服务器功能的组件规范。 我认为这个问答不太严谨。
		接着在解释组件规范的时候 说：Servlet就是一个符合Servlet规范的组件，需要部署到Servlet容器当中才能运行。
		所以根据回答，他这个问题更应该是：什么是Servlet规范？    他这个问题写的太广义
		Servlet规范和Servlet 两者是并存的，是紧密连接的。所以他这种问答也是站在了一个广义的维度去问答。
		而他应该要表达的意思是，我们接下来要学的就是怎么根据sun公司制订的这个Servlet规范去写Servlet。

 - Servlet 是两个单词：Server let 所以读的时候可以读成这两个单词的音，而Servlet发音没有那个er的音
		Server let： let 让... 一般翻译为服务器端小程序(老师说的)
 - 百度百科：Servlet (Servlet Applet)是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。
		狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。
 - 百科：Servlet是用Java编写的Server端程序，它与协议和平台无关。
###Servlet容器&Servlet规范的意义
 - Servlet容器(比如Tomcat雄猫)为Servlet提供运行环境(主要是提供网络相关的服务)。
	即从今天开始我们再开发一个web服务端程序不用写网络相关的代码了：范老师带我们写的WebServer：监听端口、启动线程、解析请求数据包、处理业务逻辑。从今天开始监听端口、启动线程、解析请求数据包不用我们写了，Servlet容器帮我们写。我们只需要写Servlet(业务逻辑)。
 - Servlet规范是sun公司制订的一种用来扩展web服务器功能的组件规范。
	Servlet(业务逻辑)由开发人员写，Servlet容器是专业的公司组织来写的。如何保证两种代码结合在一起并且不出问题：这就需要有一个统一的规范：Servlet规范    我们按照这一规范写Servlet后，可以部署到任何一个Servlet容器里，不只有Tomcat。
###Web服务器 Servlet容器 Tomcat
 - Servlet是一种用来扩展web服务器功能的组件，需要部署到Servlet容器当中才能运行。
 - Servlet容器装入Web服务器并在Web服务器内执行，需要计算的业务web server会转交给Servlet执行业务逻辑，而Servlet容器给他提供运行环境。
 - **常识: 现在市面上看到的几乎所有的容器，都不是一个纯粹的容器，同时它也是一个简单的web服务器。即Tomcat同时也是个简单的web服务器，即纵使没有专业的web服务器(比如apache),浏览器也可以直接向Tomcat发请求。**
 - 专业的web服务器什么时候用：如果这个web应用，用户量非常大，并发量非常大，这时如果不使用专业的服务器，直接使用Tomcat来充当web服务器，那Tomcat就崩了。这时前端就需要一个专业的web服务器来抗压。
		500个并发差不多是Tomcat的上限。以后做项目的时候可以安装专业的web服务器，做一些配置即可。我们写的sevlet代码在容器中运行，安装专业web服务器后之间不会有影响。
 - 如果开发的web应用用户量并不大，比如公司考勤的系统，是不用安装专业的web服务器的，直接使用Tomcat即可。
 - 百科：Tomcat服务器是一个免费的开源的web应用服务器。
 - 回头可以深究Web服务器，应用服务器，Http服务器等。反正Tomcat是web服务器。CSDN有收藏。
 - **servlet容器的不同叫法**：servlet容器，web容器，有的也直接叫容器


##step3. 打包规范
		Servlet离不开容器，需要部署到容器中。部署的话就要先变成一个组件，也就是说要按照规范创建一个文件夹
``	建立一个具有如下结构的目录结构
		appname (应用名，自定义)		/工程名字，web应用名
			WEB-INF 	/WEB-INF是固定的，只能这样写
				classes (放.class文件)
				lib (放.jar文件,可选)	/没有使用jar包可以不要
				web.xml(部署描述文件,servlet3.0以上的版本可以不要)	/课上讲的是目前最流行的servlet2.5版本


##Tomcat 
###下载Tomcat
 - www.apache.org 阿帕奇官网-->下方APACHE PROJECT LIST-->Tomcat
		或直接进tomcat.apache.org	
 - Tomcat是java写的 不用安装，解压即可。因为java的程序只依赖jdk，不依赖OS。配置java变量他运行的时候就能找到java虚拟机。
 - 安装后与eclipse集成，可以利用eclipse管理，启动以及关闭Tomcat，向tomcat中拷贝东西。
###将Tomcat和exlipse集成的操作
 - Window-->preferences首选项-->Server服务器-->Runtime Environm运行环境-->Add添加一个Server的配置-->Apache：
		选哪一个要看安装的Tomcat版本，而可集成的Tomcat版本又和eclipse的版本有关系。老师的eclipse版本有点低，只能支持到8，如果用8以上的会有问题。最后他用了tomcat7，我们用8.5
``	-->选中 Create a new local server 创建一个新的本地的server，便于我们用eclipse管理Tomcat
``	-->next Name无所谓，名字而以-->Browse 找到Tomcat安装的目录 
		JRE:是java的运行环境，因为Tomcat是java写的，离不开java运行环境，JRE可以用他自带的,也可以自己再组建一个。不动也没关系，课上没动，显示的是Workbench default JRE
``	-->Finish-->OK 
		项目多了一个文件夹-Servers：展开有Tomcat xxx 再展开有一堆配置文件，这是Tomcat运行的一些配置，暂时不管，以后要改。
 - Window-->Show View-->Servers:控制台出现Servers，双击显示的Tomcat xxx-->Overview概述(Tomcat的一些配置)：
``	Server Locations 服务器位置，默认用的Use workspace metadata 改成 Use Tomcat installation
		Use workspace metadata：用的是系统自带的Tomcat
				eclipse有自带的tomcat，估计是版本很低的tomcat
		Use Tomcat installation：用的是我们安装的Tomcat
				Deploy path：部署文件的位置，不用改，可以改，搜索'Deploy path'看后边提到的。
				我试了当生成部署文件后，Server Locations 下的设置就不能改了，老师说需要删了重配(这是eclipse一个不友好的地方，但是这个一般设置好了也不需要改。)。
``	Publishing发布  默认Automatically publish...自动发布 改成Never publish autopmatically
		自动发布是当源代码一发生改变自动帮你部署，我们手动部署，因为自动部署一些细节一概而过我们看不到，我们手动部署，便于说明细节
``	然后保存
 - 验证：启动Tomcat。Window-->Show View-->Servers:控制台出现Servers 右击Start：Console终端有输出：红色的是Tomcat启动时的日志，报告启动情况。最下面 Server startup in xxx ms 启动毫秒 基本就没问题了。可看到默认监听的端口号是8080，可以打开浏览器请求 ：http://localhost:8080   正常情况下看到一只猫。。。


##创建Maven-Web工程的操作
 - 建立maven项目，Packaging打包的方式必须为war   Version:SNAPSHOT快照 开发一般用这个
 - 建完工程后，工程包报错：因为按照我们的规范，Servlet规范有一个部署描述文件，但是这个没有，展开可以看见src-main-webapp：下面缺web.xml部署描述文件
		(视图一定要用Project Explorer项目视图 不能用Packages视图。一直用的就是Project Exporer啊，之前没听说过Pachages视图。改的话是在Window-->Show View-->Project Explorer)
 - 右击工程下的Deployment Descriptor 部署描述:xxx -> 瓶子 Generate Deployment Descriptor Stub 生成部署描述文件web.xml 也创建了目录    (默认没有描述文件所以要加进来)
 - 右击工程Properties-->Targeted Runtimes 目标运行环境-->选中Tomcat
		目的：指定运行环境，开发的时候会用到Tomcat带的Servlet的API
		百度：普通的java项目，运行在java runtime(java运行环境)上


##形参&实参
 - 形参是定义方法的时候，该方法所携带的参数
		比如 public void printlnfo(String info	){...}    此处info就是一个形参，它是String类型的
 - 实参是在调用方法的时候，给这个方法传递的参数值
		比如调用上述方法，xx.printlnfo("hello");    此处的"hello" 就是一个实参
		实现方法调用的时候，系统会把实参"hello"的值赋予形参info变量，即info就指向了"hello"，调用这个方法后，就会在屏幕上打印出hello
###main方法里的String[] args
 - 是程序运行时传递给main方法的参数，可以是0个或1个以上的字符串，所以以数组的形式传递。无论是在DOS环境下还是Eclipse中，都可以给程序传递参数。
		这种用法很少。
		百度："Java中main方法参数String[ ] args"
		CSDN收藏"main方法中的String[]args到底是什么"(提到了一个需求：运行该软件的时候必须提供用户名和密码)


##实际开发中需要写的东西：java类&web.xml
		其他的都可以用开发工具帮我们做
###写一个servlet的java类的细节-HelloServlet.java
 - 右键Soure-->Override/Implement...重写父类的一个方法-->service（Http...,Http...)-->OK 原因以后讲
		servlet.png:web server 处理静态的请求，如果需要计算，会转交给servlet容器来处理，容器调用Servlet，调用的就是重写的这个service方法。
 - 修改形参arg0-->request请求;arg1-->response响应 这样代码的可读性会好一点。将自带的注释和super.service(arg0,arg1);删除，没用
 - 加构造器便于查看细节，跟踪Servlet的运行过程。开发的时候不用加。
		Servlet容器收到请求之后，会先通过构造器创建Servlet对象。则执行了构造方法。
**这个类里面我们并没有写任何和网络相关的代码，但是实际上它就是一个网络应用程序，我们可以通过浏览器来调用。	之所以它是一个网络应用程序，是因为容器帮我们做了很多工作，比如解析请求数据包、创建响应数据包**
###部署描述文件web.xml的介绍和编写
 - src-->main-->webapp-->WEB-INF-->web.xml
 - 第一行为xml声明：版本、编码，跟传奇学过xml
 - 根源素<web-app> 标签内的属性和属性值(如下)，对于开发人员来讲：理解成一个约束条件：我们往里面填哪些元素，填哪些属性，可以写什么东西，都要遵循一个约束条件。
		<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5">
		最后以.xsd结尾，这其实是一个文档。我们要填什么东西怎么填，要遵循这个文档的要求。version是"Servlet规范"的版本(最新到达3.0、3.1了，把开发进一步简化了，但原理是一样的)
		xsd是指XML结构定义(XML Schemas Definition); XML Schemas Definition也叫SML Schema 中文名：可扩展标记语言架构。一份XML schema文件描述了可扩展标记语言文档的结构。作用是定义一份XML文档的合法组件群，就像文档类型定义(外语缩写: DTD)的作用一样。--深究可百度
 - 今天先把<web-app>里的东西删了只保留根源素。以后讲
 - 在根源素下添加元素如下：
		两个子元素，每个子元素下又有两个子元素
		<servlet>
			<servlet-name>名字，给开发的这个servlet命名，自定义，没要求</servlet-name>
			<servlet-class>写完整的类名：包名.类名</servlet-class>
							写完整的类名，servlet容器会利用java反射机制加载servlet，然后调用servlet的构造器，创建servlet对象。
		</servlet>
		<servlet-mapping>
				<servlet-name>和上边的那个name一样</servlet-name>
				<url-pattern>值必须以/开头+随便写个字符串</url-pattern>
							url-pattern是告诉容器，该servlet处理哪些请求
		</servlet-mapping>
 - 如果url-pattern不加/部署后会弹出一个错误：启动Tomcat出问题了，启动失败，详情里也没说是什么错误。这时看控制台，因为Tomcat也是个java程序，运行离不开java虚拟机，那我们可以看控制台虚拟机报什么错：找能看懂的。
		比如url-pattern里写的是<url-pattern>/date</url-pattern>会看到： java.lang.IllegalArgumentException: Invalid <url-pattern> [date] in servlet mapping 非法的参数异常：无效的<url-pattern> [date]


##部署运行&查看部署文件的操作
		即拷贝，不需要手动拷贝。所谓部署就是eclipse帮我们在tomcat上建一个规范的目录结构。
 - 右击工程-->Run As 怎么运行-->Run on Server 在服务器上运行-->选择容器：
		选择刚安装集成的Tomcat容器，以后在企业里可能会安装好几个容器，都可以用来测一测。解释：在公司里用的服务器和企业的用的可能会不同，比如我们有个团队在为达内开发一个web应用，现在要用Tomcat做测试，但是达内有钱，他用的时候说Tomcat功能太弱，要买一个IBM的容器，这时我们的代码一般不用做任何的修改。所以有些时候我们可能会安装好几个容器，都测一测，谨慎一些。
``	-->next	(直接点Finish也可以，next可以看到过程)
		右边的小瓶子day01，表示已经部署的应用，即day01已经拷贝到容器中去(eclipse帮我们拷的)。小瓶子表示应用。
``	-->Finish-->Restart server-->OK
		此时往往会弹出一个提示，让我们重启服务器(Tomcat)。之前Tomcat与eclipse集成后启动验证过。没有也正常，没有是因为之前没有启动。
 - 部署运行后显示的404页面并不是错误，而是因为地址(url)不完整，缺少url-pattern
 - 看eclipse帮我们做了什么：找到Tomcat目录文件-->wtpwebapps 这是刚刚利用eclipse帮我们部署的时候，eclipes把step3打包的文件拷到了wtpwebapps里面，
		wtpwebapps-部署文件的名字和位置并不是固定的，可以改：Window-->Show View-->Servers:双击Tomcat
		Server Locations 服务器位置 Deploy path 部署路径	查看笔记'Deploy path'
 - 若没有部署请求的应用或部署失败，则请求时会报404错误。部署失败一般不会发生，偶尔发生。解决办法为多部署几次。


##servlet02.png图解-Servlet是如何运行的。
 - 现在市面上看到的几乎所有的容器，都不是一个纯粹的容器，同时它也是一个简单的web服务器。即Tomcat同时也是个简单的web服务器，即纵使没有专业的web服务器(比如apache),浏览器也可以直接向Tomcat发请求。所以比servlet01.png少了个中间的Webserver。
``1 通信模块
``如果看浏览器的源代码就会知道，浏览器中有一个通信模块
		浏览器是用C写的比较多。我们用java写聊天室客户端的时候写过 Socket s = new Socket(ip,port) 这样的代码，使客户端和服务端通过ip和port建立了一个连接。浏览器里也有类似这样的代码，我们把这样的模块称作通信模块。
``服务器端也有个对应的通信模块
		Tomcat中有类似于下面聊天室服务端的代码：
			while(true){		//不断循环
						Socket s = ss.accept..	//监听端口
						new WorkThread(s).start	//一旦来了请求启动一个线程去处理这个请求
					}
``3&12 红底红框块是数据包
``6 容器可以依据请求路径，判断应该创建哪个servlet对象。创建Servlet对象并调用其中的service方法
		容器根据day01/hello   day01表示要访问的应用，/hello表示请求的sevlet。
		我们写的web.xml中 url-pattern是告诉容器，该servlet用来处理哪些请求。就是在这里起作用的。
			容器收到请求后，从<servlet-mapping>中的<url-pattern>知道，/hello是由<servlet-name>：helloServlet处理，再去<servlet>中找到上下对应的<servlet-name>helloServlet，再找到与此对应的<servlet-class>：java类web.HelloServlet。此时容器会利用反射机制创建<servlet-calss>中指定的java类对象。
		则创建HelloServlet对象
 - 真正需要我们写代码的就是第8、9步。其余的都是容器帮我们处理了。
		容器帮我们处理了和网络相关的问题，我们只需要关注业务逻辑


##@Override 重写标记
		写一个servlet的java类，右键Soure-->Override/Implement...重写父类的一个方法-->service 上边有记录
 - 继承了某个类后，利用eclipse重写父类的方法，会在方法上自动添加 @Override  表示这是一个重写的方法。
 - 若取消了继承，则方法会报错。解决报错：将 @Override 注掉。


##小项
1. sun公司被oracle公司收购
2. Servlet组件   tomcat容器
		宝马车(容器)用的米其林轮胎(组件)。
3. 因为CGI是用perl，c/c++写的  开发繁琐、并且不好移值，所以用得少了。
4. ".war" war包  我们servlet开发最终的成果就是这样一个压缩文件-war包
5. 	apache服务器，全称：apache http server ；apache开发的web服务器，因为太出名所以直接被简称apache服务器
6. nginx：web服务器，俄罗斯的一个小伙子写的，现在非常之流行，可能在毕业的时候会讲一下
7. 写一个Servlet的五个步骤，不管用哪个开发工具都离不开它，只不过有的开发工具帮你做的多点，有的帮你做的少点。即有的你看不到，有的你能看到。
8. 浏览器一般是c写的比较多
9. Tomcat的bin目录下有shutdown.sh和startup.sh 后缀.sh是linux里的可执行文件，有时Tomcat频繁启动会报错，可以点几次shutdown.sh关闭。 -王哥说的
10. 人工智能是一个非常非常大的HashMap，它可以用大数据去找近似近似的答案
11. 表单就是向服务器提交数据的 
12. 静态页面在webapp文件夹下创建	/静态页面
		表单action的值写的和<url-pattern>的值去掉斜杠一样，后边仔细讲
13. 文本输入框、密码输入框如果不填写任何数据，会获得""空字符串，所以要加判断
	对于多选框，如果用户没有选择任何选项，会获得null值。数组取值有空指针异常，所以要加判断
14. html5比较宽松，在写单个标签的时候，比如<br> <input ...> 可以写成<br/><input .../> 效果都一样
15. 在工程名右击运行的好处是。在代码区域右击运行的缺点是：在代码区域右击运行后eclipse会自动访问当前代码区域，会影响一些比如要求记次数、查看第一次访问的操作，不便于演示。而工程名运行访问的是工程名路径，访问不到东西，不会影响测试。内部浏览器也没有设置可以看，不如客户端浏览器功能强大。


#------------------------------------Servlet.day02--------------------------------------
###上午用day01工程讲Http；下午前半节课建day02-lab工程讲昨天的作业并利用上午知识进行拓展。然后建day02工程'用户管理'实现浏览器访问数据库


##部署应用后不生成字节码文件的问题
 - 个别同学出现了这样的问题
		正常情况下在Tomcat/wtpwebapps/day01(应用名appname)/WEB-INF/classes/web/有.class文件
 - 这是eclipse的一个老毛病，处理方法就是多试一试几种办法：
		- Project：Build Automatically 自动编译 看有没有勾选勾选
		- Project：Clean...清理  作用是把字节码文件全删了，然后重新编译一次,再部署。一般这个方法就能解决。
		- Servers：右键Tomcat：Add and Remove 可以先把右边的应用Remove到左边，然后再Add到右边，Finish，再右击Tomcat：Publish重新发布，最后右击Tomcat：Start启动服务器
		- 重启eclipse
		- 工程右击-->Properties-->Java Compiler:JDK版本来回换一换


##抓包工具：TCP/IP Monitor 监视器的使用操作
		抓取浏览器和服务器之间传递的数据包。这个工具不要求必须掌握，且可能有的同学不能用，和eclipse有关系。
 - window-->Show View-->Other-->Debug-->TCP/IP Monitor监视器-->Open
		抓包工具存在浏览器和服务器之间，浏览器发送的请求数据包和服务器的响应数据包(即数据传输)都会被监听。
		因为http协议数据包最终要通过TCP/IP协议来传递，所以通过这个来取。
 - 控制台出现 TCP/IP Monitor 标签-->空白框右击-->Properties-->Add 添加(告诉它监听谁)
		Local monitoring port:这个工具的监听端口。只要没被占用的端口就行(如8888)
			这个工具其实也是个服务器，需要分配一个端口来监听。
		Host name：localhost  Port 8080     监听对象，目标本机服务器Tomcat
		其他的不动(Type:HTTP Timeout:0 Start monitor..没勾选)
			浏览器和服务器在传递数据时先通过8888端口，然后8888端口监听并转接到Tomcat8080端口
 - OK-->Start-->运行工程-->浏览器访问http://localhost:8888/day01/hello?number=1&city=wh&city=cs
 - 控制台--> TCP/IP Monitor:
		左上角localhost:8888下 选刚刚发过来的那个请求。
 - 右上角倒三角-->Show Header:
		看浏览器把哪些数据发给了服务器：
###Show Header 查看数据包的结构
		介绍数据包的结构(课堂笔记以及webserver11的readme结合理解)
 - 左边Request两个框是请求数据包的内容
``	1.Size:请求行+消息头	(有些人喜欢把这两样统称为请求头或数据包的头)
``		- 请求行：
			GET /day01/hello?number=1&city=wh&city=cs HTTP/1.1
			请求方式   请求资源路径                            请求使用的协议和版本
			回顾webserver_v11的readme:GET请求：地址栏形式提交数据用户输入的数据会被拼接到请求的抽象路径中，以"?"分隔，左侧为请其的抽象路径部分，右侧为用户传递的若干参数。每个参数以"&"分隔。
``		- 消息头：看课堂笔记
``	2.Encoding：实体内容(消息正文)
		get请求的实体内容是空的。post请求会将请求参数放到实体内容里面。
 - 右边Response两个框是响应数据包的内容
``	1.Size：状态行+消息头
``		- 状态行：
			HTTP/1.1 200 OK
			协议/版本　状态码　状态描述
``		- 消息头：
			Content-Type: text/html;charset=ISO-8859-1
			告诉浏览器，服务器返回的数据类型和编码。是用分号;隔开的
``	2.Encoding：实体内容(消息正文)  看课堂笔记


##传输字符乱码问题
 - 只要不是iso-8859-1码字符就会乱码。
		以传输中文为例。
###Servlet输出中文的乱码
		向浏览器传输中文
 - 原因：因为out.println方法在输出时，默认使用"iso-8859-1"来编码。
 - 解决方法：在respoonse.setContentType()中添加charset=utf-8 分号隔开
		即写为response.setContentType("text/html;charset=utf-8");
###表单包含有中文参数值的乱码
		向服务器传输中文
		test.java中有对浏览器和服务器的编解码方式进行模拟和验证
 - 原因：当提交表单的时候，浏览器会检查参数值，如果不是ascii码字符，就会进行编码。浏览器会按照打开该表单所在的页面时的字符集来进行编码。
		浏览器向服务器发请求，服务器返回一个html文档。浏览器收到之后，看到html文档<head>里的<meta charset="UTF-8">,知道html文档中的所有字符，应当用UTF-8进行解码。当我们提交表单的时候，浏览器也会按UTF-8进行编码。
``		服务器默认用ISO-8859-1解码
 - 解决方法
		看课堂笔记
``		post请求：request.setCharacterEncoding(String charset);
		添加到所有的request.getParameter方法的最前面。前面不能有任何的getParameter方法，只要有就会乱码。字符集参数要和客户端的编码字符集一样。即和表单html中<head>_charset规定的一样。
``		get请求：Servers项目_Tomcat..._server.xml,<Connector>标签中添加 URIEncoding="utf-8"。
		用来告诉Tomcat，如果发的是get请求，用utf-8解码。tomcat8.0以上的版本，包括8.0，默认会使用utf-8来解码，加了也不受影响。估计是收到来自中国市场的压力，为适合中国消费者，最近他的版本编解码慢慢向于utf8靠拢。
		在这个标签中还可以修改端口号，如果Tomcat端口号8080被占用，则可以通过这个配置文件去修改端口号。


##设计师&架构师对Java语言异常处理的思路
		AddUserServlet.java导入数据库的异常处理
		& DEUtils.java()中添加的close方法中的异常处理
 - 首先try catch 捕获异常
 - step1.记日志(将异常信息记录下来)。在实际应用当中，一般会记录到文件里面
		日志的记录在企业里一般都有写好的模块，甚至有专门的架构师每天只记日志
		也可通过控制台输出，但在企业中不合适。因为服务器一关就看不到了，不便于以后查究找错。
 - step2.看异常能否恢复，如果不能够恢复，需要提示用户稍后重试。
		不能够恢复的异常：比如因为各种原因，使数据库服务停止、网络中断等，一般将这种异常称之为系统异常。
		我们有时上网会遇到 系统繁忙，请稍后重试 这种很有可能是程序运行的时候遇到了数据库问题、网络问题等。
		Connection conn = DBUtils.getConn() 拿不到连接是典型的系统异常。因为以后既然都上线运行了，突然异常肯定不是代码的问题。
 - 企业中异常具体怎么处理，架构师会事先把接口类写好，照着写即可。不同架构师代码可能不一样，但思想都一样
###在DBUtils中添加close()方法
 - 用于关闭结果集，关闭连接对象，关闭Statement执行对象。
		国斌老师讲的时候说关了连接对象，执行对象就一块被关了，关闭结果集他倒是没提。
 - rs.close()有异常需要处理，处理之后，在catch中抛出(即关不上就抛出，因为这是底层的类，不用它自己处理，谁调用谁处理)。但是传奇老师说过关流这东西一次关不上次次关不上，所以这里处理一下再抛出有啥意义呢：程祖红老师说，如果不想记日志可以直接抛出。
	**于是恍然大悟：用try-catch语句可以起到记日志的作用，因为catch有e.printStackTrace();输出异常信息！如果要把异常日志记到文件中也得在catch中做啊，总之一定要用try-catch捕获异常嘛！**
 - stat.close()和conn.close()写try-catch也是为了记日志才不直接抛出。
 - 所以：**想记日志就try-catch**


##小项
1. 写一个Sevlet不依赖于某个特定的容器，按照规范写即可。
2. 常见的Servlet容器：(免费)Tomcat Jboss Jetty Resin (收费)weblogic ...
3. javac命令：编译Java程序     →.class字节码文件（.Java文件编译成.class文件）
   Java命令：  运行Java程序     →结果（运行结果）
		一个程序员可能不用它，但要知道它
4. 聊天室和webserver用过Socket。Socket完整的称呼叫做Tcp/ip Socket
5. IP地址是IP协议定义的。IP协议为互联网的每一台机器分配地址。
6. 提到了一本书 TCP/IP
7. http.png：图解浏览器和web服务器之间是怎么通信的。
	一次请求，一次连接的优点：节省资源：web服务器可以利用有限的连接为尽可能多的请求服务。
		缺点过几天说，比如买东西不断地选商品，服务器要不停地识别这个请求到底来自于哪个用户，这时会出问题。
8. HTTP 0.9 第一版 1991年发布。现在最新的2.0版，但是还没怎么用，2.0是多次请求一次连接。目前浏览器主流是1.1版本，已经用了20年了。
9. MIME类型  是一种规范    webserver_v10提到过
10. 其实不止有get和post请求。Http协议一共有七种请求类型(put、delete等)。但浏览器只支持这两种。
	如果要处理其他的请求，要用到额外的技术：比如ajax技术
		七种请求可以在右击重写service时看到，service上面七个do方法，跟着的就是请求--学完'就绪'来补充
11. post请求会将请求参数放到实体内容里面，可以提交大量的数据给服务器。理论上没限制，但实际编程中我们要限制，会影响网络传输
12. post请求只能说相对安全，因为http协议本身是不对数据加密的，比如我们抓包工具能看见。
		敏感数据要加密处理：用https协议。用https协议需要对服务器做一些配置，而且要申请专门的数字证书，难倒不难，但是比较麻烦。用这个协议会发现王速变慢了。因为加密要花时间
13. <fieldset><fieldset>标签是html5中新出的，可以将表单内的相关元素分组，会在相关表单元素周围绘制边框。美观
	<legend></legend>标签为<fieldset>元素定义标题。
14. BmiServlet.java最后out.close()方法可以不调用。因为servlet容器再执行完service方法之后，会自动调用该方法。
		参看day01_HelloServlet.java 这里直接.println，没用out参数接收。
15. web.xml里删的那几个标签，以后讲是干什么的，删不删也不影响我们，但是看着比较罗嗦。
16. day02_test.java中用到URLDecoder.decode()和URLEncoder.encode()方法。
		抛出不支持的编码异常UnsupportedEncodingException，当JDK不支持指定编码时会报这个异常。比如乱写个utf-9
17. 查看servlet的maven工程有没有导包：工程-->Java Resources-->Libraries-->Maven Dependencies
18. 在sql语句字符串中把sql语句的关键字大写，便于看代码结构。


#------------------------------------Servlet.day03--------------------------------------
###day03工程迭代day02工程，使用DAO；练习应该写在day03-lab工程中，我没写，并把这个工程删了。


##修改工程应用名的操作(复制的工程如果直接部署会报错)
 - 缺省情况下，我们建一个工程的时候，eclipse会把应用名和工程名设置成一样
 - 右击复制完的工程-->Properties-->Validation-->Web Project Settings  Web工程设置:
		Context root: dayxx  这就是应用名，是真正的应用名。就是部署的时候eclipse帮我们拷贝到容器(Tomcat)的文件夹的那个应用名的名。复制的工程应用名还是复制之前的应用名。
 - OK-->OK
 - 如果不改，部署的话会弹错，详情意思是：已经存在这个目录。
###若修改了应用名之后还弹相同的错
 - 经实验：原因是在修改应用名之前部署过，虽然部署失败，而且查看了一下部署的目录(Tomcat下的wtpwebapps中)也不存在此应用，但是eclipse已经有了记录，产生了冲突。
		我是为了要查看不改的话会弹什么错，所以没改名就部署了一下，然后发现了这个问题。洋洋说他直接复制完改了名才部署还是出错，应该不会吧,但解决方法一样。
 - Servles-->Tomcat...展开箭头-->右击对应的瓶子-->Remove


##MVC：Model-View-Controller(模型-视图-控制器)
 - 我们现在写的Servlet中的代码基本分三种，要分别抽出来
		参看ListUserServlet_old.java
 - 表示逻辑out.println代码-->jsp； 数据访问逻辑jdbc代码-->DAO； 业务逻辑java代码(计算方面的代码)-->java类。
		数据访问逻辑DAO和业务逻辑都是java类
 - 抽出这三个之后，Servlet中还剩流程控制代码：Servlet负责流程控制，收到请求，可以调用java类处理，也可以调用DAO访问数据库，最后交给jsp展现。
		我们今天先抽DAO，day04-05抽jsp
 - 这叫MVC：Model-View-Controller(模型-视图-控制器)一种经典的软件架构。模型包括java类：业务逻辑和数据访问逻辑DAO； 视图：jap视图展现；控制器：Servlet。
		说以后还会讲


##DAO(扩展)
		扩展：不是这个阶段的核心知识。不属于web开发的知识，是属于jdbc的知识
``	...看课堂笔记
###DAO的优点
 - DAO封装了数据访问逻辑，调用者不用关注底层数据访问逻辑的实现，
方便代码的维护。
		一起写可读性不好。且出错后还要找是java代码出的还是jdbc出的。
 - 方便测试
		比如将jdbc代码写在servlet里面，需要部署整个应用才能测试，而将jdbc代码写在DAO类里面，可以直接测试。
		比如我们是在Test2里测试的，这样测试完以后再出错就首先排除这里的错误。
 - 方便分工协作


##生成重写toString方法的操作
 - 右击Source-Generate toString()...


##小项
1. 虽然说http是规定了浏览器与web服务器之间...，但是实际中，有可能客户端不是浏览器，而是程序。也完全可以。如果感兴趣，可以上www.apache.org   下载http-client.jar 这个jar包里边有很多api，可以很方便的写一个程序向web服务器发请求。也许以后工作能用到。
2. DAO严格来说并不是web开发的知识，是属于数据库访问的知识即属于数据jdbc的知识。
3. 如果出了一些错，实在发现不了错误，也可能是maven没有配置好。
4. 实际中数据库表中的id是不需要给用户看的，它只是为了保证主键唯一(用来表示这条数据的唯一编号)，没有任何业务含义。因为在课堂上有用所以我们才列出来。
5. 现在有新的技术MyBatis访问数据库，比jdbc方便很多。
6. 为什么我把_old的那几个类throws...改成直接throws Exception不行呢！！！？？？。回头再深究吧，应付不过来了。


#------------------------------------Servlet.day04--------------------------------------
###用day03工程讲重定向； day04工程讲jsp；day04-2工程迭代day03工程，并使用jsp


##改进昨天的代码(重定向)
 - 改进昨天的功能：昨天的代码，用户插入数据后显示添加成功的页面和一个用户列表的超链接。需要点一下用户列表超链接才能显示用户列表。现在用户需求：不想点超链接，想插入完直接显示用户列表。
``	假设方法一：可以让添加数据的Servlet在执行完插入代码后，new一个查询的Servlet去显示用户列表。
		这是不允许的，在一个Servlet中 new一个Servlet 这种代码是不允许的。因为Servlet是容器管理的，只有容器才有权力把这个类实例化，创建这个对象并调用他的方法。这是Servlet规范不允许的，如果写了不会报错，但是会出现问题：我们后面会讲容器的声明周期，如果非要这么写会丧失掉容器的很多服务，很多服务功能就用不了。
``	假设方法二：在添加数据的Servlet执行完插入代码的后面，添加查询的代码。
		不建议这么写：查询的Servlet中已经有这个代码。造成代码冗余，并且不符合设计规则：
``		**系统设计、架构有一个基本原则：一个类的职责要单一，不能做太多的事。**
###可行方法-重定向
		看课堂笔记'重定项'
 - 方法：完成插入操作后，给浏览器发送302状态码及Location消息头。
		我们只需要写这行代码response.sendRedirect(String url);容器会帮我们添加消息头生成状态码发给浏览器
		用抓包工具可以看到服务器发送的302状态码。(注意/day03/add请求，返回的是302；紧接着浏览器收到302后发/day03/list请求，返回的是200，别看错了)
 - 可以发现，返回的数据包是没有实体内容的：他只是一个通知，没有必要返回任何的数据。
		浏览器收到以后也不用解析，直接访问给定的地址。
		这就是课堂笔记写的：重定向之前，容器会清空response对象上存放的所有数据：即如果重定向代码所在的Servlet中有out.println()的代码都是白写，被清空，没任何作用。
 - 如果想让用户既看到添加成功，又跳转到用户列表。可以用JavaScript实现，和重定向无关。
		setTimeout(function(){
			location='list';
		},2000)				//服务器只需要发送这么一段js脚本给浏览器即可。应该就是响应返回out.println(添加成功+js代码)


##jsp(Java Server Page) java服务器端页面
		也是一个规范：sun公司制订的一种服务器端的动态页面技术规范。
 - 先有servlet，后有jsp。jsp的本质就是一个servlet。--看课堂笔记'什么是jsp'
 - 浏览器向容器发请求，容器收到请求后才会把jsp变成servlet。(部署完后看到的并不是我们想展现出的页面)
		如果不请求，打开jsp文件并不是我们想表达的页面。
		第一次请求浏览器明显有一些卡顿，就是因为正在把jsp转成servlet。
###查看收到请求后服务器转换成的servlet-java类
		基于我们写的hello.jsp来总结
 - tomcat目录/work/Catalina/localhost/day04/org/apache/jsp
		work：tomcat在运行当中生成的临时文件都放在work文件夹下面
		容器内部生成的文件，所以路径这么深
``			如果没有这个文件，是部署设置的问题。
				看笔记'Deploy path'。如果选择的是eclipse自带tomcat只能删了重配。因为老师说如果用eclipse的tomcat则不会在我们安装的tomcat目录下的wtpwebapps文件和work文件生成东西。我试了一下，发现确实是这样，尽管他写的部署路径的名字也是wtpwebapps，但是却找不到这个文件夹。而要是手动设置部署路径，虽然能找到能看到部署的文件，却还是找不到他的work文件夹。只能删了重新配成自己安装的那个tomcat。(个人认为，班里的linux系统不深究，家里的可能在c盘user文件下，自带的tomcat可能是在这个文件下。这里文件很大，我当时重装eclipse的时候监测过，我们安装eclipse的时候指定的路径只是eclipse程序的路径，在user下有几个他安装的时候放过去的文件夹，几百m)
 - .java文件是容器帮我们生成的,打开可看见帮我们写好的代码
		hello_jsp.java文件
``	  - 类名hello_jsp，继承了HttpJspBase类。老师说其实HttpJspBase类又继承了HttpServlet。
			所以说hello_jsp间接继承了SttpServlet，符合Servlet规范，所以说他就是一个Servlet。
``	  - 	方法void_jspService(),等价于我们写的service方法。参数是request和response，抛出的异常也一样。可以看到方法的内容。课堂笔记：'jsp是如何执行的'
``			html(css,js) ----->  在service方法里面，使用out.write输出。
				我们在.jsp中写的html(css,js)代码，在void_jspService()方法里面使用out.write输出。
``			<%     %>    ------>  照搬到service方法里面。
				我们在.jsp中写的java代码，直接挪到void_jspService()方法里面
``			<%=    %>    ------>  在service方法里面，使用out.print输出。
				我们在.jsp中写的java表达式，在void_jspService()方法里面使用out.print输出。
####out.write和out.println的区别
 - 这两个都是输出的。
 - write方法会将null转换成""输出，而println方法会输出null。
		out.write更友好一些，因为null这个值让用户看到是不合适的，看不懂会困惑怀疑。这是write的优点。
 - writer方法不能输出对象，只能对基本类型、字符串进行处理。
####out是怎么来的
		为什么我们在jsp中能直接写out.println()
 - 还是在这个.java文件中，可以看见service方法中又声明了一个变量：...JspWriter out = null;
		类型JspWriter，这是PrintWriter的一个子类，输出流。
		之后在try语句块中，给out赋值：out = pagecontext.getOut() 相当于response.getWriter();即获得了一个输出流。
 - 即容器在帮我们生成java代码的时候，把一些对象事先准备好了
		out request response 都可以直接用，直接在.jsp里写。
 - 这种准备好的对象一共有九个，看课堂笔记 '隐含对象'
		隐含对象共有九个。现在目前只需要记out、request、response。三个即可
###jsp中的指令和表达式
 - 指令：看课堂笔记'指令'
		指令：让容器生成源代码的时候，额外做一些事。
		属性之间空格隔开，同一属性的不同值用逗号隔开。也可以分开写，指令和属性可以写多次。
 - 表达式：<%= java表达式 %> 容器将等于号后边的内容放到out.println()中。
		<%= new Date()%>等价于<%out.println(new Date())%>		以后如果不想写out.print()就可以这么写。
		不能加分号，因为加了分号就相当于：<%= new Date();%>等价于<%out.print(new Date();)%>	
 - **println和print**，都是只将数据写到响应对象中。均起不到浏览器换行作用。
		要想在浏览器换行用<br>：直接在jsp中写<br>或在out.println/print(xxx+"<br>");
###jsp中写java代码的三种方式
 - 目前只学两种：java代码片断<%  java代码  %> 和 jsp表达式<%= java表达式 %>
 - 第三种年后学，用的比较少
###jsp的乱码错误问题||jsp的保存报错
		其实如果写的字符和指定或默认的编码不对，在写完代码保存的时候就会报错。
		中文为例	笔记图pageEncoding.png，不看也行
 - out.println/print("中文")  向浏览器输出出现乱码
		原因：out.println方法在输出时，默认使用"iso-8859-1"来编码。前边记过
		解决办法：contentType属性="utf-8"，设置response.setContentType方法的值。
 - 某些容器  读取.jsp文件出现乱码
		原因：容器要读取.jsp文件生成.java文件。有一些容器在读取jsp文件的时候默认用的是iso-8859-1来解码。如果文件中有中文，解码就会出现乱码。
		解决方法：pageEncoding属性="utf-8",设置jsp文件的编码。告诉容器，在读取jsp文件的内容时，使用指定的字符集来解码。
 - 以后我们只要输出中文，最好pageEncoding属性也加上，防止某些容器读取乱码。


##小项
1. jsp对大小写敏感。sun公司的一些产品和规范都很严谨，因为sun公司的前身是斯坦福大学的一些教授，典型的学院派。
		像现在python、大数据这些搞技术的，就不那么严谨，很灵活。各有各的好处
2. jsp中用java.util.*的形式导包只影响第一次加载的速度。优点是不用去记具体的类了。
3. 记的回顾：'jsp是如何执行的'
		1 转换为servlet(jsp-->servlet)  2 调用servlet(编译+实例化+调用service())


#------------------------------------Servlet.day05--------------------------------------
###用day04-2工程讲转发。day05工程迭代day04-2工程，下午最后讲include用day05工程。


##昨天写的jsp的缺点||引出转发
 - 昨天我们写的jsp(day04-2：listUser.jsp&listUsers_old.jsp)，是在jsp中调用DAO对象的方法，查询用户信息生成表格。这种写法现在已经不建议了，因为sun公司起初设计jsp规范的目的是让他处理表示逻辑，并不是什么都让jsp做。(笔记搜索'MVC')。请求应该发给Servlet，由Servlet调用java类(DAO也是java类)处理，处理完之后得到的数据再交给jsp去呈现。即jsp不需要关注数据怎么来怎么加工，只负责展现，只关注表示逻辑。
		十几年前大家写jsp就是我们昨天的写法，所有的代码都往jsp装，因为他太强大。但是时间长之后jsp越写越大，里边什么都有。很不利于修改维护。现在都不这么写了，除非项目非常小。
		这也不符合：系统设计、架构有一个基本原则：一个类的职责要单一，不能做太多的事。
 - 总之就是，不能什么都让jsp做，要分工明确，职责单一，便于维护。


##转发
		结合课堂笔记'转发'
 - 转发的概念：一个web组件将未完成的处理交给另外一个web组件继续做。
		通常是一个Servlet转发给--->Jsp，其他的也都行比如Servlet转发给Servlet。
 - 图解forward.png：竖条长窄框表示'容器'这两个字。大的是容器。
		即箭头指向长框的就是xxx发送/通知容器，箭头指出的就是容器创建/调用xxx。
###三个步骤解释
``	1. 将数据绑定到request对象上。
``			request.setAttribute(String name,Object obj);
			绑定名name写什么都可以，只要保证set和get的时候一样就行，目的是依据绑定名获取绑定值。
``	  -	转发的底层实现(源码)是一个HashMap：map.put(name,obj);以name为key，以obj作为value,绑定在HashMap中
			对应的get方法：Object request.getAttribute(String name);	依据绑定名，获得绑定值。
				注意get的时候需要强转，因为传进去的是Object类型
			因为时map.out，所以是可以绑定多个
``	2. 获得转发器。
``			RequestDispatcher rd = request.getRequestDispatcher(String uri);	参数是转发的地址
``	  -	转发的本质就是一个web组件通知容器去调用另外一个web组件，Servlet通过媒介RequestDispatcher(转发器)通知容器调用jsp。
``	3. 转发
``			rd.forward(request,response); 		forward：转发
``	  -	参数是service方法的两个参数，此时request对象就携带了绑定的数据，转发器就可以通过请求对象拿到绑定的数据。即servlet收到请求后，只把数据放进请求对象后便不再做处理，而是将请求对象和响应对象都传给转发器转发出去处理。


##URI、URL和URN的区分
		URL和URN是URI的子集，URL和URN有交集   看百度百科
		我这里只浅显了解，还不懂，有时间再百度
 - URI=Uniform/Universal Resource Identifier 统一资源标志符
		是一个用于 '标识某一互联网资源' 名称的字符串。是一种字符串文本标准。
		表示web上每一种可用的资源，如HTML文档，图像，视频，程序等都由一个URI进行定位。
 - URL=Uniform/Universal Resource Locator 统一资源定位符
		是URI的一种，它 '标识一个互联网资源' 。他是URI的一个子集，不仅唯一标识资源，而且还提供了定位该资源的信息。
 - URN=Uniform/Universal Resource Name 统一资源名称
		百度百科'URN'：是URI两种形式之一。唯一标识一个实体的标识符，但是不能给出实体的位置。系统可以现在本地寻找一个实体，在它试着在web上找到该实体之前，它也允许web位置改变，然而这个实体却还是能够被找到。
		百度百科'URI'：URL的一种更新形式，URN不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需要假以时日，因为它需要更精密软件的支持。


##servlet&javax-文档&源码
###eclipse打开servlet源码报错
 - IDE中没有servlet的源码，servlet的源码在tomcat/lin目录下，导入此目录的servlet-api.jar包
###servlet的API文档
 - javax.servlet是j2ee的部分，需要在j2ee文档看。核心文档里没有。
		j2ee的中文版文档好像不怎么样，因为翻译的人不一定懂j2ee，可以下个中文和英文一块看。
###javax拓展包
 - 百度百科： java和javax都是Java的API(Application Programming Interface)包，java是核心包，javax的x是extendion的意思，也就是拓展包
		java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit)和swing
 - 成恒：javax表示的是服务端的包

##关闭&启动数据库的操作
		模拟数据库关闭，测试 异常的转发 error.jsp 我们没试，老师试的
 - 右击计算机-->管理-->服务和应用程序-->服务：MySQL右击停止
 - 同样的，右击启动。启动后要重启tomcat(容器)。
		这和我们DBUtils的实现有关系，连接数据库是在静态块里中完成的，只执行一次，要重启重新获取连接。


##访问不合理的几种情况分析
		原因无非就是和每个类、每个jsp的实现有关。道理差不多，分析一下代码就知道了。下边就是举两个例子。
 - 直接访问listUsers.jsp：报500错误空指针异常。因为ListUserServlet.java类没有运行，jsp中获取转发过来的request的绑定值为null。
		'应当访问list'，然后容器去运行ListUserServlet.java类，类中把数据绑定到request对象后再转发给listUsers.jsp
 - 直接访问add：容器收到后运行AddUserServlet.java类，类中把请求参数添加到数据库，并立即重定向到用户列表。但是这时候请求参数它解析到的都是null，所以直接访问add会直接添加一个除了id均为null的用户并显示用户列表。
		'应当访问addUser.jsp'
 - 直接访问login：容器收到后运行AddUserServlet.java类，但是并没有请求参数和请求参数值。usrname和pwd是null。	将null传作为参数传递，执行的是find(null)方法：
``		sql语句为SELECT * FROM t_user WHERE username=null 我们学数据库的时候学过，如果用等号判断null，则查询的结果是Empty set (0.00 sec);	则find()方法返回的user=null，之后在service中判断则会转发给login.jsp并显示用户名或密码错误。
		'应当访问login.jsp'，输入用户名和密码之后让AddUserServlet.java去判断返回用户列表还是用户名或密码错误。
		延伸：如果是按照条件为null查询，我们学的正确的语句应该是SELECT * FROM t_user WHERE username is null，假设我们这么去查找，则如果存在usrename为null的信息，则返回的user不是null，返回的这条user数据有id(因为id主键不能为null)，但username为null。此时service方法判断的时候又有两种情况：
				1.如果数据库对应的密码不是null，(我们直接访问login得不到参数，即pwd=null)则判断user.getPwd().equals(pwd)即 密码.equals(null),判断不成功，走else登录失败，显示用户名或密码错误。
				2.如果数据库对应的密码也为null，则判断user.getPwd().equals(pwd)即null.equals(null),此时会报空指针异常。查看笔记'null.equals()'。
				注意：用户名若为null，则用户名的唯一约束不起作用，可以有多个用户名为null的数据，不过我们find()用的是if取数据，没用循环，只能得到第一条。


##include包含指令
 - include包含： 便于代码简化、复用和维护。看课堂笔记'include'
		list、login、add页面都有相同的header和footer标签
 - 被包含的文件并没有被真正执行，只负责提供内容。
		可以看work文件中，并没有生成被包含文件的.java文件(或者说servlet文件)
 - 被包含的文件可以是'任何的'文件，比如包含一个html文件
###引入多个相同的文件时
 - 比如我们的header.jsp 不能同时引入多个。原因是这个jsp内有new对象的操作，如果引入多个，则产生变量重复。没想到解决的办法。


##小项
1. 课堂笔记错误单词(已修改)：如何转发_step1：xx.setAtribute()-->xx.setAttribute()
2. 获得转发器：request.getRequestDispatcher(String uri);	方法源码写的是getRequestDispatcher(String path)。看课堂笔记'获得转发器'和我的笔记'URI、URL和URN'
3. 转发之后，浏览器地址栏的地址不变。因为转发是服务器内部的跳转。而重定向会变，因为是服务器让浏览器去请求。
4. 确认框： confirm(); js学过，今天在listUsers.jsp中的删除操作搭配return使用。
5. html符号：双箭头：&raquo    登录页面的确定按钮里的
6. 为什么不能加两个header.jsp 可以加两个footer.jsp
7. JSP：<%@ page contentType="text/html; charset=utf-8"%>   属性之间必须空格隔开！！也必须有分号，即分号和下一个属性之间必须空格隔开！不然报错！
8. 转发不需要非得绑定数据，只是一个web组件通知容器去调用另外一个web组件。


#------------------------------------Servlet.day06--------------------------------------
###day06工程讲Cookie；day06-lab工程是个人写的练习，day06工程中有老师写的。


##状态管理
 - 状态：多次交互所涉及的数据


##Cookie
		看课堂笔记'Cookie'
 - 添加Cookie：response.addCookie(c);
		执行完这行代码，服务器会发送set-cookie消息头给浏览器。消息头的值是：cookie的名字和值，以name=value的方式发送给浏览器
 - 浏览器可以把Cookie保存在内存/硬盘上。
		默认情况下是把Cookie保存在内存中。如果关闭浏览器，则浏览器进程结束，操作系统会把浏览器维护的内存清空，Cookie也没了。
 - 当浏览器收到Cookie后，再次发送请求，会以Cookie消息头的形式将之前临时保存的数据发送过来。
 - Cookie[] request.getCookies();
		如果没有Cookie，则返回null，所以需要先判断不为空再取值
 - 修改Cookie：Cookie c = new Cookie("username","xxx");response.addCookie(c);
 - 删除Cookie：Cookie c = new Cookie("username","");c.setMaxAge(0);response.addCookie(c);
		新的把老的覆盖，并且新的立即删除。
		设置了删除，请求发出后在抓包工具可以看出，服务器发给浏览器的响应头Set-Cookie:多了例如： Max-Age=40;(存活时间40s) Expires(有效期)=Mon, 07-Jan-2019 08:07:08 GMT
###Cookie的编码问题
 - Cookie只能存放合法的ascii字符。合法的意思是：ascii字符有个别的几个也不能保存。
 - 处理方式使用encode()和decode()方法。
 - 有的比较高版本的tomcat在添加cookie的时候即使没有做encode()处理，也不会报错。因为比较高的版本的tomcat底层功能的实现已经自动按照utf-8进行编码处理了，而且也是按照utf-8进行的解码。
 - **建议总是做编码处理**，兼容性更好。
		因为第一：ascii字符有几个也不能保存，也得做编码处理。
		第二：不能保证我们做完后甲方用的是高版本的tomcat。


##查看Cookie的操作
 - 查看浏览器发送过来和服务器发送出去的Cookie：抓包工具
		打开抓包工具，可以看到服务器发送的响应头Set-Cookie: 形式是name=value。
		当浏览器收到Cookie后，再次发送请求，也会看到请求中有上次的Cookie的消息头
		可以同时发送多个Cookie。
 - 查看浏览器收到的Cookie：右上角菜单(三个点)-->设置-->高级-->隐私设置-->内容设置-->Cookie-->查看所有Cookie和网站数据
		以Chrome为例
		打开浏览器查看Cookie可以看见浏览器收到的cookie。(先清空后实验会更便于查看)
		(并且可以在这里设置禁止cookie，这是cookie受限制的一点。)
``		名称相同且路径相同的Cookie会被覆盖，只显示一个。**路径不一样不会被覆盖：但是开发中尽量不要这么做**，因为代码会越写越复杂，因为要考虑名称相同路径不一样的问题。


##添加cookie和读取cookie代码
 - 添加cookie
		Cookie c = new Cookie("name",URLEncoder.encode("value","utf-8"));  实例化对象、设置编码
		c.setMaxAge..		设置生存时间
		c.setPath				设置路径
		response.addCookie(c)	添加
 - 读取cookie
		Cookie[] cookies = request.getCookies();		get
		if(cookies != null){		判断
		for(Cookie c : cookies) {	遍历
		...URLDecoder.decode(c.getValue(),"utf-8"))		取值、解码
		...		}			...或者还要删除等
		}


##路径
 - 浏览器在向服务器发请求时，会比较请求路径是否与cookie的路径匹配，只有匹配的cookie才会被发送。
		如果不这样就会消耗很多流量、没有必要、也不安全。

##jsp中使用Cookie
		Cookie的路径问题用的是jsp演示的，因为jsp可以在文件里有很多层，好演示。
 - jsp中写Cookie是不需要导包的
		因为jsp转换成servlet的java代码里面默认import了三个包，其中有一个是：
		import javax.servlet.http.*;		Cookie就在这个包里面。
day08学完后解释：
 - 浏览器访问jsp，可以在高级中看到一定会有一个JSESSION的Cookie，这是一个sessionId。
		因为jsp转换成servlet的java代码里面有这么两句代码：
		声明：javax.servlet.http.HttpSession session = null;
		赋值：session = pageContext.getSession();这句代码底层的实现是调用request.getSession()
``		(session也是一个'隐含对象')
``		**有关jsp的疑问，要时刻谨记它是一个草稿，是要转换成servlet的**


##小项
1. 面试问题，看课堂笔记'比较转发与重定向'
2. day06-lab:Find_add..et.java:逻辑出错，在循环内if-else，else是不符合逻辑的，因为没循环完怎么就能判断else呢。请求后会报错。


#------------------------------------Servlet.day07--------------------------------------
###day07工程讲session；day07-2工程迭代的day05工程，增加session验证功能；day07-3工程搭配图checklogin.png讲解session原理(可以不看，讲之前我就懂了)


##Cookie的限制
 - a.可以被用户禁止
		高级设置-->内容设置里可以禁止
 - b.不安全
		用户在高级设置中都能够看到。对于敏感数据(比如帐号密码)，一定要加密(加密算法-有现成的API)。
 - c.只能存放少量数据
		大约4k左右
 - d.数量也有限制
		浏览器大约能存放几百个cookie
 - e.只能存放字符串


##Session(会话)
 - Session是什么：服务器端为了保存用户的状态而创建的一个特殊的对象(即session对象)。
``		查看浏览器Cookie中的**'JSESSIONID'是Cookie  路径是/  ！**
		当浏览器第一次访问服务器时，服务器会创建session对象(该对象有一个唯一的id,一般称之为sessionId),接下来服务器会将sessionId以cookie的方式发送给浏览器，浏览器保存在内存中。当浏览器再次访问服务器时，会将sessionId发送过来，服务器就可以依据sessionId找到对应的sessinon对象。
 - Session的id很长，32位既有字母也有数字，很难猜出来。id很长就很难被伪造，不知道值也不能修改，所以很安全。
 - **Session的绑定值是object类型，所以一个访问者/用户只有一个session**  我认为！
		我认为正是这个原因，一个访问者/用户才只有一个session。(一个访问者/用户可以有多个cookie)，因为object类型可以存很多东西，存数组都可以，所有的数据都在object里和绑定名关联在一起，并且共用同一个id。
		而cookie的绑定值是String类型，所以cookie可以有多个也是理所当然。
###获取session对象：
 - 为了节省资源空间，服务器会把空闲时间很长的session删除，这就造成了有sessionId但找不到对应的对象的情况。
 - 参数为false的方法：HttpSession s = request.getSession(true);
		此方法简述就是：获得已有的sessionId对象的方法。
		如果没有/找不到，底层代码会new一个session对象
 - HttpSession s = request.getSession();等价于HttpSession s = request.getSession(true);
		`因为开发中80%用的都是参数为true所以sun公司特意做了个不带参数的
		方法HttpSession s = request.getSession();
		它的源码只有一行就是HttpSession s = request.getSession(true);
###session的常用方法
 - 绑定、修改数据
		session.setAttribute(String name,Object obj);
 - 依据绑定名，获取绑定值
		Object session.getAttribute(String name);
 - 删除、解除绑定
		session.removeAttribute(String name);
``		删除指定名称的绑定对象，调用了这个方法后再调用getAttribute则返回null，但是session对象还是原先的


##修改超时时间长度的操作
		没必要改，大部分服务器默认的超时时间长度为30分钟。30分钟就很合适了。
 - 方式一 修改web.xml
``	a.	修改Servles工程-->Tomcat-->web.xml
		<session-config>
			<session-timeout>30</session-timeout>
		</session-config>
		这是改的服务器的配置，所有部署到这个服务器的应用都会收到影响，一般不要改它
``	b.	上边的代码复制到某个webapp-->web.xml
		只对当前应用起作用
 - 方式二 编程的方式
``		session.setMaxInactiveInterval(int seconds);
		设置两次请求之间最大的时间间隔


##删除session的方法
 - session.invalidate(); 	invalid失效，无效的
 - 为什么不叫delete或drop：
		服务器在执行这个方法的时候，底层并不会真正的把这个session对象删掉，对象的删除销毁是有资源开销的。为了节省这笔开销，服务器只是把这个session对象里的数据抹掉了，这样session就是一个空白对象，然后再给空白对象重新分配一个id给另外一个用户服务，这样可以节省对象的创建和销毁的开销。


##删除操作为什么要保护
 - 每个操作都要保护。
``	a.假如用户在这个页面停了半个小时然后进行删除，而此时session已经失效了，再允许删除就变得不符合逻辑，不合理。
``	b.或者用户不登陆直接在地址栏输入.../del?id=10 直接删除。如果不加保护也会删除成功。


##Cookie和Session什么时候用
		实际应用中sookie和session要结合使用
 - 对于比较重要的、安全性要求比较高的数据，用session
 - 不是很重要的用cookie


##小项
1. oracle老板喜欢钱，最近有个消息2019年开始,使用java可能要慢慢开始收费。现在java发展要看两个公司：apache和亚马逊。以后企业里java要收费的话选亚马逊的jdk比较靠谱(open jdk)
2. 高德纳：《计算机程序设计艺术》讲的算法  写了一个排版程序：Tex 说谁能找到一个bug给5美元。最后一个bug是被Oleg Bulatov发现的
3. session不是发给浏览器的，是服务器端的对象。只有sessionId以cookie的形式发给浏览器。
4. cookie数量也有限制，浏览器大约能存放几百个cookie。
		很多浏览器限制一个站点最多存放约20个cookie
5. 同一浏览器开两个窗口也能访问到相同的session数据，因为他们同属一个进程，共用一个内存，内存里有sessionId。


#------------------------------------Servlet.day08--------------------------------------
###day08工程讲路径；day08-2工程讲容器处理请求路径；day08-3工程迭代day07-02工程，实现一个Servlet处理多个请求(流程控制)。
###day08-4工程讲上下文作用：绑定


##部署的原理
		发现eclipse中的工程下的webapp目录和部署文件的结构是很相似的。
		eclipse做了以下的事：
 - 部署的时候eclipse会把webapp整个文件夹拷贝到tomcat里，并把webapp改名为应用名(应用名默认工程名。笔记'修改工程应用名的操作')
 - 如果有java代码，eclipse会编译，并在WEB-INF里建一个classes文件夹，将编译好字节码文件放到classes文件夹里面。如果有jar包，会在WEB-INF里建一个lib文件夹，并放到此文件夹中。


##路径问题
 - 课堂笔记中的路径问题的意思是：四种情况(链接、表单提交、重定、转发)下路径应该怎么填写
 - 我们平时写的day0x/xxx.jsp 这样的路径，其实day0x是应用名，即webapp，部署后被eclipse改名为应用名(默认工程名)
 - 相对路径是：**相对于现在这个文件所在的路径**。所有的文件的根目录都是应用名。
 - 绝对路径用得更多。好处有两点：
		1. 好写。好写在不用考虑相对位置关系，从应用名开始算即可。
		2. 好维护。引用的文件即使位置改变了也没关系，被引用的文件位置不变就可以。(还是不用考虑相对位置关系)
 - 应用名要用方法写：String request.getContextPath(); 获得实际部署时的应用名,方法的返回值是以斜杠开头
		实际应用中应用名可能会改，一定要使用这个方法，可以避免


##容器如何处理请求资源路径
		看课堂笔记
		比如，在浏览器地址栏输入http://ip:port/day08-2/abc.html
 - 浏览器会把端口后的内容 /day08-2/abc.html 当作请求资源路径发给容器
 - 容器默认认为访问的是一个servlet。
		即如果我们在webapp下建立一个abc.html；同时又在web.xml中一个<url-pattern>中写abc.xml并让其<servlet-class>为一个Servlet的java类。此时浏览器访问day08-2/abc.html请求是发给了servlet，而不是这个名字一样的文件。
 - 精确匹配：就是<url-pattern>的值和请求地址(/abc.html)一样。大小写都得一样


##让一个servlet处理多种请求
		day08-2工程_SomeServlet.java中体验。
		day08-3工程_ActionServlet.java中实现。这个servlet就是MVC中进行流程控制的代码(控制器)。开发中servlet只需要一个
 - 用后缀匹配or通配符匹配都可以
 - 方法：获得请求资源路径
		String uri = request.getRequestURI();
		然后按照 / . 拆分判断
 - 注意：点击用户列表 删除 的请求路径变成了del.do?id=xx  ?前面是路径


##Servlet上下文
 - context：环境；上下文；来龙去脉；语境
 - sun公司希望把这个对象做成非常重要的，对我们开发很有意义的一个对象。所以叫context上下文。ServletContext
		sun公司有一个理想：想让容器的开发人员除了为web应用提供网络相关的服务之外，再提供多一些的服务。因为我们再开发项目的时候经常会有一些常见的需求，比如权限管理。容器的开发人员事先把这些常见功能写好，作为开发者就不用写了，只需要通过Servlet上下文调用这个服务就可以了。比如权限管理的服务、安全性、日志、事务等。
		但是这个对象其实没什么用，因为真实应用里对于这些功能的要求非常高，非常细。就是说容器虽然有，但是不足以满足我们的要求。sun公司想让我们不用写这些代码，但我们还是得写。
		现在很少用这个对象去调服务了。但是还是有一些有用的地方。我们要学的就是。
 - 上下文的特点 常考：
		唯一性：一个web应用对应一个Servlet上下文。
		持久性: 只要容器没有关闭，应用没有被卸载，Servlet上下文就会一直存在。-- 你若不离不弃，我便生死相依
				(应用被卸载即：Servers-->右击应用-->Remove)


##request & session & Servlet上下文   绑定的区别
		day08-4_AServlet.java&BServlet.java
 - request,session,Servlet上下文都提供了绑定数据相关的方法
		setAttribute,getAttribute,removeAttribute
 - 生存时间不一样。结论：在满足使用条件的情况下，优先使用生命周期短的(节省内存)。
		- request：生存时间在一次请求和一次响应期间
		- session：在多次请求和响应期间，并没超时内存在
		- servlet上下文：只要容器没有关闭，应用没有被卸载就存在
				request < session < servlet上下文
``		以转发为例：将数据绑定在request对象里，然后获得转发器转发。其实完全可以把数据绑定在session对象或上下文里面，然后转发也可以，完全没问题。但是用request节省内存，响应发送完之后就销毁了。所以优先使用声明周期短的。
 - 可访问的范围不一样。
		绑定到session对象上的数据只有与之对应的用户能够访问
		绑定到Servlet上下文上的数据，所有用户都能访问到


##小项
1. 课堂上写相对路径是因为课堂上的路径都很简单，但是实际开发的话路径可能就比较复杂了。
2. 刚发现重写sevice方法的话它会自带throws ServletException, IOException两个异常。。


#------------------------------------Servlet.day09--------------------------------------
###用day08-4工程讲上下文作用：读取全局的初始化参数；
###day09工程_BasicServlet讲生命周期,其他的是重写BMI练习


##全局初始化参数
		同应用的所有的servlet都可以用
 - 初始化参数：我们可能需要在启动servlet的时候给他初始化一些参数，可以在web.xml配置文件中对servlet进行配置。
		如果在servlet里写就写死了，所以在xml中写。
		比如：很多企业都有这么一个需求：我们开发一套软件，别人在访问的时候，希望能够把公司的名称、地址、联系方式都输出一下。即servlet一运行，就要输出一个公司的名字等。 
 - 配置方法和读取方法见课堂笔记
		若要配置多个，要再添加一套标签。


##对象&实例&类的区别
		可以说一样，但也有微妙的差别：
 - 对象-object：东西、物件
 - 类：是基于业务领域的对象做的一个抽象
		业务领域的意思：宠物店的宠物猪，和厨师眼里的肉猪 是不一样的。所以基于业务领域
 - 实例：调类的构造器的那个对象
 - 对象是生活当中的东西，实例是具体的哪个东西
 - **我们不细抠对象和实例，讲课过程中没有区分这么仔细**，只是作为细分的了解


##servlet生命周期--实例化
 - 情况1: 容器收到请求之后创建。
 - 情况2: 容器启动之后，立即创建(需要配置)。
		配置启动加载： <load-on-startup>1</load-on-startup>
		容器启动之后，会立即创建该servlet对象。值是一个大于等于零的整数，值越小，优先级越高(即多个servlet值越小越优先被创建)。
``		这种情况 一般搭配 '在启动时初始化' 的需求 时使用，因为实例化后会立即初始化。
``		优先级平时没什么考虑。当我们实际开发中可能希望某个先初始化，某个后初始化，这时需要考量这个值。
 - 注：容器只会创建一个实例！ 即构造方法只执行一次
 - 先实例化，之后立即初始化。这是一个连贯的执行。


##servlet生命周期--初始化
###servlet-init()/初始化方法
		init：初始化
``		看课堂笔记(3)'相关的接口与类(了解)'和' 2)初始化'以及图'init.png'
 - 老师找的tomcat**init()相关源代码**。
		源代码(老师强调不需要看，看不懂打击人。需要下载)目录是：apache-tomcat-xx版本号-src-java-->javax-->servlet-->GenericServlet.java
		在eclipse中导入servlet源码也可以看。。。
		这个类中有这样的代码：
			private transient ServletConfig config;
``			获得ServletConfig对象的方法：
			public ServletConfig getServletConfig() {
				return config;
			}
``			init()-带参：创建servlet实例之后，会立即调用该实例的init方法
			public void init(ServletConfig config) throws ServletException {
``				this.config = config;			将容器传递过来的ServletConfig对象保存下来
``				this.init();						调用我们重写的init()
			}
``			init()-不带参：这是让我们重写的init。重写的目的是为了扩展初始化的功能
			public void init() throws ServletException {

			}
 - init.png图解：容器收到请求(如果配置启动容器时就实例化，就不需要请求了)，创建srevlet实例，后立即调init(ServletConfig config)方法：把容器传过来的ServletConfig对象保存下来，然后调用我们重写的init()。我们通过重写init()来实现自己的初始化逻辑。
####重写init()的操作
		source一般都是和源代码相关的操作
 - 右击Source-->Override/Implement Methods-->GenericServlet-->init()
 - 重写init()的目的：扩展初始化的功能。(实现自己的初始化处理逻辑)
###初始化参数-局部
		这个是局部的初始化参数，标签写在web.xml的一个servlet里面，只对所在的servlet有用。
 - ServletConfig对象的主要作用就是读取初始化参数。
		也可以获得ServletContext上下文
 - 读取初始化参数值方法：String getInitParameter(String name);
 - 配置方法和读取方法见课堂笔记
		若要配置多个，要再添加一套标签。
 - **初始化标签要写在实例化标签前面，不然会出错，不知道为啥**！！！？？？
		百度了一会，就说得放前面，也没百度到为什么，回头仔细百度
###什么时候需要初始化
 - 一些比较复杂的初始化操作。不需要每次请求都执行的，先初始化好，节省cpu开销。
		如果一个servlet的初始化过程很长：比如需要访问数据库，需要查询一些表，要把一些数据读出来放到内存里面去。那么使用初始化，将数据准备好。这样请求发过来后，就直接去内存找这个数据即可。


##servlet生命周期--就绪(调用)
 - 在BasicServlet.java中示范。示范doxxx方法时注掉了service方法，因为我们写的service方法中没调用do方法，只有父类的service代码才调用do方法。
		在这里我们重写的do方法，当容器收到请求后调用父类的service方法，然后service再调用(在浏览器地址直接填地址是get请求)我们的doGet()。
 - HttpServlet中的service方法是依据请求类型调用对应的doXXX方法。
		比如，get请求会调用doGet方法，post请求会调用doPost方法。
		doXXX方法只是抛出了一个异常。目的是想让开发人员，只需要override doXXX方法即可。
 - 我们一直以来是直接重写的service方法，在service中写逻辑，也没有调/也没必要调用doXXX方法。因为都是一样的。
 - service.png图解：BasicServlet中service我们没重写
		我们以后写一个servlet有两种写法，一种是官方的建议：把父类的do方法重写；一种是我们一直的写法：直接重写service方法。
 - HttpServlet的**service()源代码**
		exlipse中看，或者源码目录在GenericServlet.java同级目录servlet下的http文件夹中。
``		service()方法中先是请求对象调用方法：req.getMethod()，获取请求类型。
``		然后判断：如果是XXX请求，则调用doXXX(req,resp方法)
		doGet方法中的代码只是抛异常：我们可以把BasicServlet.java中的service和doGet都注掉，然后启动容器访问这个servlet，那么请求会发给容器，容器调用HttpServlet中的service，service判断是get请求(在浏览器地址直接填地址是get请求)，然后调用doGet，那么这个异常就会抛出：405状态码-Http method GET is not supported by thid URL--http的get请求不支持
 - sun公司建议我们重写do方法，但我们可以直接重写service。
		如果有这种需求：get请求要这么处理，post请求要那样处理--不同的请求需要进行不同的处理，那么重写do方法比较好。如果直接写service就要加判断，判断是什么请求类型。而重写do方法父类的service就帮我们判断好了。
 - **我们重写do方法，则容器就调我们的do方法。我们重写service，则容器就调我们的service**


##servlet生命周期--销毁
		用于释放资源
 - 容器在删除servlet实例之前，会调用该实例的destroy方法。不写销毁也不会报错的原因：
		GenericServlet已经提供了destroy方法的实现。
 - GenericServlet的**destroy()源代码**
``		- 空的，什么都没写。我们可以override GenericServlet的destroy方法，来实现自己的销毁处理逻辑。
``		- 一般来说，我们在初始化中拿到什么东西，在销毁方法中就要归还。比如我们在初始方法中拿到了数据库连接，在销毁中就要断掉连接或者归还到连接池。因为连接是有限的。
 - 我们用一个暴力的方法让destroy()执行：卸载应用。
		容器在删除servlet实例之前，会调用该实例的destroy方法。要删除实例可以卸载应用来实现。
		此时控制台会输出destroy()中我们写的输出代码。


##servlet生命周期总结
 - life.png图解： 3 请求收到后实例化。
		我们用默认的形式画图，如果加<load-on-startup>标签，则启动容器时就创建
 - 我们可以把生命周期看成一种契约/约定。即容器和我们写的servlet的约定。我们只需要把方法(init()/service()/destroy()/构造器)写好，容器就会按照一定的规则/规律去调用。
		我们要按照这种约定写代码。
 - 就绪(调用)：是每次请求都执行此一次。实例化、初始化、销毁：一个生命周期只执行一次


##重写BMI练习相关
 - 用配置文件/初始化参数
		有可能以后最大/小值会变，所以写在配置文件中
 - 在init()中拆分初始化参数
		因为不需要每次请求都拆分一次，浪费cpu资源。总体只拆分一次即可。
 - 初始化需要一定的时间，所以我们让启动时就实例化，这样就会启动时就初始化。
		因为实例化后紧接着初始化。优先级的值没有要求


##New Servlet的操作
 - 直接new Servlet-->
``		第一个窗口：可以看到帮我们直接把父类加进来了
``		-->next：第二个窗口，生成部署描述信息：
		Name：对应描述文件中的servlet-name。默认也可以
		Description：描述，相当于注释。可以不写
		URL mappings：就是url-pattern。可以改。
				右边有add：实际上我们可以让多个url-pattern对应一个servlet，只不过比较少见
``		-->next:第三个窗口，可以看到能加入一些方法。
		默认doGet和doPost加入进来，这是sun公司官方的建议。我们直接重写service即可，把那两个去掉。
		Constructors from superclass 用不到构造器也去掉
``		-->finish
		可以看到加上了一个序列话版本号，因为GenericServlet实现了序列化接口Serializable：序列化接口为了保证序列化，反序列化的时候不发生版本错误，所以加上了序列化版本号。我们使用系统自带的即可。
		可以看到web.xml中也加入了对应的配置。但是多了两行标签:
				<description></description>
				<display-name>BmiServlet</display-name>
				这两个元素可以不要，相当于一段说明，说明Servlet是干什么用的，可以在里面写注释说明。删掉即可


##小项
1. 硬编码：将可变变量用一个固定值来代替。造成后期更改困难。


#------------------------------------Servlet.day10--------------------------------------
###day10工程讲过滤器；day10-2工程讲监听器；day10-lab工程是我做的练习，老师在day11工程讲


##过滤器
 - 过滤器非常像servlet，而且也有生命周期。四个阶段：实例化、初始化、就绪、销毁
 - 容器启动之后，会立即创建过滤器实例。不会等请求发过来再创建。
		只会创建一个实例。
 - filter.png图解
``		1 容器收到请求后总是会先创建请求对象和响应对象
		3 如果有过滤器，则先调过滤器doFilter(),他会把请求对象和响应对象传进去，在过滤器中使用
		4 调用了过滤器链的doFilter()方法之后，容器会继续向后调用Servlet的service()
		5 Servlet执行完service()后将处理结果返回给过滤器：我们可以对处理结果进一步进行处理
 - **过滤器可以在servlet的service方法执行前和执行后做一些处理**
###过滤器中的方法
 - void init(FilterConfig filterConfig)
		容器在创建好过滤器实例之后，会调用该实例的init方法(只会调用一次)，容器会将FilterConfig对象作为参数传递过来。可以利用Filterconfig来读取初始化参数，也可以用来获得ServletContext。
		注：ServletConfig也可以获得ServletContext上下文
 - void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
``		容器收到请求之后，会调用过滤器的doFilter方法(类似于Servlet的service方法)。
		ServletRequest是HttpServletRequest的父接口
		ServletResponse是HttpServletResponse的父接口。
		FilterChain（过滤器链)：如果调用了该对象的doFilter方法，容器会继续向后调用，否则，中断请求，返回处理结果。
``		因为sun的过度设计，需要做强制转换(我们经常用的是子接口中的方法)。
		HttpServletRequest request = (HttpServletRequest)arg0;
		HttpServletResponse response = (HttpServletResponse)arg1;
			|| 了解：为什么是ServletRequest/Response而不是HttpServl...
			这是sun公司过度设计(想多了)的产物。sun公司在设计servlet规范的时候，有这么一个长远的想法：把Servlet规范打造成一个与具体网络协议无关的规范，(即除了Http其他的都可以基于Servlet规范来开发,这是可行的：因为任何网络编程的模型都差不多，都是打包拆包请求处理等。)。Servlet的API中主要有两个大的包：
			|| javax.servlet.*;javax.servlet.http.*;所有和具体协议无关的接口与类都在servlet.*包里，servlet.http.*包是为了支持http协议定义的接口和类，这里面的接口和类往往是从servlet.*包里继承过来的。好处是自定义协议(自定义协议是很常见，已有的协议不满足要求比如安全性、速度等，比如抖音、腾讯微视频等都是自己的协议)可以用servlet.*包来扩展(比如我们企业内部要开发个协议，java.servlet.tarena,就可以利用javax.servlet.*中的接口与类来拓展)。但是实际上没人这么做，因为这些接口和类谁都可以定义，不需要听他的，还要受他控制。
			|| 过滤器接口、ServletRequest/Response对象等就是在javax.servlet.*包中定义的，都是和具体协议无关的。这么设计想法很美好，但是造成我们在用的时候很麻烦。我们在doFilter中用的往往是子接口中的方法，所以要做强制转换.
``		过滤器的doFilter()和过滤器链的doFilter() 区分
		容器启动后调过滤器的doFilter(),他会把请求对象和响应对象传进去，在过滤器中使用
		过滤器链的doFilter()是将请求对象和响应对象传进去，使继续向后调用Servlet的service方法。参数写request/arg0、response/arg1都可以。因为指向的都是同一个对象。我们强转只是为了用javax.servlet.http.*里子接口的方法
 - void destroy()
		容器在删除过滤器实例之前，会调用destroy方法(只会调用一次)。
###配置过滤器
		在web.xml中配置，和servlet的配置类似。
 - 也是用的java反射实现的，所以类名不能写错
 - url-pattern和servlet一模一样，可以用精确匹配、通配符、后缀匹配。
		写和servlet一样的url-pattern并不会冲突，因为会先执行过滤器。
		如果写/*就会拦截所有的
###过滤器的优先级
		过滤器可以写多个，容器会一个个调用。
 - 调过滤器链的doFilter()方法，严格来说是调后续的web组件，可能是个servlet，也可能是下一个过滤器
 - 当有多个过滤器都满足拦截要求，则容器依据<filter-mapping>配置的先后顺序来执行。
 - 过滤器的底层实现(了解)：
		容器启动之后，读取web.xml，通过java反射先创建过滤器对象并实例化，接下来容器会将所有的过滤器对象按照配置文件的先后顺序放入滤器链对象中。过滤器链可以看作一个list集合，过滤器链的底层实现就是一个ArrayList。
		每调用一次过滤器链的doFilter()方法，就从集合中取一个过滤器对象，并调用过滤器对象的doFilter。
###过滤器的初始化参数
 - 配置：在web.xml中，在过滤器的标签内写
		三个标签，见课堂笔记
 - 读取：利用FilterConfig对象去读取。在init方法中有这个参数，我们需要设置一个全局变量，将容器传给init的这个变量保存下来。
		见CommentFilter.java  先设置全局变量，后在init方法中赋值
 - String getInitParameter(String name)方法，用来读取初始化参数
		- ServletContext  ServletConfig  FilterConfig  三个对象均有这个方法，都是用来读取初始化参数
###过滤器的优点
 - a.可以在不修改原有代码的基础上，为应用添加新的功能。
		这一点很重要：因为有些时候你没有源代码，或者有时候有源代码但是你不能改。
``		软件设计领域有一个很有名的设计原则，开闭原则：一个软件系统要**对修改关闭，对扩展开放**。
			因为修改源代码就要重新测试。oracle数据库有2000万行代码，修改一个bug很好修，但是怕产生新的bug，所以要测试，测试的话要40台机器一起跑8个小时。根本就修改不了了。
 - b.可以将多个组件相同的功能集中写在一个过滤器里面，方便代码的维护。
		有的很多组件有相同的功能，有时就可以放在监听器中


##监听器
		day10-2工程；监听器的重要性没有过滤器那么大，用的不多。
 - 监听容器产生的事件。
 - listener.png图解：
		图描述的是统计在线人数的练习CountListener.java。
		4 将人数绑定到上下文中，因为上下文会一直存在，且所有用户都能访问到
 - 容器一启动就会把监听器实例化，只会创建一个实例。
###session监听器中的方法
 - 监听器的方法是在响应的事件产生以后去调用的。
		比如session一创建，容器会调用监听器的sessionCreated方法
 - void sessionCreated(HttpSessionEvent arg0)
		session对象创建之后，容器会调用此方法。HttpSessionEvent是事件对象。可以通过事件对象来获得session对象。
		间接获取session对象：因为session已经被创建了。所以通过事件对象的getSession()方法获取。原先是通过request对象获取
 - void sessionDestroyed(HttpSessionEvent se)
		session对象销毁之后，容器会调用此方法。
###配置监听器
 - 监听器的配置很简单，只要告诉容器监听器的类名是什么
		比如：
		<listener>
			<listener-class>web.CountListener</listener-class>
		</listener>
###监听器的生命周期
 - 只有创建(实例化)，别的没了
		容器一启动就会把监听器实例化，只会创建一个实例。
###在jsp中输出当前系统在线人数
 - 可以这样写：<%=session.getServletContext().getAttribute("count") %>
 - 也可以这样写：<%=application.getAttribute("count") %>
``		application也是一个'隐含对象'	类型是ServletContext
		jsp转换成servlet的java代码里面有这两行代码：
		声明：final javax.servlet.ServletContext application;  类型是ServletContext
		赋值：application = pageContext.getServletContext();
###day10-2工程监听器
 - 使用原理：用不同浏览器访问hello.jsp，模拟多个用户访问。则监听器CountListener就会监听到session的创建和销毁
		如果是用同一个浏览器只有一个session,达不到效果
 - 监听器是监听'servlet容器'产生的事件并进行相应的处理。所以我们访问jsp就可以触发监听器。
 - session有半小时的生存事件，我们可以添加一个功能：退出销毁
		在jsp中：<a href="logout">安全退出</a>		安全的意思就是让用户心里作用去点它，而不是直接关浏览器
		再写一个Servlet处理超链接的请求：写一个LosoutServlet，实现session.invalidate();
		这样就可以显示尽量准确的在线人数。		没写，让我们有空试试


##Servlet文档
		Servlet的API都在这四个包里
 - javax.servlet 与具体协议无关的类和接口
 - javax.servlet.annotation 
 - javax.servlet.descriptor
 - javax.servlet.http 和http协议相关的类和接口
 - 	中间两个先不用管它，他是最新的规范当中添加了一些java注解可以简化我们的编程。即3.0以后我们可以不用写配置文件了，最新的规范中可以用java注解来代替。原理一样，只是简化
###监听器接口
 - HttpSessionListener	`在javax.servlet.http包中`
		学了，这个最重要
 - ServletContextListener	`在javax.servlet包中`
		两个方法：
		上下文一创建容器会调用contextInitialized(ServletContextEvent sce)
		上下文一销毁容器会调用contextDestroyed(ServletContextEvent sce)
 - ServletRequestListener	`在javax.servlet包中`
		两个方法：
		请求对象一创建容器会调用requestInitialized(ServletRequestEvent sre)
		请求对象一销毁容器会调用requestDestroyed(ServletRequestEvent sre)
 - 绑定数据相关的事件老师没说，也在这里。应该是：
		HttpSessionAttributeListener接口
		ServletContextAttributeListener接口
		ServletRequestAttributeListener接口
 - 这都是接口，**使用监听器的时候只需要实现需要的接口，然后在方法中写监听处理逻辑即可**。


##小项
1. 老师的eclipse自动添加方法时的形参和我们的形参名字有些不一样，应该是版本问题，注意就行
2. Servlet也有文档，Tomcat也有文档，可以在doc.tedu.cn看都有哪些，然后回家下载


#------------------------------------Servlet.day11--------------------------------------
###day11工程讲昨天的练习,其中CountServlet.java解释线程安全问题；
###day11-2讲jsp基础补充的知识(webapp)


##web缓存
		图cache.png
 - 我们可以将数据库中的一些数据提前查询出来，放到内存里面(比如放到Servlet上下文)，这样，请求过来时就不需要查询数据库了，直接从Servler上下文中获取。
		很多时候程序慢就慢在数据库上，因为IO操作很慢。访问内存更快很多。
 - 这些数据不能太大，而且数据很少发生变化，而且频繁使用。
		实际应用中一般不超过几十万条数据。


##CacheListener练习讲解--昨天的练习
		CacheListener.java
 - 通过事件对象获取上下文。
###监听器中异常的处理
 - findAll()方法有个异常：捕获之后，这里并不能告诉用户系统繁忙，稍后重试。因为此时容器刚启动，用户并没有发送请求过来，在这里没有办法通知用户。
 - 解决方法：在这里只记日志即可。用户访问jsp，在jsp中判断：若上下文绑定值为null，则告诉用户繁忙重试


##Servlet小结
 - 看课堂笔记**'Servlet小结'，总结整个知识体系**


##jsp
 - jsp并不是我们的重点。因为现在有更好的技术来处理表示逻辑，有可能到企业里是用html结合js来做(新技术)。
 - 访问jsp也可以传参，比如loca../a5.jsp?number=100  和访问servlet一样
###New JSP File的操作
 - new-->名字不需要写后缀了，自动生成
	-->Next：页面展现的是一些模板，默认是New JSP File(html)
		直接点完成默认是上次选择的模板
	-->Finish
 - 生成的页面的一些问题
		language="java"  过度设计的产物，告诉容器这里面是什么语言，多余的，根本没用。删掉
			本质是sun公司在推出jsp规范的时候，希望以后在jsp里面可以写别的语言的代码，但是目前为止，只支持java
		把没用的东西、注解都删掉，会页面简洁。
###自定义jsp模板的操作
		其实以后我们不会这么写，以后都是美工设计好的静态页面我们来改。这里只是为了课堂做案例便捷。
 - jsp中任意空白处右击-->Preferences...参考-->Web-JSP-Editor-Templates模板
	-->New...：
		随便取个名字myjsp
	-->Context环境：模板用在哪个地方
		选New JSP
``		Pattern样品，模式，图案：
		这里是自定义的模板
	-->OK-->Apply and Close
###jsp中的<%! 声明变量或方法  %>
		a1.jsp
 - 从查看tomcat-work文件里生成的servlet源代码可以看出，声明的变量是(属性)全局变量，声明的方法是和service并列的方法。


##JSP的隐含对象
		看课堂笔记'隐含对象'
###常用的六个
 - out输出,request请求,response响应,application上下文,session	用法可分别搜索前面的笔记'隐含对象'
		a2.jsp 演示session只为加深印象，没补充啥
 - pageContext：页面上下文
		容器会为每一个jsp实例创建唯一的一个符合PageContext接口要求的对象，该对象会一直存在，除非jsp实例被删除。
		a3,a4.jsp
		作用一：绑定数据。 有绑定数据的方法setAttribute()。绑定的数据只有自己能访问到
``		**request、session、servlet上下文、页面上下文，一共就这四个对象有setAttribute()-绑定数据的方法。**
		作用2: 获得其它所有隐含对象。 明天讲
###很少用||从来不用的三个
 - config:类型是ServletConfig，用来读取初始化参数
		a5.jsp；即jsp也可以配置初始化参数，通过这个对象读取。只不过很少用
 - exception
		a6,a7.jsp
		a6中访问参数写成100a，使抛异常
			黑客攻击很典型的一种手段：故意访问你的网站让他抛出异常，然后分析程序的漏洞。
``		我们要绝对禁止把这种底层的异常抛给用户看。
``		解决办法：
			我们也可以在a6.jsp中try-chath，如果捕获到NumberFormatException,就输出请填写正确的数字。
``		在a6中添加'page指令的属性'：errorPage="a7.jsp" 告诉容器如果执行这个jsp出问题了，就立即调用a7.jsp。
			a7.jsp称为异常处理页面，专门处理其他的jsp的异常
``		a7中page指令的属性：isErrorPage="true" 是不是错误页面，不写得话缺省值false
``		**必须把isErrorPage属性值设置为true才能用exception**
``		exception用来获得 'a6' 运行过程当中产生的异常信息。意义不大，因为用户看不懂
		这个异常很简洁，不会把所有的异常信息都给你，只会大体描述一下。
 - page：是jsp实例本身。过度设计的产物，从来不用。
		是jsp对应的那个servlet对象，一般称之为jsp实例。


##配置JSP的初始化参数
 - 举例：
		<servlet>
			<servlet-name>a5</servlet-name>
			<jsp-file>/a5.jsp</jsp-file>
		<!-- 配置初始化参数 -->
		<init-param>
			<param-name>company</param-name>
			<param-value>码多多</param-value>
		</init-param>
		</servlet>
		<servlet-mapping>
			<servlet-name>a5</servlet-name>
			<url-pattern>/abc.html</url-pattern>
		</servlet-mapping>
 - 第一个name下边写的是jsp-file,而不能写servlet-class
		因为类名我们不知道，(类名可以看work文件夹里面的.java文件，不能这样写，因为文件名不是确定的，如果我们换一个容器，那么名字可能就和tomcat生成的不一样)。
		<jsp-file>/a5.jsp</jsp-file>：表示这个servlet是由这个a5.jsp生成的
 - 其他的都和servlet一样写
		/abc.html故意写这个，是给人感觉在访问一个html文件一样
 - 配置了之后若要使用初始化参数，要访问url-pattern才可以，如果访问jsp是读取不到初始化参数的-null


##web.xml初始标签介绍
		前两行查看笔记'部署描述文件web.xml的介绍和编写'
 - 举例：
		<welcome-file-list>
			<!-- 配置首页 -->
			<welcome-file>/a1.jsp</welcome-file>
		</welcome-file-list>
 - <welcome-file-list> 欢迎-文件-列表，首页
``	<welcome-file>  欢迎-文件，配置首页(文件必须是是html或jsp)
		欢迎文件列表下面可以配置多个欢迎文件，如果第一个找不到就往下找，一个个找。
		如果浏览器请求直接访问应用名，没有写明确指定某个地址，比如localhost:8080/day11-2/		那么容器就会看这个配置，找应用名下的<welcome-file>标签中写的文件。比如写<welcome-file>/a1.jsp</welcome-file>  那么容器就会找day11-2中的a1.jsp。如果找不到就找下一个标签的文件，一直找不到就返回404
 - <display-name> 显示名。删掉
		我们有时用一些可视化的工具来管理我们的应用的时候，工具会显示应用的名字，就是这里面写的名字
		百度：当你使用编辑器编辑该文档的时候，在title处需要显示的名称。你可以改变这个名字，然后用编辑器分别打开，可以看到title的变化。


##JSP的指令
 - 结合前面的笔记和这次课堂笔记的总结一起看
 - session属性：缺省值是true,如果值为false,就不能使用session隐含对象了。
		a2.jsp。设置为false的话下面再写session会报错，可以生成.java文件，但是生成不了.class文件
		访问这个jsp的话报500错误：不能把这个jsp编译成字节码文件
		查看work文件夹可以看到没有class文件，打开java文件可以看到因为我们把session属性设置为了false，容器没有在java文件中帮我们添加获取session属性的代码，但是下面有我们写的使用session的代码
 - e.taglib指令
		用来导入jsp标签。明天先学jsp标签再讲


##JSP的注释
 - 方式一 <!-- 注释内容　-->	如果被注释的内容是java代码，java代码会执行。
		a8.jsp  
		浏览器认识html注释，java代码会执行，但是不会显示，查看网页源代码可以看到java代码被执行
 - 方式二 <%-- 注释内容 --%>	如果被注释的内容是java代码,java代码不会执行。
		这时查看网页源代码可以看到注释的地方是空的
 - `如果在java代码片段中加// 或/* */ /** */ 这属于java代码的注释，不是JSP的注释`


##小项
1. 多个线程去调用同一个方法，一定要想到四个字：线程安全。
2. 老师用的tomcat的一个工具：apache-jmeter-2.13 进行线程问题的实验。这个工具是用来模拟并发的，不要求掌握。学测试的要学。
		只写了请求名称，断口和路径。并发数量5
3. 通过加锁解决线程安全问题。虽然有性能影响，但是一般cpu切换也就十几毫秒,性能影响是有限的
4. 黑客攻击很典型的一种手段：故意访问你的网站让他抛出异常，然后分析程序的漏洞。
		所以我们要避免把这种底层的异常抛给用户看，绝对禁止。
5. 明天才讲的：pageContext的第二个作用(day13才讲)、taglib指令


#------------------------------------Servlet.day12--------------------------------------
###day12工程讲el表达式的作用和jsp标签；day12-2工程迭代day08-3工程，利用jsp标签改进listUsers.jsp
		(jsp中写java代码是为了方便演示el表达式，其实应该写在java类中)


##el表达式
		看笔记
 - 是一套简单的运算规则，用于给jsp标签的属性赋值。也可以脱离jsp标签，单独使用。
		以前不能单独使用，现在技术越来越强大了
 - 会将返回的null转换成""输出


##el表达式作用一：读取bean的属性
 - bean：javabean其实就是一个普通的java类而已。
 - 方法一用的多，简洁。方法一解决不了的情况用方法二
###el读取bean属性的方法一
		${user.username}   ${绑定名.属性名}
 - 执行过程：依次从pageContext-->request-->session-->application查找绑定名为"user"的对象`因为绑定方法的绑定值是Object对象类型`,找到该对象之后，会调用该对象的"getUsername"方法，然后输出返回值。
``		**调用的方法原理是**将user.后的username**属性名首字母大写加get**
 - **优点**：
``		a.会将null转换成""输出。
``		b.如果找不到对应的对象，不会报空指针异常,会输出""。
		绑定名写错会找不到对象，输出空串。属性名写错会报异常。
 - 指定查找范围：使用pageScope,requestScope,sessionScope,applicationScope来指定查找范围。
		比如 ${sessionScope.user.username}
###el读取bean属性的方法二
		${user[xxx]}   [] 代替 . 的作用
 - a. ${绑定名1[绑定名2]}   []里面可以出现绑定名。
		- 执行原理：${user[s1]}    pageContext.setAttribute("s1","age")
			首先找四个范围中的user，然后从四个范围找s1，然后找s1的对应的绑定值，调其 首字母大写加get 的方法。   即找绑定名为user的对象，并调这个对象的 s1对应绑定值的首字母大写加get 的方法
		- 优点是啥？
 - b. ${绑定名.属性名[下标]} `属性是数组类型，即${数组[下标]}`   []里面可以出现从０开始的下标，用于读取数组中指定下标的元素的值。
		- 执行原理：${user.interest[0]}
			找到这个数组，并取下标为0的元素
 - c. ${绑定名["属性名"]}   单/双引号均可
		- 执行原理：${user['username']}和方法一${user.username}一样
 - d.${绑定名[下标].属性} 比如集合中封装的对象，school[1].from  学校第一名同学来自哪里
###{绑定名}
 - **如果只写绑定名，返回的是绑定值**


##el表达式作用二：做一些简单的运算
		算术运算&逻辑运算看课堂笔记
###关系运算
		常规的：${1<2 }<br> 返回true
 - 补充：结合绑定
		<%  request.setAttribute("s1","abc");  %>
``		${s1 == 'abc' } 容器依次查找绑定名为s1的值
		可指定查找范围：${sessionScope.s1 == 'abc' }
###empty运算
 - 用来判断集合是否为空，或者是不是一个空字符串。返回true或false
		<%  pageContext.setAttribute("s2",""); 
		List<String> list1 = new ArrayList<String>();
		request.setAttribute("list",list1) %>
		空字符串：${empty s2 }  true
		找不到对应的值：${empty sessionScope.s2 }  true 找不到也返回true
		空的集合：${empty list }  true
		null值：${empty null }  true


##el表达式作用三：读取请求参数值
		用的并不多，了解一下。因为MVC架构，jsp不需要处理业务逻辑，不用接收请求参数。
 - ${param.name}
		等价于  request.getParameter("name");
 - ${paramValues.city}
		等价于  request.getParameterValues("city");


##jstl (jsp standard tag lib) jsp标准标签库
		sun只定义了jsp标签技术规范，怎么写怎么用都规范好了，但是他一个标签都没写，需要公司自己写。这样就造成重复开发。于是apache开发了一套常用的标签，涵盖了大部分需求，一百多个标签。
		一开始没有名字，一堆标签，可以去apache官网下载去用。sun公司在发布javaee5.0的时候，当时javaee5.0企业级应用缺东西，不丰满。sun让apache捐献给自己用。好处就是给他命个名。。。apache很开心地捐献给了sun,sun将其命名为jstl。
		apache和sun的公司很不错，每当sun推出一些规范的时候，apache就迫不及待推出一些实现。现在apache和java疏远了，因为apache瞧不起oracle，oracle什么都想收费。所以以后java的发展还是看亚马逊
 - 以后用标签有这么三大类：apache的标准标签、一些框架自带的标签、公司内部开发的标签。
###如何使用jstl
 - 导入jstl的jar包，就在maven镜像库搜jstl即可，课上用1.2的jar包
		<dependency>
			<groupId>jstl</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		jar包内有标签类(java类)，我们只要会用标签即可
 - 使用taglib指令引入要使用的jsp标签。
####taglib指令的写法
		taglib指令的本质，告诉容器从哪一个描述文件中找用的标签对应的java类
		<%@ taglib uri="" prefix=""%>
 - uri属性：指定要引入的jsp标签的命名空间。 
		为了区分同名的元素在元素前添加的一个限定，通常是一个域名(为了避免命名空间也冲突)。
``		打开工程文库Libraries-->Maven Dependencies-->jstl-1.2.jar-->META-INF-->c.tld
		每个.tld文件都对应了一堆标签，核心标签在c.tld。我们要学的就是核心标签。tld文件：标签的描述文件。从文件的第一行可以看出这其实就是xml文件。
		容器看到标签以后，要知道这个对应的标签类(java类)是谁，这时容器就会查询描述文件，找对应标签的标签类(java类)
		c.tld: 11-12行有这么两行标签：
					<short-name>c</short-name>
					<uri>http://java.sun.com/jsp/jstl/core</uri>
``		uri就是要在taglib的uri的值，prefix是推荐的别名。别名可随意
 - prefix属性：命名空间的别名。
		命名空间通常是域名，很长，取别名简洁
###理解容器对jsp标签的执行过程
``		看day13笔记'JSP标签的执行过程'
 - 首先容器根据别名，去taglib指令找uri命名空间。
		因为容器有这么一个需求：他要知道标签对应哪一个标签类(java类)。这就需要去标签地tld描述文件去找，但是tld文件也不止一个。每一个描述文件的命名空间都不一样。
``		每一个命名空间都对应了一个描述文件。
 - 通过命名空间找到对应的描述文件后，根据标签名找到对应的标签类(java类)
		比如60行:  if标签对应的标签类(java类)
			<name>if</name>
			<tag-class>org.apache.taglibs.standard.tag.rt.core.IfTag</tag-class>
 - 找到标签类，容器就会调用类中的java代码了。
 - 标准标签库中的标签名我们也可以自己写，如何让容器知道掉的是我写的还是标准库中的，就需要命名空间了。


##jsp标签
###if标签-表示if-else的写法
 - if.jsp & 图if.png
		jsp标准标签库中没有专门的else的标签
 - 表示if-else的写法一：
		这种用的比较多
		<c:if test="${user.gender == 'm' }">男</c:if>
		<c:if test="${user.gender != 'm' }">女</c:if>
 - 表示if-else的写法二：
		特殊写法。用的不多，了解即可
``		var指定绑定名，scope指定绑定范围，可以是：request page(表示pageContext) session application 
``		<c:if test="${user.gender == 'm' }" var="rs" scope="request">男</c:if>
			这行代码等价于：request.setAttribute("rs",false);绑定名是var的值rs，绑定值是test属性的值
``		<c:if test="${!rs }">女</c:if>
		即非false，则输出女
###choose标签
		choose.jsp
 - 相当于if-else if-else if-...-else
 - 语法
	<c:choose>
		<c:when test="">		`when:当...时候；当后边写的条件成立。此标签至少出现1次
		</c:when>
		...
		<c:otherwise>			`相当于最后一个else。可以出现0或1次
		</c:otherwise>
	</c:choose>
 - 当test属性值为true时，执行标签体的内容。when和otherwise不能单独用，必须嵌套到choose里才能用。
###forEach标签
		看forEach.jsp，看课堂笔记
 - varStatus属性：用来指定绑订名。绑订值是一个对象，由该标签内部创建，用来获得当前遍历的状态，
		以VarStatus="s"为例
``		${s.index}，经常当作变量来用；绑定名s.属性index，容器会依据绑定名s找到绑定值对象，这个对象是标签内部自己创建的
		getIndex():用来获得当前正在被遍历的元素的下标(从０开始)
``		${s.count},通常用来给表格生成序号；
		getCount():用来获得当前遍历的次数(从1开始)。


##小项
1. 写代码的时候，开发工具帮我们检查错误用的是java反射机制。java反射很耗费内存，所以比如jsp，就经常反应不过来，写对的代码会标红线，但是项目不报错，重新打开一下即可。
2. 回头看一下out.writer的api，为啥我故意用out.writer输出null会报错
3. JSP标签：平时我们开发的时候很少去自己写一个标签，因为jsp标签技术发展了很多年了，有很多常用的现成的标签。
4. 书：jsp相关的，比如从入门到精通。正确的方式是学习核心的，都学不一定用，万一忘了就学新的


#------------------------------------Servlet.day13--------------------------------------
###利用jsp标签改造day12-2工程的所有jsp(不多，十分钟改完了)；
###day13工程讲自定义标签，然后用自定义标签改造day12-2工程的header.jsp；
###day13-2工程讲MVC；day13-3工程迭代day12-2工程，将所有jsp移动到WEB-INF下


##自定义标签
 - 结合'HelloTag.java'&课堂笔记
 - 自定义标签不是重点，旨在让我们了解jsp标签的执行原理
###step1. 写一个java类，继承SimpleTagSupport类。
		注：继承SimpleTagSupport类开发的标签属于简单标签技术。
		常识：jsp标签技术有两个版本：早期-复杂标签技术；现在-简单标签技术。老版的虽然很强大，但是开发起来很麻烦，所以sun公司制定了新的技术规范-简单标签技术，要继承SimpleTagSupport
####JSP标签的执行过程：
 - 容器根据标签的别名，通过taglib指令找到命名空间。然后通过命名空间找到标签的描述文件。
		描述文件中有标签的名字和标签类的对应关系。
		容器通过命名空间找描述文件时，会从WEB-INF以及jar包的META-INF下找
		命名空间就是一个字符串，写什么都行，为了避免重复才写成域名
 - 容器通过描述文件找到标签对应的标签类，然后通过java反射将标签类实例化，创建对象。
 - 容器将对象创建好之后，将标签的属性值`通过调用对应的set方法`赋给对象的属性。
		如果属性值是el表达式则先计算再调set方法
		标签有哪些属性，标签类也得有对应的属性，数姓名要一样，类型要匹配，并且有对应的set方法。
		get方法可以没有，但是set方法一定要有
 - 最后容器调用doTag()方法
###step2. override doTag方法，编写处理逻辑。
 - 获取out对象--**PageContext作用二：获得其它所有隐含对象**
 - 获取PageContext：继承SimpleTagSupport，他的JspContext()方法可以获得PageContext
``		需要强转：PageContext pctx = (PageContext)getJspContext();
		过度设计的产物，返回类型是JspContext，JspContext是Pagecontext的父类，所以强转
###step3. 在tld文件当中描述标签||tld文件的介绍和写法
``		看'mytag.tld'
 - tld文件要放到WEB-INF下
		或者在WEB-INF下建一个子文件夹，放到子文件夹中。
``		如果以后要打成jar包，可以放在jar包中的META-INF文件夹中
		(容器通过命名空间找描述文件时，会从WEB-INF以及jar包的META-INF下找)
``		文件名没有要求，但是后缀要求是tld
			sun规范，标签的描述文件要是tld
**tld文件中的元素**：
``		1. xml声明、根源素可以从c.tld完整拷贝过来
``		看笔记'部署描述文件web.xml的介绍和编写'
		.tld描述文件必须有xml声明以及taglib根源素，这是sun的规范
``		2. 从c.tld拷贝过来&修改
		<description>描述</description> 比如标签写完别人要用，描述作为对标签的大体介绍。类似于注释说明
			可删除
		<display-name>JSTL core</display-name> 没说，看笔记'display-name'。
			可删除
		<tlib-version>版本号</tlib-version> 可以给标签自定义版本号，一般企业有版本控制的规范
		<short-name>(推荐的)别名</short-name> tld推荐的别名和jsp中写的别名最好一样，不一样也没关系
		<uri>命名空间</uri>
``		3. 从c.tld拷贝过来一段标签描述&修改
		<tag>
			<description>描述这个标签是干什么的</description>
				可删除
			<name>标签名</name>
			<tag-class>对应的标签类完整的类名，包名.类名</tag-class>
			<body-content>empty</body-content>
				<!-- body-content是用来告诉容器，标签
				有没有标签体，如果有，可以出现哪些内容。
				有三个值：
				empty：没有标签体。
				scriptless：有标签体，但是，标签体里面不能
							够出现java代码。
				JSP：有标签体，并且标签体里面允许出现java代码
				但是，只有复杂标签技术才支持这个值。 -->
					之所以新技术(简单标签技术)不支持写java代码，是因为我们用标签的目的就是不写java代码
			<attribute>  attibute:属性，标签中的属性也要描述。有几个加几个
				<description>相当于注释</description>
					可删除
				<name>属性名</name>
				<required>属性是否是必选的</required>  required：必需的。
					true or false
				<rtexprvalue>是否可以动态赋值/是否支持el表达式</rtexprvalue>  Run-time Expression Value自定义标签属性
					true or false
			</attribute>
		</tag>
**不要遗漏任何的结束标签！！**


##MVC：Model-View-Controller(模型-视图-控制器)-系统讲
``		纯补充。看课堂笔记'# 2.MVC'；笔记搜索'##MVC'
 - 图mvc.png
 - 基本都是用Servlet当作控制器。
		有一些mvc框架比较特殊，比如Struts2，用的是过滤器来充当控制器的。
 - 表示逻辑还可以细分为两部分
		- 处理结果要以合适的方式展现出来--输出
		- 用户使用系统的页面--输入
 - 一般来说最重要的一个模块就是Model
		先写Model，再写jsp，再写控制器
		一般是这样的顺序，写完一个测试一个。企业开发中可以分工同时进行。
 - 成恒补充：Model=Dao+Service
		DAO：Data Access Object 数据访问对象，做数据的增删改查
		Service：业务逻辑类，做一系列的判断，判断是否运行做某些事情。
					不是servlet里的service方法
		由这两个部分保证数据的安全和有效
 - 优缺点a.方便代码的维护。
		(模型返回的处理结果，可以使用不同的视图来展现。这话不好理解)
		比如：视图变化，对model没有影响；model变化，对视图也没影响
 - 一般来说企业做软件都会用MVC，就算是规模小的成本低，开发简单，但是不好维护，长期发展也要用MVC
 - 成恒补充：**MVC是一种(分角色的指导)思想**,他指导我们数据的处理流程中至少应当有三个角色。角色分清除，分工合作，就会有效地将低耦合度，便于代码地维护和修改。


##WEB-INF||避免用户直接访问jsp
		把jsp藏起来
		按照MVC的思想，jsp本身就不是一个完成的程序，理应不给用户看。
 - 方法：将jsp放入WEB-INF文件夹中
		按照Servlet规范，WEB-INF下的所有数据，浏览器不能直接访问
		打开tomcat-->wtpwebapps-->dayxx-->WEB-INF：有这个文件，但是浏览器访问不了。因为容器不让访问WEB-INF里的数据。
 - 百度百科：**WEB-INF是Java的web应用安全目录**。
		INF是 DEVICE INFormation File 设备信息文件 的英文缩写
		所谓安全就是客户端无法访问，值有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应的映射才能访问。
 - 以后所有请求不再出现.jsp，全部.do交给控制器处理。
		转发不需要非得绑定数据，只是一个web组件通知容器去调用另外一个web组件。
 - 注意：重定向、链接的地址也都是浏览器发送请求。
		也不能直接访问WEB-INF的数据，应当都改为向控制器发请求的地址
		如果要用重定向访问WEB-INF下的jsp，那重定向的地址不能是jsp，而应该是.do的形式，使浏览器向服务器再次发出请求。终究还是被服务器转发到jsp


#------------------------------------Servlet.day14--------------------------------------
###smartmvc01工程reflect包讲反射和注解，其余讲MVC；
###smartmvc-lab练习，并改进，之后老师在smartmvc01工程改进了


##java反射和java注解
 - 几乎所有的java框架都离不开java反射；最新的框架离不开java注解，因为注解更轻量，并且写配置文件更方便
 - 只学/回顾和框架有关的
###java反射
		看范传奇反射包以及搜索笔记相关记录
		看smartmvc01工程reflect包中A.java,B.java,TestCase.java,TestCase2.java
 - newInstance()方法
		范传奇讲的，看笔记'newInstance'
 - Class.forName()方法的原理
		通过java反射加载类：JVM(java虚拟机)委托类加载其查找类的字节码文件，然后将字节码文件的内容读到方法区，然后将这些内容转换成一个对应的class对象。看下边笔记'###类加载过程'
 - java语言中，任何类型在方法区中都有一个对应的class对象，包括基本类型也有。
		String.class   int.class
 - Method对象封装了方法的所有信息，比如方法名、参数类型、返回类型等等。
		范传奇SE反射包ReflectDemo1.java&程祖红TestCase.java
		获取当前类自己定义的方法(不含有从父类继承的)：Method[] methods = cls.getDeclaredMethods();
		获取当前类的所有方法(包括从父类继承的)：Method[] methods = cls.getMethods();
``		获得参数类型：Class<?>[] getParameterTypes()
		见TestCase.java，用变量.length来判断方法的参数个数，如果为0则不带参,>0则带参
``		获得方法名：String getName()
		TestCase2.java
 - invoke()方法
		范传奇：Object invoke(Object obj, Object... args)
			Method的invode方法是用来执行当前Method表示的方法，需要传入的参数有两个：
			1：方法所属的对象
			2：实参(若该方法没有实参，可以不传入)
		程祖红：有返回值，返回值是目标方法的返回值,类型是Object。
			TestCase.java 第二个参数是一个对象数组
###类加载的过程示例讲解：
		Student s1 = new Student("Sally");
		s1.study();
		Student s2 = new Student("Kitty");
		s2.study();
 - Java虚拟机(JVM)会把操作系统分配给他的内存空间划分成：堆(只有一个)、栈(一个线程一个栈)、方法区(只有一个)三种区域。
 - 当jvm运行到第一行Student的时候，会看方法区里有没有Student的类型信息，即看方法区中有没有Student类对应的class对象，显然第一次运行没有。
 - 这时jvm手下有一个很厉害的角色，**类加载器**ClassLoader：类加载器的主要工作就是去找这个类的字节码文件。
		字节码文件在硬盘存放
 - jvm委托**类加载器先找到Student类的字节码文件，将文件内容(硬盘里)读到方法区里面(内存里)，然后再把这些内容转换成一个对象--即class对象**
``		**class对象：是java反射里最重要的对象。可以当成是字节码文件在内存当中的对应物**(字节码文件在硬盘上是个文件，在内存中是个对象)
		Class.forName()就是让类加载器去完成类的加载，即会根据类名去找到类的字节码文件，将文件内容读到方法区里面(内存里)，然后再把这些内容转换成一个对象
 - 运行到s1：jvm将s1变量放到栈中
 - 运行到new Student("Sally")：将Student对象放到堆中
``		**这个对象的属性值，包括名字"Sally"都是在堆中存放**
 - 第一行执行完(最后执行=吧)，s1变量会指向堆中对应对象的首地址(s1中存放这个地址)。
		并且在Student对象中，存放有方法区中class对象的地址，我们可以通过Student对象，找到方法区中对应的class对象。
 - 第二行执行：jvm通过s1找到堆当中的对象，然后执行方法区中的study方法中的代码
``		**方法的代码均在方法区中存放(减少内存开销)**
 - 第三行Student执行：虚拟机运行到这行，会发现方法区中有Student类对应的class对象。
		类只加载一次
 - 然后jvm将s2变量放到栈中，在堆中再创建一个叫Kitty的Student对象，并让s2指向此对象。
		并且kitty中有个指针也指向了方法区中对应的class对象
 - 最后s2.study，jvm通过s2找到堆当中的对象，然后执行方法区中的study方法中的代码
###java注解
		reflect包中Test.java,C.java,TestCase.java
		注解不影响原有代码的运行，加注解可以通过反射对方法的运行加一些额外的影响
 - 写一个java注解：New Annotation
		注解的名字和类名接口名要求一样。别的没多说，Modifiers是public 不知道是干啥的！！！？？？
 - 注解可以加在方法、类、参数前面都可以
		我们只加在方法前，不多讲。。。
 - getDeclaredAnnotation(xxx)方法。文档：返回直接存在于此元素上的所有注解。
		TestCase3.java。  参数为注解的class对象：
``		`在java中所有的类型都有一个对应的class对象，`**注解也有对应的class对象**
 - 注解加在源代码以后，默认只会保留在字节码文件中，一旦运行就会被抹掉
``		解决方法：@Retention(RetentionPolicy.xxx)，xxx分别对应注解的三个生存时间
		默认是CLASS：保存到字节码文件，运行就没了。
		最短：SOURCE：保存到源代码，编译就没了。
``		最长：RUNTIME：保留到运行时。
		@Retention是元注解，即用来解释其他注解的注解。
 - 注解的属性：注解的属性。可以有多个属性，如果只有一个属性且属性名为value，则在使用时可以不指定属性名。
		看Test.java；   注解的属性看起来像是一个方法一样，但并不是。
		属性名为value：   public String value();	-->  @Test("淡淡")
		属性名不为value： public String abc();  -->  @Test(abc="阳阳")


##MVC框架(smartmvc)
 - 框架：高质量的软件的半成品。
		写好了很多常见的代码。
		- Spring 作者 Rod Johnson 音乐博士，爱好：写代码
		- mybatis 访问数据库的
		- SpringMVC 是Spring的一个模块，是MVC框架
 - 今天的smartmvc是模仿SpringMVC写的。通过smartmvc的学习，我们可以把知识融汇起来，包括反射、注解、Servlet、jsp。
###整个框架组件的关系&图解smartmvc.png
		我们以后要学SpringMVC，所以我们现在故意把一些类名、变量名等写得和SpringMVC一样
 - 概述：DispatcherServlet(控制器)负责接收请求，然后依据HandlerMapping(映射处理器)提供的信息调用对应的Controller(Model,处理器)来处理。
		DispatcherServlet模仿SpringMVC中控制器的名字。相当于我们写得用户管理的ActionServlet
 - 详解：按照MVC架构思想，控制器收到请求后要调用Model处理，但是框架是和具体业务无关的，具体调哪个Model事先不知道。这时就要利用反射：
		我们是框架的作者，这时我们可以要求使用我们框架的程序员要按照我们的约定来写代码。
``		我们可以先要求程序员在写Model(处理器)的时候这么写：
		类名方法名注解名等不作要求，我们模仿SpringMVC
``			public class HelloController(){		`在框架里我们把这个类叫作处理器，其实就是Model`
				要求使用框架的开发人员在类的方法前面加上注解。注解的属性是value，属性值是请求路径。即如果请求地址是这个，则这个注解下面的方法来处理，并且要求方法的返回值是字符串。
``				@RequestMapping("/hello.do")
``				public String hello(){
						方法内写业务处理逻辑...
						最后要返回一个视图名(字符串)。当控制器调了模型之后，模型返回一个视图名给控制器，控制器会会按照"/WEB-INF/"+视图名+".jsp"来生成jsp的地址
``						return "hello";
``					}
``				}
``	`那么请求过来后，控制器怎么知道调用哪个Model来处理：`我们可以提前利用java反射，把请求路径("/hello.do")和处理器(HelloController())以及方法(hello())的关系建立起来。
``	这个对应关系我们可以委托一个特殊的对象HandlerMapping(映射处理器，负责提供请求路径与处理器的对应关系)，由HandlerMapping负责解析处理器当中的注解，并在初始化方法init()中就应该做好。
		HandlerMapping相当于是控制器的秘书，是控制器抽出来的一个功能。
``	但HandlerMapping还并不知道我们在开发中添加的处理器。这时应当添加一个配置文件，使用框架的开发人员把开发中写的处理器的类名在配置文件中配置一下。
		src/main/resources/smartmvc.xml
``	控制器去读取配置文件，就知道了有哪些处理器，然后利用java反射把处理器实例化之后交给HandlerMapping来解析请求路径和处理器的对应关系。
		不实例化的话HandlerMapping就找不到我们写的处理器，没法解析。
		使用dom4j读取配置文件


##MVC框架-控制器之DispatcherServlet-init()
		DispatcherServlet.java
		实现一个简单的web mvc框架，其核心是一个可以重用/通用的控制器。基于该框架开发一个web应用，只需要写模型和视图。
		控制器是DispatcherServlet+HandlerMapping
 - 在init()方法中解析配置文件，并将控制器配置启动加载
		web.xml中，<load-on-startup>1</load-on-startup>
		容器启动后马上把控制器实例化，紧接着调用初始化方法。这样请求到达之前这些事就都做完了。
 - SAXReader的read()方法中传入的是一个输入流。
		使用dom4j  对范传奇讲的稍有补充,主要情况还是看看范传奇的
``	获取输入流：和jdbc读取配置文件一样
		getClass().getClassLoader().getResourceAsStream("smartmvc.xml");
		getClass()：继承自Object,获得此对象对应的class对象(方法区里的对象)
		getClassLoader()：获得类的类加载器
		getResourceAsStream(xxx)：是类加载器的方法。返回读取指定资源的输入流。
			这个的路径应该怎么填，从哪个目录开始填！！！？？？
 - 为了方便对对象的管理，将处理器实例放在list集合中。保存好后交给HandlerMapping建立请求路径和处理器的对应关系


##练习
 - **写MVC框架的步骤很重要，见课堂笔记**
 - 改进：增加框架的灵活度
		把文件名配置成初始化参数，在web.xml中加<init-param...标签，以后开发人员在这里把配置文件名改一下即可。


#------------------------------------Servlet.day15--------------------------------------
###smartmvc02工程迭代smartmvc01工程
###smartmvc-lab练习

##mvc.png图解
 - 2 创建处理器的实例，并放在List集合中
		昨天的笔记有：为了方便对对象的管理将对象放在list集合里面。保存好后交给HandlerMapping建立请求路径和处理器的对应关系
 - 4&5 创建HandlerMapping对象，调用这个对象的proess方法
 - 6 利用Map创建对应关系
 - 7 序号7之前的全部都是容器一启动就做好的事。


##MVC框架-控制器之HandlerMapping(映射处理器)
``		这个难度最大
		HandlerMapping.java & Handler.java
		实现一个简单的web mvc框架，其核心是一个可以重用/通用的控制器。基于该框架开发一个web应用，只需要写模型和视图。
		控制器是DispatcherServlet+HandlerMapping
 - HandlerMapping相当于是控制器的秘书，是控制器抽出来的一个功能。
		映射处理器：负责建立请求路径与处理器的对应关系。
			比如说"/hello.do"请求，应该调用HelloController的hello方法
 - 用Map存放请求路径与处理器的对应关系。key是请求路径 ,value是处理器方法对象和处理器对象。
		并把处理器方法对象和处理器对象封装成Handler类。
``		因为invoke()的执行需要：	method.invoke(obj)	
			method是方法对象   obj是方法所属的对象即处理器对象
			只有处理器对象没办法调方法。
 - **注意**：读取注解的属性值，是调用的Method的方法。而前面Method[]取得了处理器类中所有的方法。所以如果有方法不写注解，运行时就会报错。**处理器中的方法必须写注解**
 - 将请求路径与处理器的对应关系保存到Map里
``		maps.put(path, new Handler(mh,bean)); 
		path是注解的属性值；mh是方法对象Method；bean是处理器对象。


##MVC框架-控制器之DispatcherServlet-service()
 - 去掉应用名，就是去掉了 /smartmvc02
 - 如果路径写错，则handler为null，所以要判断
 - mh.invoke(obj) 的try-catch就捕获一个Exception即可，没必要捕获这么多。
``		java有个地方设计的不是很好，就是异常的设计非常繁琐。
			很多异常根本就不会发生，除非代码写错。但是代码都是要经过测试才上线运行，测试完再上线，代码就不会写错。所以这些异常根本就不用考虑，
			比如	非法访问异常：把方法写成私有的，别的类就不能调用
				非法参数异常：参数类型写错
 - response.sendError(404):发送404状态码给浏览器


##MVC框架-处理器
 - 如果要求重定向到jsp，则重定向的地址应该是.do的形式。因为jsp在WEB-INF下不能直接被访问，终究还是重新请求服务器然后服务器去转发到jsp。
		可能只是为了多一次请求次数吧？。Logincontroller.java


##练习
 - 写一个使用smartmvc的文档：
1.你只需要写你的处理逻辑和表示逻辑：表示逻辑jsp写在WEB-INF下；在src/main/java下写你的处理器类。
2.处理类要求这么写：
	你要在方法前加上@RequestMapping(xxx)注解，注解的属性名是value所以你可以直接写属性。
		属性要求是：调用这个方法的请求路径并去掉应用名。
	方法可以用HttpServletRequest request和HttpServletRequest response两个参数，你需要用的话就写上，不用可以不写。
	方法有String的返回值，要求是视图的名字。
		如果你需要转发，则直接return 视图名
		如果需要重定向则return redirect+请求路径
3.在src/main/resources下有一个xml文件，将你写的处理器类名写在这里面
		你可以给这个文件改名，改了名后在web.xml下改一下param-value内的属性
4.**我理解能力还是太菜了，看老师写的--day16课堂笔记**


#------------------------------------Servlet.day16--------------------------------------
###1.16号 第一节课；  smartmvc-demo用来演示别人如何使用我们写的smartmvc框架(步骤见课堂笔记)。


#----------------------------------程祖红Spring.day01------------------------------------
###1.16号 除第一节课；  spring-day01工程讲spring；spring-day01-lab做练习
		今天spring工程是jar包，明天成恒用的war包


##Spring的来历
 - 牛人：Rod Johnson 秃顶 音乐博士，爱好编程
 - Sun公司当时出了一个j2ee企业版(现在叫javaee)，里面有个ejb技术，当年非常火。可以解决企业级开发很复杂的问题，但是这个技术非常复杂，一般人不好掌握。
 - Rod Johnson 说你这个太麻烦，我帮你简化一下
		起名叫Spring春天，意味着用我的技术，春天来了。
 - Spring框架把ejb技术封装了，我们间接去使用，更加方便。


##Spring介绍
 - 是一个开源的、用来简化企业级开发的应用开发框架。
``	开源的安全、灵活
		安全：可见源代码，知道底层都干了啥
		灵活：可以改
 - 一站式框架：用了他别的就不需要用了。因为Spring对很多常用的框架提供了集成的机制。
		比如要做任务调度：集成一下Quartz框架。这个框架很简单，只负责任务调度
 - Springjdbc是Spring的一个模块
###优点之管理对象：IOC 理解
		结合成恒讲的去理解
 - IOC：对象之间的依赖关系由容器来建立		原本：对象之间的依赖关系由对象本身来建立。
 - 举例：我现在有两个类A&B：B中有个方法f2()，A中想用这个方法要：B b = new B(); b.f2();
			这么写有个小瑕疵：如果一个非常复杂的系统这么写就会有问题。
 - 软件开发的设计准则：一个高质量的软件模块之间应该'低耦合'。
			低耦合：两个模块之间不要互相依赖
 - A调B就是高耦合，修改麻烦。比如现在A已经写完了。由于某种原因要让A改为去调C的一个方法，这时候就得改源代码，然后重新测试。
 - 但是我们要做到：'对修改关闭，对扩展开放'。避免A和B直接依赖。
 - 在Spring框架中，A调B的方法我们不这么写(new)了，框架帮我们建立两个依赖的关系。只需要在配置文件说明一下A需要B，那么Spring就会帮我们把B传给A，在A中就可以调B的方法。如果以后要调C的方法，改配置文件即可，不用改源代码。
``		这个思想在业界很早就有了，叫IOC。Spring把它用到了极至


##启动Spring容器
 - step1.导包
	- 导包的时候，我们一直搜索的其实就是groupldId
		导3.2.8版本的，这个版本和PPT教材一致
		Spring有特别多，好几百个jar包，我们这次导入的有9个
 - step2.添加配置文件
	- 配置文件的模板在当天的压缩包applicationContext.zip以及课堂笔记都有
		压缩包解压后直接把applicationContext.xml复制到src/main/resource中
	- 第一行是xml声明；第二行beans开始到结束是根元素，里面都是属性
		属性是对文件的约束，即在这里可以写哪些子元素，都要遵循这个约定(约束条件)
 - step3.启动Spring容器
	- 需要写代码启动，建包建类 FirstSpring.java


##创建对象
		课堂笔记
###方法一：使用无参构造器(重点掌握)
		对象是通过构造器创建的，它说了很多遍了
		配置文件&FirstSpring 
 - Spring容器解析配置文件，读取类名，利用java反射通过调用构造器创建对象。
 - step1.为一个类提供无参构造器（缺省构造器）
		括号内的意思是：或者使用缺省构造器。即不写构造器；
``		写不写都行，写了我们可以加输出语句看到被调用了
 - 方法：依据id获得对应的对象：
		第一个参数是bean的id。
``		getBean("a1") 返回值是Object类型，需要做强转  Apple a1 = (Apple)ac.getBean("a1")
``		getBean("a1",Apple.class); 这个重载的方法，第二个参数是对应的class对象。不用做强转
 - 控制台：	如果配置文件的类名写错会报：类无法加载；
``			如果id写错，比如：没有叫a2的bean；
``			都不是ClassNotFoundException
###方法二：使用静态工厂方法(了解)
		配置文件&Test.java&FirstSpring
 - 方法一的配置文件写法是使用无参构造器来创建对象。但是抽象类没有构造器，也就不能这么创建。
		比如Test.java中的Calendar，传奇讲过，很详细，日历类是一个抽象类
			Calendar.getInstance();返回的是Calendar的一个子类GregorianCalendar，这个子类是实现类
 - 使用抽象类在配置文件中应该加一个属性：factory-method属性：用来指定静态方法名。
		Spring容器会调用该类的这个静态方法来创建一个对象。
		factory-method="getInstance" 这就相当于这段代码：Calendar.getInstance();
###方法三：使用实例工厂方法(了解)
		配置文件&Test.java&FirstSpring
 - Spring容器会调用该bean的实例方法来创建对象。
		factory-bean属性：指定要调用的bean的id；
		factory-method属性：指定要调用的实例方法。
				factory-bean="cal1" factory-method="getTime"
				调用id为cal1的bean的getTime方法创建对象
		相当于：Calendar cal1 = Calendar.getInstance();
				Date date1 = cal1.getTime();	实例方法getTime()返回值是Date对象


##单元测试
 - 导入了一个Junit的jar包，单元测试，和国斌那个不一样吗。
		国斌那个不找坐标导包啊，直接写上@Test，然后就出来一个Junit4的东西。和Maven Dependencies并列的。程祖红这个是在Maven Depend..里边的
 - 执行方法一：Window-->Show View-->Outline大纲-->右击类下的test()1-->Run As 以什么方法运行-->JUnit Test
		点一次Outline之后就出现在控制台旁边了
 - 在控制台图标旁边有一个绿勾/红叉加上绿J和红U的图标，这是JUnit的控制台：绿色表示测试通过了
 - 执行方法二：双击方法名选中-->右击-->Run As-->JUnit Test
		双击应该就是为了确保选中吧。国斌都是点一下


##bean的生命周期
		方法名叫啥都行，不必须是init/destroy，这是习惯用法
 - a.初始化方法
		配置文件里添加init-method属性：用来指定初始化方法。
		init-method="xxx" 告诉Spring容器xxx方法是初始化方法
 - b.销毁方法
		配置文件里添加destroy-method属性：用来指定销毁方法。
		Spring容器关闭之前，会删除它所管理的bean,在删除bean之前，会调用destroy方法。
		销毁方法只针对作用域为singleton的bean。
``	设计ApplicationContext接口的时候，并没有给这个接口设置关闭容器的方法(colse方法)。所以声明的时候用ClassPathXmlApplicationContext声明。
		TestCase.java
``	销毁方法只针对作用域为singleton的bean。


##小项
1. New maven工程这两天讲一个个小的模块，没必要部署到Tomcat里运行，都是一个个java类，周五再改成war包
2. 以后工作当中，建议把测试类写在src/test/java下面，这些类最终不是给用户用的，是我们开发用的包和类。
``		**以后用maven帮我们打jar包的时候可以把这个包排除开外。**不参与编译打包
3. 我们在test下建的包本来叫test，在TestCase.java中写的@Test
``	而在main也有个包叫test，包下有个类叫Test。、
``	好像是因为这个重名啥的。。导致TestCase的@Test注解报错。所以把包名改成了test1
		不过TestCase类的作用域讲完后，我把包名改成test又不报错了。。。而且还能正常运行--然后成恒又说了一下，看'测试类不要叫Test'
4. bean的作用域：scope属性 应用中大部分都是缺省值，即单例
5. 架构师写接口的，有责任
6. bean的延迟加载(了解)  一般不用


#-------------------------------------SPRING.day02--------------------------------------
###工程名SPRING-02-IOC
		添加依赖的时候：成恒老师说3.2.8版本有点老了，用4.3.9版本的。只改版本号即可，那两个id这两个版本是一样的；推荐现在开发最好用4.xx.xx版本的。因为从4开始有一些新的实用的东西出现。最近几天用不着。
		成恒老师的课spring是war包。说war包表示的是web项目，但是并不是选了war包就必须写web项目。所以不用设置Tomcat容器。除非要用到Tomcat的东西(比如day03的生命周期注解)


##对昨天的补充
 - 检查Spring配置文件的类名有没有写错：按Ctrl，指针移上去有下划线，点击可以进入对应的类。
		写错的话没有下划线
 - 为什么测试类写在test包下：1.区分地清楚；2.test里的不参与最终的编译打包
 - 测试类不要叫Test，因为单元测试的注解也叫Test；会冲突。
		叫xxxTest或Testxxx
 - 从容器中获取对象：建议用带参数的getBean(xx,xx.class)
``		能不强转就不强转。因为写了强转，代码以后就这样了，强转的语法是不能改的，失败了程序崩掉；而方法里的代码是可以改的，以后可以优化。
		如果写在第二个参数，可能在某些版本更新中只需要重写getBean方法，如果在getBean方法中判断类型不匹配可以做一些补救措施。。
		并且经过我们故意把配置文件的类名写错：发现强转失败和第二个参数报错的异常是不一样的。
 - ApplicationContext的关流close()，使用声明AbstractApplicationContext去关流
		声明的时候，能用大的就用大的：接口>父类  太大的也不行，太大的比如Object，没有close()方法
###Ioc(Inversion of control：控制反转)
		结合程祖红讲的去理解
 - 用了Spring后，我们就不用再new对象，Spring帮我们去创建；我们写getBean()
		User user = new User();--->User user = ac.getBean("user",User.class);
 - Spring创建好了后，就把对象放在那里，什么时候想用写getBean()就可以。
			延迟加载知识回顾：Spring容器启动之后，会将所有作用域为"singleton"的bean实例化。
 - 所以说Spring叫作容器。因为它装了好多对象。
		能放东西的就叫容器
 - ApplicationContext加载了Spring配置文件以后，**一边去解读配置文件一边创建对象**
``		所以**spring配置文件，任何一个地方配错了，导致无法创建配置的对象的话，那么整个文件就是错的**
		整个加载就是错的，那么即使使用配置对的对象也是会报错。容器就启动不起来
 - 控制反转：把控制权交出去。我们不再去控制，交给框架去控制。
		以前控制权(操作权)在我们的java程序(代码)中实现；现在把操作权交出去了，只是给一个配置，但是对象什么时候创建、属性什么时候赋值我们都不管了，这就叫做控制反转。即
 - IoC核心是：对象的管理；但还有个很重要的是：属性的值从哪里来
		因为单纯的把对象new出来，意义不大。new对象的语法很简单。我们没必要靠spring去new
``		Spring更重要的作用是帮我们把属性的值确定下来：在我getBean()的时候，对象的属性会有我配置好的值,即今天要学的'为属性注入值'
 - 总述：控制反转：写配置文件就叫控制反转。不用自己new对象，也不用自己调方法设置值，而是通过配置交给容器搞定。


##通过SET方式为属性注入值
		看笔记
 - <property>节点的`name`的值可以理解为属性名称。但其实是类中的属性对应的SET方法名称中`set`右侧的名称且首字母小写。`看笔记`
		因为Spring框架其实就是根据你配置的name属性的值组装出了set方法的名称并调用，即name="age" value="23"-->setAge(23)
		而Set方法应该是通过Eclipse这种开发工具自动生成的，Set方法的名称是规范的，与Spring框架使用的规则是相同的。
``		所以，只要能保证SET方法的名称是规范的，不必纠结`<property>`中的`name`属性到底指的是什么。说是指属性名称也对。


##index和position(pos)
		不成文的规定
 - 如果某个变量名字叫作index，那么应该是从0开始的；遵从开发规范、正经开发的，index都是从0开始的
 - 目前学过的唯一index不是从0开始的只有xx.setString(1,"xxx") jdbc中预编译给?赋值，从1开始
 - 如果某个变量叫position或简写pos，也是从0开始的


##xml-xsd/dtd文件 & Alt+/提示 & XML Schema代理服务器的使用
		课堂笔记是'关于解决XML文件无法自动提示的问题'
 - xsd/dtd是规范当前xml的语法格式的，约定xml的属性、标签、取值等怎么写。xsd/dtd文件从它前边对应的网址下载。
 - 如果Alt+/看不到提示，意味着电脑当中缺少相关的xsd/dtd文件；很有可能是连不上对应的那个网址。
 - xsd/dtd里的网站，这样的正经网站应该是没有被大中华局域网墙掉。但是国外的网站太远，连接地很慢
		距离远意味着经过的路由越多，中间的某个路由很忙，或者某个路由检查项多；一般连接到国外经过几十层路由很正常。中间经过的设备以及设备对数据的处理是导致慢的原因。
 - 在教室里的电脑是不会访问不到的，因为苍老师把这些文件都下下来了。我们要从eclipse配置，让网站转换到达内的网站即可。
``		达内**开发文档：XML Schema代理服务器使用**,逐一替换一下访问的网址
		设置好了以后，就不会再出现弹不出提示什么的事
 - **xsd/dtd下载一次有了之后，以后就不会重复下载了**
###xml中xsd和dtd的区别
 - 百度


##@Before&@After注解
		TestCase.java-搭配测试方法使用
 - 在方法前加上@Before注解，被@Before注解的方法，会在每个测试方法之前自动调用；
		即执行测试方法，会自动检查有没有哪个方法有@Before注解，有则先调用被@Before注解的方法
 - 在方法前加上@After注解，被@After注解的方法，会在每个测试方法执行完自动调用；


##配置文件的结点<list>&<array>混用
		注入集合类型的值用到的
 - ArrayList本质就是个数组。存储数据的形式和数组是一样的，在内存中都是连续的。
		回顾'ArrayList'  List是个接口，常用的实现类是ArrayList、LinkedList
 - list和array节点是可以混用的：因为他们本身的存储格式是一样的，在内存当中的处理方式没有太大变化


##由数组和线性表的原理区别 联想到 String字符串的修改
 - String就是char[](char数组)，所以字符串的插入就慢。
		相当于ArrayList
		数组长度不可变，因为在内存里两边都是其他的数据。修改就得另找位置
 - stringBuilder()和stringBuffer()实际占用内存一开始就很大，所以增删快
		程祖红老师说可以指定长度，比如指定8192(8k)，这样就有8千多个初始的char长度


##在.properties文件中使用中文的操作
		看课堂笔记'在.properties文件中使用中文'
 - 有01.png图解
 - 使用#开头可以在.properties文件中写注释


##List和Set
 - List：序列的(有序的) ArrayList,LinkedList
 - Set：散列的。HashSet,TreeSet,LinkedHashSet
		不能说是无序的：HashSet无序，TreeSet有序 (TreeSetTest.java)
		LinkedHashSet:看TestCase，有序
``			只要看到Linked连接，就是链表实现的
 - Set不能重复，判断是否重复的依据是：看添加进来的和已存在的元素 equals为true且hashCode()值相同
``		这也是Map中的key的评判标准。Set只用了Map的key这一列。世上本没有Set，Set的本质是没有value的Map
 - 看任何一个Set的源码，可以看到内部是用了一个对应的Map
		HashSet--->HashMap<E,Object>;TreeSet--->TreeMap<E,Object>;LinkedHashSet-->LinkedHashMap
			Object的意思，就是不必关心value的类型。因为不用  


##小项
1. war包表示的是web项目，但是并不是选了war包就必须写web项目。
2. 添加依赖和jar包是两码事。我们在pom.xml里加的jar坐标是添加依赖。
		一个依赖里可以有多个jar包。我们添加依赖的时候会把它需要的一系列jar包都导进来。单个的叫jar包
3. 开多了项目的缺点：eclipse会变慢。影响视觉。不用的项目就关掉
		eclipse在打开的时候会检查所有的项目有没有错误
4. 鼠标放在类名代码上，出来的框左上角的小图标，C，C的右上角A  表示class abstract 抽象类
5. 即使try里有return，也会走finally
6. **使用权限的原则**：权限的使用，越小越好。任何一个成员(属性、方法)，如果要使用更加宽松的权限，必须得有个说法，必须要有原因。没有原因就private，能私有就私有
7. TestCase.java：Arrays.toString(Object[] a)返回指定数组内容的字符串形式
8. **看控制台报错的原则**：先看Caused by导致原因；没有则看第一行
		caused by是最详细的错误原因，但有的错误没有Caused by，就得看最前边的那行
9. 注入集合类型的值在实际开发中用途不大，因为我们很少在xml文件中把集合类型的值写死。但是我们确实有需求读properties文件
10. 下标和索引的概念都一样，一定要区分的话：数组叫下标，集合叫索引
11. 成恒说注入集合类型的值也不用加get方法，但是不加get方法我怎么获取这个值? ：其实，注入和Get方法是没关系的，加get方法只是我们可以调用出来。不加get方法它照样是通过Set方法给注入进去了。


#-------------------------------------SPRING.day03--------------------------------------
###1.18号 下午第一节课讲完；  SPRING-02-IOC工程讲自动装配(上午第一节课)；SPRING-O3-ANNOTATION工程讲注释


##byName和byType的特点
		加在课堂笔记了，不用看这里。autowire属性的取值；看课堂笔记+代码
 - byName要求名称一致并且要有正确的set方法
 - byType要求匹配的对象有且只有一个
		byType这种方式不要求当前类中Set方法名要一致，但是需要Set方法。是根据当前类中属性的类型去匹配。
		并且，byType不是类型直接匹配：如果是写的类的子类，或者写的接口的实现类，都是可以匹配上的
 - 装配不明确：说白了，甚至还不如我们写property。写property虽然麻烦，但是谁有值谁没值一目了然。


##MVC-Model补充
		MVC：Model(Dao+Service)+View+Controller
 - Model=Dao+Service
 - DAO：Data Access Object 数据访问对象，做数据的增删改查----实行层
 - Service：业务逻辑类，做一系列的判断，判断是否运行做某些事情。
		不是servlet里的service方法
 - 由这两个部分保证数据的安全和有效


##句柄解析
		cn.tedu.spring.Student@1ee807c6 句柄 @后的是hashCode值
 - 当我们尝试输出一个对象时，如果不是null，就会调用它的toString。
		如果toString没重写调用的就是Object的。
 - 查看Object的toString源码可以看到：
		public String toString() {
			return getClass().getName() + "@" + Integer.toHexString(hashCode());
		}   类名+@+16进制的hashCode值     toHexString是把int型的10进制数转换为16进制数
 - hashCode值是数据的引用地址-堆内的地址-栈中记录的地址。可以用来判断是否为同一个对象
		前提是在hashCode()方法没有被修改地情况。
		hashCode的源码：
			public native int hashCode();  空的方法体，是底层直接实现的
		如果被修改-恶意重写，比如：
			public int hashCode(){
				return 0;
			}
			那么返回的就是0，毫无意义


##Bean的作用域解释
		作用域：有效期，有效范围
		以下不细扣对象和实例的叫法。可查阅'对象&实例&类的区别'
###单例模式
 - 单例的作用域很大：从在spring配置文件被加载到的那一刻开始(创建)，一直到spring容器被销毁
 - 单例模式之饿汉式设计
		举例
		public class King {
			private static King king = new King();  2内部声明King  4加static使静态方法能访问到
			`为什么静态方法不能访问非static成员的原因：static的加载优先级很高，会很早就加载到内存里，而此时非static成员还没有加载到内存里，所以访问不到。`
			private King() {  1私有化构造方法，这样在其他位置就不能new了，只能在本类new
			}
			public static King getInstance() {  3公开的static方法，如果需要King对象就调这个方法，由于King只在一开始new了一个，所以不管这个方法调用多少次，都是同一个King。加static使可以用King.getInstance()直接调用此方法。(如果不加static会出现一个矛盾：不调方法获取不到对象，不获取对象调不了方法。)
				return king;
			}
		}
``	static特征：长驻内存。
		早早的被加入内存，而且一直不离开不销毁，以至于写程序的时候一直都可以调用。随时随地地访问，意味着它任何时候都在内存里。加载以后就不再离开
``	‘迫不及待地，一开始就new出来了，并且长驻内存’所以称作饿汉式
 - 单例模式之懒汉式设计-懒加载-延时加载-lazy-init
		举例
		public class King {
			private static King king;	这里只声明属性而不new
			private King() {  
			}
			public static King getInstance() {
				synchronized("lock") {  上锁，防止多线程可能同时突破if判断导致创建多个对象。里边lock岁编写的
					if (king == null) {  当调用了这个方法，且king为null的时候new一个对象，如果不为null直接返回已new的对象
						king = new King();		
					}
				}
			return king;
			}
		}
``	只在第一次getBean()的时候才new对象。‘不到逼不得已不去new，get的时候它一看没有才去new’即懒汉式
###非单例模式
 - 非单例的可以理解为局部变量：对象在getBean的时候出来，所在的方法运行结束消失
 - 非单例模式设计
		public class King {
		}

		King k1 = new King();
		King k2 = new King();
		想要多少个对象就new多少次
###观察单例&非单例模式
 - 方法：各种给日志/打桩见TestCase.java&Student.java
``		Student()是Student构造方法的输出语句
 - 单例-饿汉式：
		@Component("stu")
``		在TestCase中运行：Student()在开始加载配置文件和加载配置文件完成之间输出，说明对象在加载配置文件时创建
 - 单例-懒汉式：
		@Component("stu")  @Lazy
``		运行：Student()在获取对象时输出，即创建在获取对象时
 - 非单例模式：
		@Component("stu")  @Scope("prototype")
``		运行：Student()在获取对象时输出，即创建在获取对象时


##小项
1. 4种基本注解的作用、语法是完全相同的，只是语义不同，建议区分使用。
		只是给人表达的意思不一样，混用也可以。建议区分使用，如果不归属于后三个的就用Component即可


#-----------------------------------SPRINGMVC.DAY01-------------------------------------
###1.18号 下午第二节课开始；  工程SPRINGMVC-01-HELLO


##01.png图解/SpringMVC工作流程图
###与之前程祖红老师smartmvc图的出入问题：
1. 两张图对HandlerMapping的描述：祖红老师写的是 负责提供请求路径与处理器的对应关系；成恒老师写的是 处理请求路径与控制器的映射关系
``	成恒老师回信：
		严格来说在整个MVC中并没有处理器这个东西，我们往后边学习都会把Controller叫作“控制器”，其英文名也是控制器的意思。但是他实际确实是处理请求的组件，叫作“处理器”也是ok的，但是我们现在认识了，最好还是按照它的英文意思来。
2. 对Cotroller的描述：祖红老师写的是 负责业务逻辑的处理；成恒老师写的是 处理请求，给出结果
		业务逻辑包括：我们设定的对数据增删改查的规则，业务流程。
			在smartmvc和目前阶段，我们都是把业务逻辑写在控制器中。
			但是完整的MVC流程中，控制器并不直接业务逻辑，控制器还会继续往下去找Service--业务逻辑类。
###DispatcherServlet
 - 成恒老师回信：严格的说，DispacherServlet可以称为“前端控制器”，在MVC中，把接收或处理请求(Request)的都叫是控制器，所以，Servlet和Controller都是控制器。由于DispatcherServlet在最前的位置接收请求，所以就叫“前端控制器”了，它的作用只是分发，并不做实质的处理，真正实际处理请求的是Controller，也就是我们所说的“控制器”。
###Controller&灰框Model
		DispatcherServlet通过HandlerMapping的映射关系，把请求分发给控制器Controller。
 - Controller控制器，作出实质的处理。
 - 但在完整的MVC流程中控制器并不直接处理如何登录和如何注册，控制器还会继续往下去找Service
		在目前现阶段，我们绝大部分代码都是出现在控制器中的。但是继续往后学习，和数据库结合起来，就要用到Model了。如下
 - Service业务逻辑类，它只是判断能否注册能否登录，但是它判断的依据往往是要联合数据库做增删改查，而Service本身不做增删改查---所以Service还要去找实行层Dao
 - 而Service和Dao是SpringMVC没有约定的，即SpringMVC整个工作流程里面，并不考虑控制器往后是怎么工作的，所以用其他颜色表示。
 - 这里的Service和Dao就是Model
		看昨天'MVC-Model补充'


##小项
1. 因为Java EE原生的API使用不便利。后来出现了Struts1框架，但是这个开发团队是个小众的开发团队，不被人重试，大部分人还是用官方API，但是官方api又不好用。所以官方和这个团队开发了个Struts2，这个框架流行了很长很长时间。
``	有的公司还用Struts2；Struts2不讲，但是有视频给我们看
2. Servers项目如果close了会启动不了Servlet
3. 一般情况下java的命名风格：方法名是动词作为前缀，比如showxxx
		属性名是名词


#-----------------------------------SPRINGMVC.DAY02-------------------------------------
###工程SPRINGMVC-02-UMS(用户管理系统)


##SpringMVC工程的准备工作
1. 添加部署描述文件
2. 添加Tomcat运行环境
3. 添加spring依赖：前面项目复制pom.xml的依赖
4. 添加spring.xml配置文件：前边项目复制，保留组件扫描和视图解析器的配置
		如果根包、前后缀等属性改变则修改
5. web.xml配置：前边项目复制
		如果param-value配置文件目录，url-pattern请求路径通配符改变则修改


##接收请求参数
 - 第一种：通过HttpServletRequest获取请求参数
		不推荐用，太麻烦。但也不是完全没有用武之地。
``		在除了控制器以外的组件中依然可能需要使用。**第二种和第三种做法只能应用于控制器**
 - 第二种：直接使用同名参数
		不合适用于参数太多的情况。只是不合适，或许是因为太多了影响代码美观，所以应该用第三种封装起来
 - 第三种：通过对象接收请求参数
 - 第二&三种可以**混用**：
###‘封装参数’和‘直接使用参数’的混用`
 - 举例：接收用户注册信息和验证码，验证码不适合放在用户信息里，但要求同时接收。
 - 可以这么写：public String handleReg(User usre,String code){}
 - 接收请求参数同时使用第二种和第三种做法。



##转发和重定向
		补充课堂笔记'【附】 转发与重定向'
 - WEB-INF目录：该目录是不允许通过http协议访问的！只能把jsp文件放在WEB-INF下。素材图片,css,js文件等不能放在这里，因为这些文件都是必须要通过HTTP协议访问的。
 - 在重定向时，URL是会发生变化的。并且，两次请求之间的数据**默认**是无法共享或传递的！
		无法共享/传递意思是：你两次访问服务器，但服务器不知道这两次是同一个客户端，它没有什么数据用来记录你的访问。识别不了身份。
		默认不能共享/传递。但是可以强制使用session/cookie技术来共享/传递数据数据，不过明显这样做不便利，还会占用服务器内存
 - Case1：如果希望URL发生变化，必须使用重定向！
		举例：用户在登录页面输入用户名密码登录之后，下一步应当进入主页。如果此时是转发会出现问题/错误：
			1 网址还是登录页面的网址，不符合人的思维
			2 当用户点刷新时，浏览器会询问是否要重新提交表单，因为刷新其实就是把用户上一次的请求再提交一次`
			也可能会出错：当是注册页面时，如果注册完后用户点刷新，则会重新再提交表单，那么会返回注册失败，因为已经有此用户了。这样体验感就很差。
 - Case2：如果有大量的数据需要传递，可以考虑使用转发！
		不用转发就得把数据全放到session中去，session会占用服务器内存。
 - Case3：控制器处理好的数据，不便于在JAVA中编写如何显示，则应该转发给JSP页面！
		这种情况百分百用转发，java代码可以处理数据但不便于显示，jsp方便显示却不适合处理代码。协同合作。
###302响应码和301响应码||动态/静态重定向
 - 响应码可能是302还可能是301。因为有静态/动态重定向。
 - 静态重定向：访问A页面百分百重定向到B页面。
 - 动态重定向：访问A页面有可能重定向到B，也有可能重定向到C页面。
 - 对我们没什么用，应用在网络爬虫：如果响应码代表静态重定向，那么爬虫知道这个页面是有价值的。如果响应码是动态重定向，则是没什么价值的，可以让爬虫判断如果是动态重定向就不继续往后爬。
 - 网路爬虫：能够发出http请求的代码，然后把响应正文抓回来，分析哪些数据对它是有价值的。


##SpringMVC中重定向绝对路径的问题
 - 根据程祖红老师讲的路径问题，重定向的地址如果用绝对路径写需要加上应用名
 - 之前smartmvc处理重定向是在DispatcherServlet中：
		1 判断trturn的是不是redirect: 开头
		2 拼接上 用getContextPath()获取的应用名+/+redirect:后边的东西
		比如： return "redirect:welcome.do";-->"/smartmvc02/welcome.do";
``	明显这种设计是规定了--在redirct:后写的只能是相对路径
 - 成恒老师说springmvc框架中的重定向可以使用相对路径，也可以使用绝对路径
``	在UserController中我实验了用绝对路径写重定向，发现了以下问题：
		1 我写绝对路径  redirect:/SPRINGMVC-02-UMS/index.do
			浏览器请求变成了
				localhost:8080/SPRINGMVC-02-UMS/SPRINGMVC-02-UMS/index.do
		2 我写  redirect:/index.do
			浏览器成功请求访问localhost:8080/SPRINGMVC-02-UMS/index.do
``	我推测：
		springmvc框架对重定向路径的处理应该是这样：
		1 先判断是redirct:开头 进入重定向的处理
		2 判断剩下的是否以/开头，不是则和smartmvc中的设计一样；是/开头则把/去掉，然后还是和smartmvc设计得一样。
``	**推论**	因为springmvc流程中处理这些重定向逻辑的肯定是我们写的正儿八经的java类，不会是webapp下的那些jsp。而这些由springmvc管理的java类就在根目录下，不用考虑他们的绝对路径or相对路径，因为都是从应用名开始的。底层给拼接上应用名即可，你加了/也给你去掉。
 - 关于相对路径和绝对路径问题，我已发邮件给成恒老师。成恒老师说绝对路径只要加/就可以，不用加应用名。
 - 再想到这个问题时去看一下发的邮件。


##枚举类型的由来
		由@RequestParam注解  属性method=RequestMethod.GET 赋值方式引入
 - 开发的时候，有些数据的值是不需要非得写出来的，比如：
		gender;//性别
		String gender = "男"; // "女"，"帅哥"/"美女"，"先生"/"女士"
		性别的值只有男or女，但是在不同的场合它的称谓可以是不一样的。
``		所以为了更灵活，gender没有必要是一个字符串，更多时候我们会声明为int值
		int gender = 1；自己规定1表示什么，不是1表示什么
			if(gender==1){
				System.out.println("先生，您好!");
			}else{
				System.out.println("女士，您好!");
			}
		我们通常用1或者0这种代号来表示性别的值，因为从数据的处理上来说，int型比String类型的好控制一些，同时占用的存储空间也小一些。
``		但是用int这样写出来的代码给人感觉怪怪的：为什么1就表示男。 我倒过来也可以，我用100/1000表示男，200/2000表示女都行，只要判断的时候对应的上男女就行。这样的话这个值的大小就没有意义，只要使用过程中保持一致即可。
``		所以我们进一步这么处理：
		public class Gender{
			public static int male=1;
			public static int female=0;
		}
			if(gender==Gender.male){
				System.out.println("先生，您好!");
			}else{
				System.out.println("女士，您好!");
			}
``		这样一来看着就懂一些。只要大家认识单词，就可以知道它的意义。所以我们更希望于用名字来表示意义，至于它的值是多少就无所谓了(只要值统一就可以)。
``		但是万一有谁把这个值改了：Gender.male=100；
			那么判断就会有问题
``		所以在声明的时候就会加上final：并且加上final后命名风格也变了(常量)
		public class Gender{
			public static final int MALE=1;
			public static final int FEMALE=0;
		}
``		然而其实程序员都很懒，并不满足于这样的写法，所以将类改为接口：
		public interface Gender{
			int MALE=1;
			int FEMALE=0;
		}
		少写三个修饰符，没有什么原因，就是懒
``		但是再往后演变，就有人发现，我哪是不想写修饰符，我连值都不想写。因为他们的值是1还是0不重要，是100/200也行。只要整个使用过程中都是保持统一的。
		既然不关心它的值，那么为什么要写值呢。于是演变为不想写值的做法：
		但是这是static final的。加上final的成员变量就必须声明同时初始化值。
		为了解决这个问题，java的开发团队说那这样吧：
			把interface换一个：enum。你何止是不想要值，你连数据类型都不想要，反正也没有值。于是
		public enum Gender{
			MALE,FEMALE
		}
		所以只要这两个东西只要保证他们的值不冲突即可。enaum这种数据类型就可以保证他们的值都是唯一的，绝对不冲突。 enum里是没有值这个概念的。
 - 就是一步步偷懒懒出来的。使用的时候当成静态常量即可。
###百度枚举类型
 - 作用：用于声明一组命名的常数(static final)，当一个变量有几种可能的取值时，可以将它定义为枚举类型。
 - 好处：这种变量能设置为已经一定的一组之中的一个，有效防止用户提供无效值。该变量可使代码更加清晰，因为它可以描述特定的值。
 - 定义：是指将变量的值一一列出来，变量的值只限于列举出来的值的范围内。
 - 枚举成员的默认值：在枚举类型中声明的第一个枚举成员它的默认值为0.以后的枚举成员值是将前一个枚举成员(按文本顺序)的值加1得到的。
 - 没有显式声明基础类型的枚举声明意味着所对应的基础类型是int。
 - 未解决问题：枚举的声明，枚举的基础类型。我到底咋用它！！！？？？


##@RequestMapping源码
		Crtl+左键
 - **源码解读1**：
		String name() default "";
	1 name是属性名称，类型是String，默认值(没写)是空串。
		起到的作用就是给这个映射取名字，相当于注释。不用。
 - **源码解读2**：
		@AliasFor("path")
		String[] value() default {};
	1 value属性是字符串数组类型，即可以写多个路径{"","",""..}表示多个不同的请求路径都由这个方法处理。默认值是空数组。
	2 @AliasFor表示path和value是等效的、‘混为一谈’的。
		下边还有个：
			@AliasFor("value")
			String[] path() default {};
``		@AliasFor表示的就是这两个属性可以混为一谈。一般这是版本更替导致的。而且path上边的注释有@since 4.2。表示4.2版本后才有这个属性，可能是框架的设计者认为这个名字更适合表达要写的值的意思。
 - **源码解读3**：
		RequestMethod[] method() default {};
	1 method类型是RequestMethod数组(枚举类型数组，RequestMethod是枚举类型)，即请求方式可以写多种
		比如写method={RequestMethod.POST,RequestMethod.GET}


##几种状态码
 - 405错误：405表示请求方式不支持(错误)
		看客户端提交的方式与服务器要求的方式是否一致
 - 400错误：请求参数不对
		找@RequestParam。没有加这个注解之前名字不存在顶多是null值。只有用了这个注解才有这个错误。
 - 404错误：请求资源不存在
		检查路径的拼写和服务端的映射


##@RequestParam源码
 - **源码解读1**：
		@AliasFor("name")
		String value() default "";
		@AliasFor("value")
		String name() default "";
	1 SliadFor：name和value这两个可以‘混为一谈’。默认值空字符串
 - **源码解读2**：
		boolean required() default true;
	1 required必须的。
	2 defaule为true。即默认情况下(参数值)是必须的，true表示是。
``		课堂笔记'当使用了`@RequestParam`注解后，默认情况下，参数值是必须提交的，如果客户端提交的请求中并不包含该名称的参数，则会报告400错误：`请求参数不对`'
	3 可以用的时候写 @RequestParam(value="psw",required=false)，则默认这个参数值不是必须提交的。这样就不会有400错误
	4 经我实验：若设置了required=false，并没设置默认值(源码解读3)，则不提交这个参数的情况下参数值为null
 - **源码解读3**：
		String defaultValue() default ValueConstants.DEFAULT_NONE;
	1 defaultValue() 默认值 属性，String类型。默认值什么也没有
		default ValueConstants.DEFAULT_NONE 默认值为 ValueConstants接口下的常量DEFAULT_NONE，DEFAULT_NONE顾名思义默认_没有值，这个理解起来有点绕，点DEFAULT_NONE源码就看到了
		指针悬停在defaultValue() 有个特别说明
				Supplying a default value implicitly sets required to false.
				这行是使用时的注意事项：(如果)要设置默认值，(需要)显式地设置required为false
				(显式：明确的通过代码表现出来；隐式：我们学的很多属性都有默认值，那就是隐式)
				显式的设置required为false，即设置required=false，即源码解读2-3，使不必须有这个参数值。因为如果必须有这个参数值(要求客户端明确的发送参数值过来)，那就没有默认值这一说了。所以需要搭配required=false使用，当没有参数值时使用默认值。
``		课堂笔记'通过`defaultValue`属性来配置**默认值**'
 - **看给成恒老师的邮件**未解决问题！！！？？？


##小项
1. 看课堂笔记'【附】 转发与重定向'：
2. 重定向加redirect:  转发也可以加forward:  不过spring默认的行为就是转发--return "forward:login" = return "login"
3. 在类之前使用@RequestMapping注解，可以简化每个方法之前的注解。**解决大量名称共性问题**
4. @RequestParam("pwd") String password 表示别人将交出一个pwd，而我编程的时候用password。这样不影响前后端的命名风格


#-----------------------------------SPRINGMVC.DAY03-------------------------------------
###SPRINGMVC-02-UMS工程：昨天的作业以及今天一直到乱码问题之前的内容
###SPRINGMVC-03-EXCEPTION：SpringMVC处理异常


##Tomcat修改发布设置
 - Never publish automatically：从来不自动发布
		以前我们选的是这个。目的就是让我们熟悉tomcat，能自己操作就自己操作
 - Automatically publish when resources change：当资源改变时自动发布
		当任何一个资源(源文件)比如jsp、html、java类等一旦改变就会把改变的重新部署到tomcat里。
		现在可以改为这个。以后就不用修改了一个东西后重新部署了。
		可设置Publishing interval(in sesonds)：延时时间
 - Automatically publish after a build event：在build事件以后自动发布
		把项目重新build以后就重新发布。即class文件改变则重新发布，当你修改了源文件是不会触发自动发布的，需要编译后class文件发生了变化才会触发。
		exlipse我们一直用的是自动编译：Project Build Automatically；取消勾选自动编译后Project下还可以点Build All等
		可设置Publishing interval(in sesonds)：延时时间
 - 用第二个就行，第三个本身我们就自动编译了，和第二个一样


##Java EE过滤器的缺点
		举例：某些页面必须用户登录后才可以访问，某些页面不需要登录即可访问。需要过滤
 - Java EE过滤器的结构：
	配置：
		<filter>
			<filter-name></filter-name>
			<filter-class></filter-class>
		</filter>

		<filter-mapping>
			<filter-name></filter-name>
			<url-pattern>*.do</url-pattern>
		</filter-mapping>
	代码判断：
		登录过滤器
``			判断请求路径是否必须登录
			是：判断是否已登录
				是：放行
				否：重定向
			否：直接放行
 - 在实际应用中，由其是大型的网络系统，需要登录or不需要登录的请求有非常多，如果用Java EE过滤器判断请求路径是否必须登录，那一定是非常麻烦的，对所有的页面(请求路径)都要做判断处理。
		高不成低不就，做不做的出来，做的出来，好不好用，不好用。
 - 于是我们可以用SpringMVC的拦截器


##关于方法名参数为arg0，arg1...的问题
		例：实现HandlerInterceptor接口
 - 问题：生成的方法参数名应是request，response。如果是arg0，arg1的，**意味着没有相应的源代码**。
		在程祖红给我们讲过滤器监听器的时候我也发现了这个问题
 - 解决方法：按住ctrl不动点接口看源码,如果原本没有的，会自动的从maven下载它的源码。
 - 延伸问题：**为什么没有源码我可以用方法呢？**
 - 答案：没有源码的意思是没有它的java文件，我们可以用方法是因为有它的class文件。也就是说在class文件中我们可以得到方法的权限、返回值、名称、参数类型，但是没有参数名称。


##HandlerInterceptor接口三个方法的拦截位置
 - public boolean preHandle()：SpringMVC工作流程图序号4。运行在控制器之前。
 - public void postHandle()：SpringMVC工作流程图序号5。
 - public void afterCompletion：SpringMVC工作流程图序号6。


##@ExceptionHandler的参数问题/源码
		Ctrl点击进入源码
 - 源码解读：
		Class<? extends Throwable>[] value() default {};
	1 通过这行源码可以看出，此注解有个参数叫作value，value的类型是Class。Class的泛型要求是extends Throwable，即参数要写一个类，但这个类必须是Throwable的子类。`比如：Exception.class对，String.class就错。`并且可以是一个数组`比如：{IOException.class,RuntimeException.class}`
		'Throwable'可搜索，这是异常最顶端的类，包括了Error和Exception
 - **此参数可以写父类**。若写的是父类，则其子类异常也会走此方法处理
 - 表示此方法处理异常的范围有多大，那些异常是交给这个方法来处理。


##小项
1. 建类时可进行的操作：在New Java Class页面可以选择超类和接口。

2. 键盘的字母排序由来：是为了降低打字员的打字速度--可百度。打字机响应速度慢，将常用的放在不灵活的手指下，将不常用的放在灵活的手指下。

3. **utf-8和utf8**：UTF-8是标准写法。一般程序都能识别这两种写法。但在MySQL中只能写utf8，不加-；在其他大部分情况建议写标准的UTF-8


#------------------------------------MYBATIS.DAY01--------------------------------------
###工程：MYBATIS


##数据库补充
 - 进入数据库：mysql -uroot -proot  可以直接在用户名p后面写密码root。但是有个缺点：密码会随着这一行直接暴露在窗口名上
		MySQL版本高了好像就不行了，比如我笔记本的8.0，网上说MySQL 5.6 在命令行输入密码，会提示安全警告信息。--可以看MySQL的安装配置&使用笔记
 - 在数据库中，规范写法是：所有的关键字应该都大写，自己起的名字小写。这是官方建议
		但是sql语句完全是不区分大小写的，完全都可以写成CReAtE
 - 数据库中对字段常用的约束就是not null 和 unique。
		其实约束都可以在java代码中实现，在数据库中写定作用不大，不过这是数据安全的最后一道保障。但在完整的程序中，数据库的约束一般不会发生作用
 - create table xx(id int primary key);等同于create table xx(id int,primary key(id));
 - **写java代码时永远都不要使用*号，除非测试。**
		原因：1、占用内存，很多不必要都要查出来；2、查询的结果需要起别名，不能用*号；3、避免信息泄露
 - **SQL语句不区分大小写**，不论是用户名还是密码还是什么。而我们平时的上网体验：大部分用户名都不区分大小写，密码是区分大小写的，所以我们判断用户登录并不会去查询密码，而是查询用户名取得密码，之后通过java代码来equals比较
##数据库的编码指定
 - 整个MySQL软件叫作数据库服务器，这个数据库服务器上有很多数据库，每张数据库中可以有多张数据表。
 - 数据库服务器   数据库  数据表  这三者均可以设置编码。分别在安装时，创建时，创建时指定，而且编码可以不一样。
``		如果不指定编码，则沿用前边的：
			如数据库服务器设置为utf8，则数据库默认也是utf8。
			若数据库是gbk，则数据表默认gbk。
 - 通常我们在创建数据库的时候不设编码，而在创建数据表时指定编码。
``		即以后在每张数据表创建时后边都加上**DEFAULT CHARSET=utf8**
 - 查看表字段/表结构：desc 表名=describe 表名  这个desc不是降序，而是describe。
###char()和varchar()区别
``		括号内填写的是长度：字符的个数。
 - char(xx)是定长。   char(32)：固定长度为32，写入的若不足32，则补空格
``		使用场景：例如对密码做加密的处理后用char()
			加密处理：密码原本可能是123456，但是我存进来后是其他的。而且绝大部分加密算法不管你存进来是多少，计算之后长度都是一样的。此时我们就会用定长的char(),比如char(16) char(32)
``		国斌：	CHAR用的少，char效率比varchar略高，但是因为现在设备性能已经很高了，效率差距可以忽略不计。
``				业界默认的规则：短的字符串用varchar，长的用text。
 - varchar(xx)是可变长度。   char(32)：最大长度为32。
		可变长度，多给点没关系。若写的是10，存的是3，则只占存进去的长度。但若写的是3，存的是10，则只存进去前三个字符。
		另外，查看表详情及实验知，int长度是11。正是正负21亿，其中第一位是'+' '-'号，后10位是数字。若存入的数字超出int，则显示最大or最小值
###问题：如何一次插入100万条数据
		成恒老师说往届学生碰到的面试题。这一百万条数据应该都是循环出来的数据，不要多想。需要用jdbc。
 - 首先：不应当一次插入100万条，因为sql语句是一个字符串，长度是受限的。同时也会占用大量的内存，导致内存溢出。
 - 方法一：100W次循环，每次插入1条。不可行，因为每次传输都要进行两个服务器的连接，然后把sql字符串传过去，并把处理结果传回来，消耗时间。
		增删改则返回受影响的行数，查询则返回查询的数据。
		两个服务器：数据库服务器和后端服务器，比如MySQL和Tomcat
 - 方法二：1W次循环，每次一个语句，100条数据。**最快，推荐**。具体：1W条sql语句，每条语句的values后跟100条数据。
``		这个方法成恒老师说的很模糊，具体的实现是我猜的，太浪费事件了，回头再仔细看！！！？？？
		for(int i =1;i<=10000;i++){
		语句 INSERT INTO t_user (username, password, age, phone, email) 
		VALUES (1, 'Tom'),(2, 'Tom'),(3, 'Tom').....(100, 'tom')---这里也是循环生成的
		执行插入
		}
 - 方法三：1W次循环，每次执行100条批处理。一次传输100条sql语句，然后处理。查看MySQL'批量操作'/jdbc02工程的Demo05.java
 - 百度：MySQL 的SQL语句有最大长度，默认是语句长度是1M，**可以在mysql的配置文件中修改语句长度**
		max_allowed_packet=xxM  建议用到的时候再好好百度一下：怎么配置sql语句长度限制
 - 一般像我们平时的SQL语句很短，一次插入一般values后跟5000条数据以内可以。


##版本号编号原则
 - 一般是三位数，分别为：大版本号.小版本号.修复/修正版本号
	- 大版本号   进行很大的改动。
		一般软件第一版是1.0.0
	- 小版本号   进行某些小功能的该进，算法优化。
		某些软件比较低调可能第一版是0.1.0
	- 修复/修正版本号   在每次修复小bug时修改。
 - 当修改了前边的版本号，后边的应当归零
 - 在版本号后面有时会添加一些子母用作版本的标示
		1.0.0.Beta   表示公测版  公开测试版本
		1.0.2.Alpha   Alpha版本的软件只在公司内部流通，比如开发团队交给测试团队
		4.3.9.RELEASE   最终版   解决了所有现阶段的需求&bug  稳定版，这种一般都没问题。
###添加依赖时的版本选择
 - 选择如上的正八经的版本号。
		不正经的版本号有例如用日期做版本：20030825.184428,这种不用。
 - 如果添加的依赖有点问题，可以向上升几个小版本，没有问题。
		但最好不要向下降版本。


##'数据库配置文件的写法'的补充
###driver
		Driver的写法.driver的填写有可能会变，比如之前没有cj. 这取决于用的依赖的版本。
 - 方法一：可以先在java类空白处敲个Driver，alt+/提示出来。
		如果出现两个，则用方法二
 - 方法二：展开Maven Dependencies所有jar包-->mysql-connector...数据库连接驱动-->META-INF-->services-->java.sql.Driver:
		在这个文件中有com.mysql.cj.jdbc.Driver或者com.mysql.jdbc.Driver等等，就是它
``		高版本的 数据库连接驱动 的依赖有这个文件，低版本的没有，没有就用方法一。
		成恒用的8.0.13版本，国斌用的5.1.6版本，都有这个文件
###url
		老师的有这个时区问题，我的没有。
 - 高版本的jdbc驱动有时区问题，使用会有SQLException: The server time zone value....
 - 解决办法：在url最后加上一个配置 serverTimezone=Asia/Shanghai
		这个时区只能写Asia/Shanghai或者Asia/Chongqing，历史遗留问题。国民党时期老外就在做这个事，定的标准没有改，当时他们只认重庆和上海。
		注意不同配置之间用&隔开，这个url也类似于浏览器的url那样。
 - 回头再花时间搞清楚到低是为什么，怎么解决！！！？？？
		注意：以前国斌时候没这个问题，是用的jdbc版本的问题还是MyBatis的问题。我回头要做个实验，在国斌的jdbc工程那里用现在用的高版本的试试。
		百度关键词是servertimezone、sqlexception：the server time zone value...
		已经百度到一个近似的描述：使用mybatis连接mysql8.0社区版时出现了这个异常信息，因为mysql默认的时去和本地时区不一致导致的。解决方案：方案1. 修改mysql默认时区  方案2. 连接mysql时指定时区为UTC：serverTimezone=UTC


##apache-commons
		BasicDataSource的导包
 - 以后看到commons的就崇拜一下，commons里面的一般都是行业的标准，多半是apache提供的。所以如果导包的时候有多个选项的话，它的优先级应该是最高的。	
	

##spring-dao.xml的书写原理||01.png图解
		bean的id其实可以写可以不写的，是该bean的唯一标识。在被用的时候用id去确定这个bean，不用则不用写。一般都写。
 - 配置数据源的value是注入值的写法 bean的id.配置文件的key  如遗忘参阅框架笔记'读取properties配置文件'&'Spring表达式'
 - name的书写是BasicDataSource中的对应的属性名/set方法名。太多不好记，可以进BasicDataSource的源码，然后show-->Outline大纲视图查看，也可以按Ctrl+O显示类中方法和属性的大纲。
		其实我们在成恒老师的db.properties中写的所有的key都是和BasicDataSource里的一致的
 - **Ctrl+O**，可以搜索类中的所有属性和方法，右下角写的是show inherited members 查看继承的成员。


##序列化&序列化接口解释
**我TM还是很迷糊**，成恒说话老是不解释地很清楚，前后说话也难找关联，浪费我太多时间！但是现在**经过我查阅和瞎猜我知道了，实体类要实现序列化接口，因为他妈的要经常反复地用到这个实体类对象，增删改查都得用，所以要给他实现序列化接口，让它按照那什么序列化方案被存在缓存里，这样就节省时间了！！！**
###成恒-序列化：
 - 序列化：指的是数据的克隆/传输过程中，整个对象的序列传输过程
		比如下列数据，为一个对象的数据
			username:jack
			age:18
			password:1234
		将这个对象克隆到其他位置去。不可能一次就传输完，因为'CPU单次运算能力是有限的'。但传输过去后零散的数据需要和属性对应的上，比如jack不能对应age，而应该对应username
 - 把数据拆散了往另外一边传递/克隆，就是一个序列化的过程。
 - 序列化过程中有一个很重要的序列化方案：先传什么数据，以及数据是什么属性；后传什么数据，以及数据是什么属性。以确保数据和属性对的上号
		这个规则/方案不需要我们去指定，只要实现了序列化接口就会自动帮我们做。
###百度-序列化：
 - 序列化解释：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。
 - 序列化的目的
		1.以某种存储形式使自定义对象持久化；
		2.将对象从一个地方传递到另一个地方。
		3.使程序更具维护性
###(为什么)实现序列化接口Serializable
		MYBATIS-User.java   实体类为什么实现序列化接口：
 - 序列化接口Serializable：点开源码可以发现接口内啥也没有，它是整个java当中极为少有的没有任何抽象方法的接口。
 - 作用：它起到的作用是标识。标记这个类可以被序列化。
``		able后缀的意思是：能否怎么样。这里就是，能被序列化,即这个类可以被序列化
		很多接口都是able结尾的,以able结尾的也绝大多是是接口
 - 实现了序列化接口相当于告诉虚拟机或容器，这个数据是可以被序列化的，在以后的克隆/传输中，都可以利用序列化机制
		序列化机制最实际的表现是：比如一个web应用，Tomcat会缓存其中一部分对象。当对象数据使用完之后，按说应当销毁，但是Tomcat会暂时留住(缓存)这个数据，下次用的时候直接使用即可，不需要再经过程序层运行。以此提高程序运行效率
 - 没有实现序列化接口的数据就不会留在缓存，数据的处理效率会略低一些。
 - **什么样的数据需要实现序列化接口：核心是表现属性和属性的值的类。**
``		**若某一个类的核心是体现某些功能的，几乎没有属性的，这样类型的就不需要实现。比如控制器，全部是处理请求的方法，没有属性和值的概念，这样类型的就不需要去实现序列化接口。**
 - 实现了序列化接口，会把数据缓存，后续访问时就不需要再走一整套流程，提升效率。


##32位/64位是什么
		32bit/64bit
###成恒解释：
 - CPU单次运算能力是有限的。32位/64位表示CPU运算一次能够处理32/64个二进制位
 - 32个二进制位即4个字节，一个int。即计算机一次只能处理一个int。一个64位的CPU才能单次运算一个long
 - 但是CPU的工作频率很大：比如2.4GHz  即计算机的单次运算能力不强，但是频率很强。
		一般说CPU多大说的是频率。
		2.4GHz x 4 即2.4GHz&4核心
###百度查阅：
		https://zhidao.baidu.com/question/176517757.html?entrytime=1548660661894
 - 这个位数指的是VPU GPRs(General-Purpose Registers,通用寄存器)的数据宽度为64位，64位指令集就是运行64位数据的指令，也就是说处理器一次可以运行64bit数据。
		64bit处理器并非现在才有的，在高端的RISC（Reduced Instruction Set Computing，精简指令集计算机)很早就有64bit处理器了，比如SUN公司的UItraSparc III、IBM公司的POWER5、HP公司的AIphs等。
 - 64bit计算主要有两大优点：可以进行更大范围的整数运算；可以支持更大的内存。不能因为数字上的变化，二简单的认为


##MyBatis查询相关
###查询所有用户数据/MyBatis查询原理
		UserMapper.java   抽象方法 List<User> findAll();
 - 操作：查询所有用户数据，用集合表示所有的用户数据，泛型为User。
 - 推荐用List集合接收--结果有序，和表中的顺序一样。
		TreeSet是按照字典排序的所以不合适。
 - 在配置mapper文件中，resultType指定(泛型)User接收，即返回值类型不写List
 - **原理**：其实在MyBatis帮我们做查询操作的时候，每一次的结果都是List。我们在配置文件中resultType指定其某一个个体比如User，框架就会尝试从结果中遍历的元素。有数据就给，没有则null。所以我们只要在配置文件中声明集合中是什么即可
###查询必须指定resultType
 - 比如查询数据表中的数据量，resultType要指定Integer接收。
``		**这应该也是为什么MyBatis里不用int的原因**。成恒老师没说是因为这个，但是他没在Mybatis里用int
 - java原生的类中只有lang包里的类才不用导包，所以我们平时用的不用导包的类都是在java.lang包下的
		lang包==language包


##小项
1. 存手机号用字符串。不用int：int类型的数应当本身具有数值的含义，可能会涉及到数的运算。并且会有这样的手机号：+86 138-0013-8001

2. 写程序在测试的时候用英文或者拼音做测试，如果写中文可能会出现乱码问题。目的是先测试整体逻辑的正确性，乱码问题放在最后解决。

3. SpringMVC解决了MVC中V-C的关系。而没有解决M的问题。M(Service,DAO)很大一部分是解决数据的处理。
		MyBatis解决了M的问题。

4. 以后在spring-dao.xml中配置数据库相关；在spring-mvc.xml中配置控制器mvc相关。
		只是为了分开管理，方便以后去修改。放在一起完全没问题

5. 老师说有的同学出现了这种错误：错误全都是大写，其中有一个是PLUGIN，这可能是因为mysql的版本过低，依赖的版本高，不兼容，更换成 5.几版本的 数据库连接依赖 。`或者也可以更新数据库啊`
		注意数据库配置文件中的driver的值可能会彼变


#------------------------------------MYBATIS.DAY02--------------------------------------
###工程：MYBATIS


##MyBatis抽象方法参数问题/为什么不能写多个参数
		解释课堂笔记'抽象方法中多个参数的问题'
 - 首先参考'关于方法名参数为arg0，arg1...的问题'，可知，在class文件中没有参数名称。
 - 所以当java文件被编译为class文件以后，class文件中并不包含对应的参数。
		这个class文件，应该是框架自动生成的(抽象类的)实现类的class文件
 - 所以当抽象方法只有一个参数的时候，mapper配置文件中的#{参数名}是可以随便写的，因为class文件里没有参数名的概念，框架会固定的取class文件中的那唯一一个参数放在配置的SQL语句中
 - 但是**当参数大于1个就会出现问题**
		比如：
			抽象方法：Integer updatePassword(Integer id,String password);
			配置文件中的SQL语句：UPDATE t_user SET password=#{password} WHERE id=#{id}
 - java文件编译为class文件运行的时候，方法就变成了Integer updatePassword(Integer arg0,String arg1);
 - 然后mapper配置文件xml文件中，执行SQL语句时，就会去方法的class文件中找名为password、id的参数，但是运行环境中有两个参数，而且叫arg0，arg1；所以就出错了
		当找password找不到就已经出错了，所以控制台会报'password' not found,但是其实id也将找不到。
		XML文件不会被编译，只有java文件会被编译
 - 那我我猜它的机制是这样的：先找同名，如果找不到看是否是一个参数，如果是一个参数那就对应这唯一的参数，如果不是一个参数则它懵逼报错。有待考究！！！？？？


##关于xxxMapper
		UserMapperTestCase.java
 - xxxMapper是我们用MyBatis需要写的一个接口，没有实现类。
 - 问题：ac.getBean得到的应该是一个具体的对象，一个已经new出来的对象。而接口是不能new对象的。这是怎么回事呢?
 - 解释：其实这是MyBatis通过代理模式 实现的，不严格地说是代理模式给的一个‘实现类’。输出mapper可以看到它的句柄，句柄中的MapperProxy表示的是Mapper的代理。规则是使用MyBatis的时候，会自动成这个代理对象来完成接口里的方法。需要这个对象的时候getBean即可，Bean的id就是接口名称首字母改小写。
		句柄：org.apache.ibatis.binding.MapperProxy@4c39bec8
 - 如果要理解代理则要学习‘代理模式’。
		这是一个很长很长很长很长的故事


##占位符#{}与${}
		占位符顾名思义，?/#{}/${}都是占位符
 - 在xxxmapper.xml文件中，用#{}代替以前jdbc写的?，实际执行时，也是预编译的。他们用于对值进行占位，比如：
		select * from t_user where id=?    id的值是个?，在mybatis中就应当用#{}
 - 但是在不能用?的地方在mybatis中就不能用#{}
 - 这段配置：FROM t_user <if test="where !=null"> WHERE  #{where} </if>
``	   相当于 FROM t_user WHERE  ?
 - ${}用于对非值的语句部分进行占位


##浏览记录的价值
 - 浏览记录有隐藏的价值，这种上网体验不必多说。比如淘宝京东的推送。
 - 在以前这种记录并不会被记下来，因为不一定有太多用，而且需要购买硬件存储设备，增加资金开支。
 - 现在尤其是大平台，比如淘宝京东，都会保存浏览的记录，并不会考虑硬盘的资金，有的是钱。
		随便挖个山洞放服务器即可。facebook脸书的服务器丢在西伯利亚。


##小项
1. SQL语句不区分大小写，不论是用户名还是密码还是什么。而我们平时的上网体验：大部分用户名都不区分大小写，密码是区分大小写的，所以我们判断用户登录并不会去查询密码，而是查询用户名取得密码，之后通过java代码来equals比较


#--------------------------------------AJAX.DAY01---------------------------------------
###工程：AJAX

##泛型
		ResponseResult.java&UserController.java
 - 泛型就是一个不确定的类型，声明具体类型的时候声明的是什么就会用什么。
 - 使用泛型：用泛型，要在声明类型的时候随便写一个泛型的占位符，且必须在类名后声明用到了占位符。
 - 占位符：占位符用什么都可以，可以是数字、子母、甚至是单词。
		单词作为占位符一般用在某一个类涉及到多个泛型的时候，可能会用单词表示。多个泛型典型的比如Map的泛型，<K,V>表示key和value，当然也可以直接用<key,value>来表示。
``		可以直接识别的数据类型的名称，即**已知的类型名不可以用作占位符**。
 - 只有声明类时用占位符。使用类时都要写成具体的类型，对于不在乎的类型，写成Void,Void是一个类。
``		UserController.java中，用不到数据data，只需要状态码和消息，而data是泛型，所以要写为Void。
		即使类型再不确定也要写成?问号，但是我们如果要使用这个类就得new，new的时候不能写?，可以用Void表示不在乎这个泛型是什么。  
		写成?是翻干啥 不懂！！！？？？
 - **Void类源码解读**
		void类的源代码很简单，没有哪个类比它的源代码更简单，
``		解读一：public final class Void 
			final修饰，不能被继承
``		解读二：private Void() {}
			私有的构造方法，别人不能用。
``		解读三：本类中也没有代码去new对象。
		The Void class cannot be instantiated.：这个类不允许被初始化
``		这个类没用，只是用来表示空的意思而以。
		The {@code Void} class is an uninstantiable placeholder class to hold a reference to the {@code Class} object representing the Java keyword void.
		这是一个占位符类。表达的意思是java关键字中的void。
``		所以我们如果要使用一个有泛型的类，但是又不在乎这个泛型的数据类型，则要写Void。
``		解读四：java开发者把这个类放在这里就是要把类名占用，且在long包内，不需要导包，则如果别人要命名一个类为Void就会报错。
###泛型和Object
 - 用泛型而不用Object的原因是如果使用的具体类型并不是使用的Object，就需要向下转型转回去。


##AJAX (Asynchronous Javascript And XML异步Javascript和XML)
		`X表示XML，最早没有json时是通过XML传输的，现在都用json，但是还是叫AJAX
 - AJAX 俗称 阿贾克斯。用于提交异步请求。异步请求：
 - 异步：各走各的，线程之间不影响。把整个浏览器理解为一个主线程，当提交请求，主线程把请求发出，并把返回的结果显示在页面上，导致页面发生变化。这样设计的程序缺点就是：一、页面变了，客户体验不好；二、请求发出没有及时得到响应，这期间页面无法操作(不能滚动，或者点击等等)，造成卡顿(原因是只有一个线程，并且线程在忙着发请求和拿回响应)。
		上述问题的解决方法是开一个子线程，让主线程负责页面显示，子线程提交请求抓回结果。两个线程没有关系。即异步提交请求。
 - 异步提交请求有两种实现方式：传统的Js方式&JQuery框架。推荐用Jq，Jq有封装好的方法。原生的js比较繁琐。
 - 异步请求的对象是XMLHttpRequest，他封装在JQuery中，不用我们创建。
 - **必须使用Http协议才能使用AJAX**，本地(file协议)打开不会发出请求。


##小项
1. ‘数据类型’这个概念只存在于运行程序的计算机里面，是程序运行过程中我们创造出来的数据类型概念。而数据被存储、传输，则根本没有数据类型的概念。
2. Chrome和Firefox遵从W3C的规范标准匹配度比较高，所以推荐用这两个。
		360、搜狗浏览器等，没有独立的网页解释程序，被称为是没有独立内核的浏览器，他们用的是IE或者Chrome的内核，来解释网页的标签。IE6-IE8最坑，如果非用IE可以用高版本的。
3. Html中不区分大小写，所以在html中不使用驼峰命名法。


#-----------------------------------SpringBoot.DAY01------------------------------------
###工程：sample

##使用https://start.spring.io 页面创建项目
 - Generate a xxx:
		Maven Project，会从maven服务器下载所需要的依赖。
		Gradle Project，通过几行代码添加依赖，不需要下载jar包添加到项目中。这个在IntelliJ idea 中很被推广，在idea中用。
 - With xxx：
		选Java，他还支持别的语言下拉可以看到
 - and Spring Boot xxx：
		版本 选择2.1.2   后边带有SNAPSHOT的表示可能不是稳定版本
 - 点击Switch to the full version显示更多的信息
 - Group Artifact等等。这些和我们平时建项目一样
 - Package Name是自动生成的，根包，需要注意这个包也是组件扫描的包，则本项目中，**所有需要被Spring管理的组件都必须在这个包或它的子孙包中**！
 - 勾选依赖：MySQL，MyBatis，(**自动会添加spring-boot-starter-web，这里应该是常用的web相关的东西**)
		因为数据库和持久层框架都有很多种，他也不知道你要用哪个，所以要自己勾选。
 - Generate Project创建，会给一个压缩包，即我们要用的项目。
		把压缩包打开就是项目，放入workspace中，导入到eclipse中即可，import-->Maven-->Existing Maven Projects。
		导入后目录还未完善，需要等待eclipse执行完程序，并正常访问maven服务器，下载到所需的jar包等等。
 - SpringBoot中没有web.xml，如果eclipse提示错误信息，缺少web.xml，是因为eclipse版本太低，更新版本。也不需要添加tomcat运行环境。
###导入SpringBoot出错的原因和解决方法
		类似于普通jar包的导入错误和解决
 - 错误：Project build error: Non-parseable POM 路径...
		很多地方报错，这是pom.xml文件的报错
 - 原因： .m2/repository/org/springframework/boot下的文件受损
 - 解决：删除此boot目录文件重新导入使Eclipse重新加载


##SpringBoot理解总结
 - SpringBoot是帮助我们添加依赖，帮助我们完成(简单的必不可少的)配置的框架，使我们的配置更加地简单。
			对我们传统编码方式没有任何改动，只是相关的配置方面不一样
 - 包括新接触的：@RestController注解，在传统的SSM框架中就有，当时没有学json，所以当时没介绍。




##小项
1. **MVC是一种(分角色的指导)思想**,他指导我们数据的处理流程中至少应当有三个角色。角色分清除，分工合作，就可以有效地**解耦**，便于代码地维护和修改。
		解耦：降低(解决)耦合度


#------------------------------------PROJECT.DAY01--------------------------------------
###工程：store

##写注释要求
 - 所有的类和接口都应该有注释
 - 所有的方法第一次出现的时候都应该有注释
		被重写的方法如果有什么特别的东西也应该写注释，如果没什么特别的可以不写。
###xxMapper.xml注释
 - 在insert和select节点前加两行注释：
		<!-- 对应的抽象方法的中文说明 -->  方便看
		<!-- 对应的抽象方法的声明语句 -->  方便检查


##//TODO
 - 暂时不写的代码加一个`//TODO`，右边滚动条方便会出现蓝色小方块，左边有小本本，鼠标悬停有提示，并且点击可以直接跳过去。用来提醒这里的代码还没有写。


#------------------------------------PROJECT.DAY02--------------------------------------
###工程：store


##关于黑客入侵数据库
 - 黑客入侵数据库在现在的软件系统很难实现了，因为Tomcat计算机和Mysql计算机会通过局域网LAN连接起来，tomcat连接到外网。黑客如果一定要黑数据库唯一的做法就是通过找Tomcat的程序的漏洞，来发送一些sql指令或植入程序。


##(消息)摘要算法
 - 摘要数据时一串16进制数。
 - 消息摘要算法的主要特征：
``		1.原文相同，则摘要相同；
				所以摘要算法也可以用来验证下载文件的完整性。
``		2.原文不同，则摘要几乎不会相同；
				摘要算法执行运算得到的最短位数是32位数。32位16进制换算成二进制是128位,128种组合，要想重复是很困难的。
				并且我们注册密码会限制密码长度，在有限的密码长度中不同密码得到相同的摘要可以认为是绝不存在的。因为要想让摘要重复，必须要原文的量足够足够足够大。
``		3.算法不变，摘要长度不变。
				使用同一种算法，摘要数据的长度不变，不管原文是什么样的。
 - 摘要算法执行运算得到的最短位数是32位数。32位16进制换算成二进制是128位，所以也称为是128位算法。


##UUID
		test/DigestTestCase：摘要示例
		可在数据库sql：select uuid();
 - 百度：UUID(Universally Unique Identifier)通用唯一识别码。是指在一台机器上生成的数字，它保证在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)指定的标准计算，用到了以太网卡地址、**纳秒级**时间、芯片ID码和随机数。
		就是一个彻头彻尾的随机数。
 - **以UUID作为盐**，字符串**长度36**=4个短横+32个16进制。


-----14.00


##小项
1. 挖矿就是穷举，对比摘要数据的值。

2. **本质区别：摘要算法不是加密算法**，因为加密算法都是可以被逆运算的。大家只是利用摘要算法的不可逆运算的特点应用到加密领域。



#------------------------------------PROJECT.DAY03--------------------------------------
#------------------------------------PROJECT.DAY04--------------------------------------
#------------------------------------PROJECT.DAY05--------------------------------------
#------------------------------------PROJECT.DAY06--------------------------------------



#----------------------------------netctoss王哥Project-----------------------------------


1. 实体类是一切的基础
2. 实体类做完做DAO，在DAO里操作数据库，数据库中的数据用实体类对象保存








#----------------------------------O总结补充&通用认知O------------------------------------


##类的加载和对象实例化过程
		https://blog.csdn.net/tectrol/article/details/80643007
		构造方法的新解："创建对象是通过调用构造方法创建的"。这句话程祖红老师第一天上午说到过两次。
		百度：构造方法顾名思义就是构造对象的方法，用它来对对象进行构造，即进行初始化。 
###类加载过程
 - 这是网上的，后来程祖红老师讲了，看笔记'类加载的过程'
1. JVM会先去方法区中找有没有相应类的.class存在。如果有，直接使用；如果没有，则把相关类的.class加载到方法区
2. 加载静态内容，初始化静态变量
3. 执行静态代码块
		程祖红：加载就是找到这个类的字节码文件，把字节码文件的内容读到方法区里面，变成一个class对象
###对象实例化过程：
1. JVM在堆内存中开辟一块空间，分配一个地址
2. 加载非静态成员，默认初始化非静态成员变量
3. 执行super语句
4. 对非静态成员变量进行显式初始化
5. 执行构造代码块
6. 执行构造函数
7. 把空间分配的地址赋值给引用对象


##我理解的面向对象和面向过程
 - 面向对象：建类，new对象
 - 面向过程：写方法，调方法(函数，过程)


##字符串转数字几种方法，
- Integet.parseInt("123")
- int i = new Integer("123")
- int i = Integer.valueOf("123")


##静态变量 全局变量 局部变量 实例变量 成员变量的区别
 - 全局变量=成员变量=实例(非static)变量+静态(static)变量
 - 实例变量=对象成员=非static成员
 - 局部变量：方法内声明的变量，出了方法就释放


##jar包数据缺失问题
		case1：jar包中数据缺失导致直接不能import这些包里的类
		case2：命名jar包里有这个类却报错找不到这个类
		case3：ZipException 解压异常，想都不用想jar包一定是坏的
###原因：jar包数据下载失败/损坏。
 - 重新下载依然不能解决。是因为当下载的时候eclipse发现这个jar包文件已经存在，便不再重新下载，而是继续导入第一次下载好的jar包。
 - 程祖红：maven导包很方便，但是有时候会有一些意外，没有完全下载或拷贝过来，会丢一些东西
###解决办法：删除jar包，重新下载。
 - 删除方法一：删除本地仓库.m2文件。   .m2读作：点m two
		目录在Window-->Preferences-->Maven-->User Settings 用户设置：Local Repository 中可见此目录包含所有下载的jar包。
		回头百度一下.m2里分别都是什么！！！？？？

 - 删除方法二：成恒：把左边的目录栏拉宽一些，可以看到每个jar包的路径，不嫌麻烦也可以在这个路径下找到然后删除。
		有的maven镜像服务器可能很慢，全部删除重新下载可能会好几分钟。
 - 重新下载方法一：重新保存使jar包重新下载
		但这样就费事了，直接删.m2的话，不都得打开pom文件重新保存一次吗。
		或者可不可以重启eclipse会检查出来没有然后重新下载，这个可以实验一下！！！？？？
 - 重新下载方法二：重启eclipse-->更新 Update Project...
``		**Maven强制更新的操作**：maven项目右击-->Maven-->Update Project-->勾选Force Update of Snapshots/Releases 强制更新版本
			Release： n.发布 版本  Snapshot：n.快照
``		作用：重新从maven服务器下载 添加的依赖但本地没有的jar包。


##validate(验证)问题
 - 问题描述：学spring，每次保存spring的配置文件，都会触发验证，右下角validating一直卡在0%；
		网上看这是个普遍问题，班里人都这样；
		经过我的测试：建maven的时候pakaging是jar没事，是war就会这样
 - CSDN：用于检测代码存在的潜在问题，比如：jsp文件的语法错误，XML中的schema错误等。
		电脑性能不佳很容易卡死，我感觉可能是因为spring配置文件里那些网址太多，它检查起来慢。但为什么选jar包形式就没事，就不知道了。
 - 可以禁用：Window-->Preferences-->Validation:勾选Suspend all validators 暂停所有验证；或者Sisable All 禁止所有


##eclipse快捷键
###Ctrl+F 查询
 - 选中字段后Ctrl+F，显示的查询内容直接就是选中的字段
###Ctrl+O 搜索
 - 'Ctrl+O' 搜索类中的所有属性和方法
###Ctrl+2，R(rename)
 - 对当前类中的代码字段进行重命名：双击选中字段，Ctrl+2，同时松开，然后(1s内)按R
 - 任何代码都可以改，只要是双击能选中一块的。
		就是单词吧
 - R表示rename
###Alt+上下箭头 移动
 - 使光标所在行或者选中的行整体上下移动位置


##状态码整合--待整合
###2字头的都是OK
		常见200，罕见206
 - 206见在断点续传。比如迅雷下载的暂停继续
###3字头的是重定向相关

###4字头的是客户端错误
 - 405错误：405表示请求方式不支持(错误)
		看客户端提交的方式与服务器要求的方式是否一致
 - 400错误：请求参数不对
		找@RequestParam。没有加这个注解之前名字不存在顶多是null值。只有用了这个注解才有这个错误。
 - 404错误：请求资源不存在
		检查路径的拼写和服务端的映射
###5字头的是服务器错误
		5字头的错误一定是会在控制台报错误信息的。


##常见异常
		拷贝自Spring笔记
	Throwable --这是异常最顶端的类，包括了Error和Exception
``		Error  --错误，一般是比较严重的问题，可能和我们的硬件或虚拟机直接相关
			OutOfMemoryError  --(比如)'内存溢出'，使用的内存超过了限制
``		Exception  --异常，常见的。可检测异常，不是100%可以杜绝的，比如拔U盘，拔网线。
			SqlException
			IOException
				FileNotFoundException
``			RuntimeException  --非检测异常。出现频率可能非常高，如果要求必须try-catch那就麻烦了。可以100%杜绝不出现(比如先进行判断，只能在数组长度内操作)
				NullPointException
				ClassCastException  --向下转型(我认为说强转比较好)可能出现
				ArithmeticException  --算术运算异常(随便一个数除以0)
				IndexOutOfBoundsException  --索引越界异常
					ArrayIndexOutOfBoundsException  --数组索引越界异常


##BindingException绑定异常
 - 所有的绑定错误一定是接口中的抽象方法和xml对不上号所导致的。
 - 可能是namespace对应的接口文件写错，或者是id写错



##小项
1. arg=argument 编程参数；args=arguments 参数

2. 在反射面前所有权限都是浮云，反射都能访问到

3. 存手机号用字符串。不用int：int类型的数应当本身具有数值的含义，可能会涉及到数的运算。并且会有这样的手机号：+86 138-0013-8001

4. lang=zh 语言=中文  **zh代表中文**，取自拼音Zhōngwén的前两个子母，**cn代表中国China**

5. 从头到尾一个不漏的**循环**叫**遍历**

6. 100Mbps*8=100MBps;8bit=Byte;网络速度的评定标准确实是以二进制位的传输速度来定的。

7. 以.开头的文件或文件夹是Linux的隐藏文件。





#--------------------------------------待解决问题----------------------------------------

最好用eclipse的 mars.2 或者mars4 回家看看家里是什么版本，mars是啥意思，就是那个原先查的代号？看完删了这句话行了
#回头用chrome浏览器查看网页源代码，把仙剑奇侠传五的html写完。先试试360能不能看到网页源代码
随机数的两种方式忘了
整合王克晶笔记 仔细精简去重web sql 笔记

#未解决问题：
怎么关web应用，使调用生命周期的销毁方法。不要直接卸载
SE day10-3 ：download中调用show的中断方法

刘苍松的算术右移和逻辑右移到底咋回事，咋算术是除2.不变负数了吗
查询补码是什么
map_key_HashMap里的equals和hashcode的成对重写
v3-HttpRequest中的getHeader方法当时设置的意义真的对吗？微博问了没回复
maven项目，JRE System Library的版本和项目的properties中的compiler版本，以前学的时候能一块动，现在我换了主机用普通导入怎么不行了呢。洋洋的我看也是一块动的，难道是和eclipse的设置有关吗。

getResourceAsStream(xxx)：这个的路径应该怎么填，从哪个目录开始填！！！？？？

内部类外部类之间到底是怎么相互访问的，为什么类里不能修改只能声明，需要在方法里。为什么要在静态块中给静态变量赋值

内边距和边框都可能影响元素的宽高，此宽高不是盒子模型里的width和height，而是整个元素占的宽高。

班里字体Bitstream Charter Regular


老师用的画图软件是FastStone Draw


#########整理传奇笔记：把这里的每天下写上它的包名，按照#包名##类名整理API 整理API不要看天数，一个包一个类地整理就行了，到时候需要看哪天的对着包名来我的笔记找对应的天数即可。

