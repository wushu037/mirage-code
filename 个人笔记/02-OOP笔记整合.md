
#--------------------------------------OOP.day01----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建6个对象类，创建World类并测试


##什么是类?什么是对象?
1. 现实世界是由很多很多对象组成的
    基于对象抽出了类
2. 对象:真实存在的单个的个体
    类:类型/类别，代表一类个体
3. 类中包含:
    3.1)所有对象所共有的属性/特征-----------成员变量
    3.2)所有对象所共有的行为----------------方法
4. 一个类可以创建多个对象，
5. 类是对象的模板，对象是类的具体的实例
	  类              对象
	月饼模子          月饼


##如何创建类?如何创建对象?如何访问成员?
	`见项目
	数据类型 引用类型变量/引用 指向    对象
	Student        zs         =  new Student();


##射击游戏需求:
1. 参与角色:英雄机、小敌机、大敌机、小蜜蜂、子弹、天空
2. 关系:
	2.1)英雄机发射子弹(单倍或双倍)
	2.2)子弹可以射击敌人(小敌机、大敌机、小蜜蜂)
	2.3)敌人可以撞英雄机
	2.4)英雄机、小敌机、大敌机、小蜜蜂、子弹在天空上飞
3. 英雄机火力值为0，则为单倍火力
   英雄机火力值大于0，则为双倍火力
   ----发射一次双倍火力，则火力值减2
4. 子弹射击敌人，子弹与敌人都消失:
	4.1)若射击的是小敌机，则玩家得1分
	4.2)若射击的是大敌机，则玩家得3分
	4.3)若射击的是小蜜蜂，则英雄机得奖励(1命、40火力值)
5. 敌人撞英雄机，敌人消失，英雄机减1命同时清空火力值
###思路
1. 找对象:英雄机、小敌机、大敌机、小蜜蜂、子弹、天空
2. 抽类:Hero、Airplane、BigAirplane、Bee、Bullet、Sky
3. 设计类中的成员变量和方法:
4. 创建对象并测试:

	class Hero{ //英雄机
		life,doubleFire,width,height,x,y
		void moveTo(int x,int y){
			英雄机随着鼠标移动
		}
		void step(){
			切换图片
		}
	}

	Hero:width,height,x,y,life,doubleFire,
	void moveTo(int x,int y){},void step(){}
	Airplane:width,height,x,y,speed,void step(){}
	BigAirplane:width,height,x,y,speed,void step(){}
	Bullet:width,height,x,y,speed,void step(){}
	Bee:width,height,x,y,xSpeed,ySpeed,awardType,void step(){}
	Sky:width,height,x,y,speed,y1,void step(){}


##基本认知
1. 专业名词
	OO:面向对象
	OOA:面向对象的分析
	OOD:面向对象的设计
	OOAD:面向对象的分析与设计
	OOP:面向对象的编程--------------你们所参与的

	基本不区分OOA和OOD；而是合称OOAD--有这样的书
	日企的软件行业或许细分OOA和OOD；

2. 软件分两种:
	1)产品:可以适应很多家公司的
	2)项目:只能适应一家公司的

3. 高质量的代码:
	复用性好、扩展性好、维护性好、
	可移植性好、健壮性好、可读性好、效率好...

4. 面向过程的结构化程序设计弊端:
	缺乏对数据的封装
	数据与方法(操作数据)的分离

5. 创建类的好处
	基本数据类型---------- 只能装一个数
	数组------------------类型必须相同
	自己造个数据类型-------想装什么就装什么


##克晶语录
语言基础:
  1)固定(画一个圆形)
  2)猜字符小游戏
  3)去银行取钱
	
面向对象:难
  1)抽象(画一个图形)
  2)射击游戏
  3)向着社会主义社会发展

晕乎乎的过来的----------------正常的
	
不晕:
  1)什么也不懂------------------下个月见
  2)自以为不晕------------------很不错很不错很不错
	
这10天晕乎乎的-----这5个月晕乎乎的-----干1,2年有点门了-----干个4,5年


#--------------------------------------OOP.day02----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类并测试
###Shoot射击游戏第二天:
1. 给6个对象类添加构造方法，并测试


##方法
0. 方法的签名: 方法名+参数列表
1. 方法的重载(Overload):
	1)发生在同一个类中，方法名称相同，参数列表不同，方法体不同
	2)编译器在编译时会根据方法的签名自动绑定调用的方法
2. 构造方法: 别名 构造函数、构造器、构建器
	1)给成员变量赋初值
	2)与类同名，没有返回值类型
	3)在创建对象时被自动调用
	4)若自己不写构造方法，则编译器默认提供一个无参构造方法，
``	  若自己写了构造方法，则不再默认提供
`		`若自己写了有参构造，也就没有无参构造了
	5)构造方法可以重载
 例：
   Student zs = new Student();这行代码干的事：
	1)创建了一个学生对象
	2)给所有成员变量赋初值
	3)调用了Student的构造方法
3. this:指代当前对象，哪个对象调用方法它指的就是哪个对象
	只能用在方法中，方法中访问成员变量之前默认this.
   this的用法:
	1)this.成员变量名--------------访问成员变量
	2)this.方法名()----------------调用方法(一般不用)
	3)this()----------------------调用构造方法
   成员变量和局部变量是可以同名的
		--------用的时候采用就近原则(即不写this的话就是在用局部变量)
   当成员变量与局部变量同名时，this不能省略
		PPT：在构造方法中，用来初始化变量的参数一般和成员变量取相同的名字，这样会有利于代码的可读性，但此处就必须通过this关键字来区分成员变量和参数了(不能省略this)
4. null:空，没有指向任何对象
	若引用的值为null，则该引用不能再进行任何操作了
	若操作则发生NullPointerException空指针异常
5. 引用类型之间画等号:
	1)指向同一个对象
	2)通过一个引用对数据的修改会影响另一个引用对数据的访问
		eg:房子钥匙
		房子:对象
		房子钥匙:引用
		配一把钥匙:引用
   基本类型之间画等号:
	1)赋值
	2)对一个变量的修改不会影响另一个变量
		eg:身份证复印件	`你修改的是你的，他还是那个


##基本认知
1. 内存管理:由JVM来管理的
	1)堆:new出来的对象(包括成员变量)
	2)栈:局部变量(包括方法的参数)
	3)方法区:.class字节码文件(包括方法)
	class Aoo{
		int a; //堆
		void show(int b){ //栈
		int c=5; //栈
		}
	}


#--------------------------------------OOP.day03----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试


##引用类型数组:
1. 声明方式一：
   Student[] stus = new Student[3];  //创建Student[]对象
    stus[0] = new Student("zhangsan",25,"LF");  //创建Student对象
    stus[1] = new Student("lisi",26,"JMS");
    stus[2] = new Student("wangwu",27,"SD");
    stus[1].age = 36;
2. 声明方式二：
   Student[] stus = new Student[]{
	new Student("zhangsan",25,"LF"),
	new Student("lisi",26,"JMS"),
	new Student("wangwu",27,"SD")
    };
3. 数组的数组：
   int[][] arr = new int[3][];
``	 声明int[]型数组arr，包含3个元素；每个元素都是int[]型，默认值为null
    arr[0] = new int[2];
    arr[1] = new int[3];
    arr[2] = new int[2];
    arr[1][0] = 100;
``	  给arr第2个元素中的第1个元素赋值为100

	声明double[]型数组ds，包含6个元素；每个元素都是double[]型，默认值为null
	double[][] ds = new double[6][];
4. 数组的数组：3行4列
   int[][] arr = new int[3][4];
    for(int i=0;i<arr.length;i++){
      for(int j=0;j<arr[i].length;j++){
        arr[i][j] = (int)(Math.random()*100);
	System.out.println(arr[i][j]);
      }
    }
``  3行4列  3:为arr的长度  4:为arr中每个元素的长度


#--------------------------------------OOP.day04----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
###Shoot射击游戏第四天:
1. 设计超类FlyingObject，6个派生类继承超类
2. 给FlyingObject设计两个构造方法，6个派生类分别调用
3. 将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组，并测试
4. 在6个派生类中重写step()


##继承:
1. 作用:代码复用
2. 通过extends来实现继承
3. 超类:所有派生类所共有的属性和行为
	派生类:派生类所特有的属性和行为
4. 派生类继承超类后，派生类具有:派生类的+超类的
5. 一个超类可以有多个派生类
	一个派生类只能继承一个超类-----单一继承
6. 继承具有传递性
7. java规定:构造派生类之前必须先构造超类
	在派生类的构造方法中若没有调用超类的构造方法
	------则默认super()调用超类的无参构造方法
	在派生类的构造方法中若调用了超类的构造方法
	------则不再默认提供
``**super()调用超类构造方法必须位于派生类构造的第一行**


##super:指代当前对象的超类对象
  super的用法:
1. super.成员变量名-----------访问超类的成员变量
2. super.方法名()-------------调用超类的方法
3. super()-------------------调用超类的构造方法


##向上造型:
1. 超类型的引用指向派生类的对象
2. 能点出来什么，看引用的类型
	FlyingObject o1 = new Airplane();
	FlyingObject o5 = new Sky();
	o1.只能点出FlyingObject类的
	o2.只能点出FlyingObject类的

	Person p1 = new Student();
	Person p2 = new Teacher();
	Person p3 = new Doctor();
	p1/p2/p3.只能点出Person类的


##方法的重写(Override):重新写、覆盖
1. 发生在父子类中，方法名相同，参数列表相同，方法体不同
2. 重写方法被调用时，看对象的类型
3. 重写遵循"两同两小一大"原则:-----了解
	3.1)两同:
	  3.1.1)方法名相同
	  3.1.2)参数列表相同
	3.2)两小:
	  3.2.1)派生类方法的返回值类型小于或等于超类方法的
		  1)void时，必须相等
		  2)基本类型时，必须相等
		  3)引用类型时，小于或等于
	  3.2.2)派生类方法抛出的异常小于或等于超类方法的-----异常之后讲
	3.3)一大:
	  3.3.1)派生类方法的访问权限大于或等于超类方法的-----明天讲
`4. 重写中使用super关键字
``	PPT：子类在重写父类的方法时，可以通过super关键字调用父类的版本。
	Class Foo{
	  public void f(){
		System.out.println("Foo.f()");
	  }
	}
	Class Goo extends Foo{
	 public void f(){
		super.f();
		System.out.println("Goo.f()"); 
	 } 
	}
	Foo obj2 = new Goo();
	obj2.f();
	输出结果为：	Foo.f();
				Goo.f();
	子类重写方法中的super.f();调用了父类的版本；这样的语法通常用于子类的重写方法在父类方法的基础之上进行功能扩展。
``	重写的形象描述：
	我继承了一个中餐馆:
	A:我还想做中餐--------------不用重写
	B:我想改做西餐--------------需要重写
	C:我想在中餐之上加西餐------需要重写(先super再加西餐)
	
``	如果重写时，是想在超类的基础之上做操作----先super再加入


#克晶语录
咋理解继承
  程序中的继承:
		代码不用自己写，自己也能用
  生活中的继承:
	1.继承财产:
	    钱不用自己挣，自己也能花
	2.继承皇位:
	    江山不用自己打，自己也能坐
	3.继承工作:
	    工作不用自己找，自己也能干


#--------------------------------------OOP.day05----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
###Shoot射击游戏第四天:
1. 设计超类FlyingObject，6个派生类继承超类
2. 给FlyingObject设计两个构造方法，6个派生类分别调用
3. 将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组，并测试
4. 在6个派生类中重写step()
###Shoot射击游戏第五天:
1. 画窗口
2. 给类中成员添加访问控制修饰符
3. 给对象类添加图片属性


##重写与重载的区别:-----------常见面试题
1. 重写(Override):
	1.1)发生在父子类中，方法名相同，参数列表相同，方法体不同
	1.2)遵循"运行期绑定"，看对象来调用方法
2. 重载(Overload):
	2.1)发生在一个类中，方法名相同，参数列表不同，方法体不同
	2.2)遵循"编译期绑定"，看参数/引用来调用方法


##packger和import
1. package:
   1)作用:避免类的命名冲突
   2)类的全称: 包名.类名
   3)包可以有层次结构
   4)建议:包名所有字母都小写
 建议包名:
	域名反写 . 项目名称 . 模块名称      . 类名
	cn.tedu . aproject . stumanager   .
	cn.tedu . aproject . teachmanager .
	两个公司的项目的都有A这个类，但是包是绝对不一样的--域名唯一
	A公司:
	  package com.a.b.c.d.e;
	  class Aoo{
	  }

	B公司:
	  package com.b.c.d.e;
	  class Aoo{
	  }
2. import:
   同包中的类可以直接访问，
   不同包中的类不可以直接访问，想访问有如下两种方式:
	1)先import声明类再访问类-----建议
	2)类的全称----------太繁琐，不建议

 
##访问控制修饰符:
1. public:公共的，任何类
2. private:私有的，本类
3. protected:受保护的，本类、派生类、同包类
4. 默认的:什么也不写，本类、同包类
 说明:
   1)**类的访问修饰只能是public或默认的**
   2)类中成员的访问修饰如上4种都可以
 标准：
   **数据(变量)私有化(private)**
   **行为(方法)公开化(public)**

##static:静态的
1. 静态变量:
    1.1)由static修饰
    1.2)属于类，存储在方法区中，只有一份
    1.3)常常通过类名点来访问
    1.4)何时用:所有对象所共享的数据(图片、音频、视频等)

 `成员变量:
   1)实例变量:没有static修饰，属于对象的，存储在堆中，
		有几个对象就有几份；通过对象点来访问
   2)静态变量:由static修饰，属于类的，存储在方法区中，
		    只有一份；     通过类名点来访问
	class Aoo{
		int a; //实例变量
		static int b; //静态变量
	}
 `内存管理：
   堆:new出来的对象(包括实例变量)
   栈:局部变量(包括方法的参数)
   方法区:.class字节码文件(包括方法、静态变量)

2. 静态方法:
    2.1)由static修饰			`实例方法：没有static修饰
    2.2)属于类，存储在方法区中，只有一份
    2.3)常常通过类名点来访问	`也可以通过对象点来访问，new对象然后对象.他的静态方法；但黄色警告不建议这么调`
		Scanner scan = new Scanner(System.in);
``		double b = scan.nextDouble(); //实例方法，不用static修饰的方法，对象点

``		double d = Math.sqrt(25); //5 
``		Arrays.sort(arr);             //静态方法，用static修饰的方法，类名点
		
    2.4)静态方法没有隐式this传递，
        静态方法中不能直接访问实例成员

		实例变量多还是静态变量多----------实例变量多
		实例方法多还是静态方法多----------实例方法多
		  实例变量多所以实例方法多，因为静态方法不能访问实例变量

``		PPT：由于static在调用时没有具体的对象，因此在static方法中不能对非static成员(对象成员)进行访问。
``		百度：静态方法只能访问静态成员，实例方法可以访问静态和实例成员。
		之所以不允许静态方法访问实例成员变量，是因为实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。同样，因为实例方法可以访问实例成员变量，如果允许静态方法调用实例方法，将间接地允许它使用实例成员变量，所以它也不能调用实例方法。基于同样的道理，静态方法中也不能使用关键字this。
		main()方法是一个典型的静态方法，它同样遵循一般静态方法的规则，所以它可以由系统在创建对象之前就调用。
		参照：https://zhidao.baidu.com/question/305017611182741684.html

    2.5)**何时用:方法的操作仅与参数相关而与对象无关**
		比如下边那个求平方根的、排序的。假设方法不是静态的，我new出对象来调是没必要的：不管谁点sort(arr)都是一个结果，不管谁点sqrt(25)都是5，只和参数(求根数、数组元素)有关。
		小敌机移动方法就不适合静态：移动和对象有关，因为和对象移动前的坐标有关。移动后每个对象的结果都不一样`小敌机------step()移动`

``		例1：求平方根
		double d = Math.sqrt(25); //静态方法
		无论m1,m2,m3,...,m100中的哪一个对象，去sqrt(25)最终的结果都是一样的，说明sqrt()的操作仅与参数有关而与对象无关
			假设sqrt()不是静态的:
		  	Math m1 = new Math();
		  	double d = m1.sqrt(25); //5
		
		  	Math m2 = new Math();
		  	double d = m2.sqrt(25); //5
		
		  	Math m3 = new Math();
		  	double d = m3.sqrt(25); //5    不管谁访问结果都是5
``		例2：排序
		Arrays.sort(arr);
		无论a1,a2,a3,...,a100中的哪一个对象，去sort(arr)最终的结果都是一样的，说明sort()的操作仅与参数相关而与对象无关
			假设sort()不是静态的:
			Arrays a1 = new Arrays();
			a1.sort(arr);
	
			Arrays a2 = new Arrays();
			a2.sort(arr);
	
			Arrays a3 = new Arrays();
			a3.sort(arr);              不管谁访问，给arr排序的结果都是一样的

3. 静态块:
    3.1)由static修饰
    3.2)属于类的，在类被加载期间自动执行，
        类只被加载一次，所以静态块只执行一次
    3.3)何时用:加载/初始化静态资源(图片、音频、视频等)//静态变量和静态块配着用，静态变量声明变量，静态块给静态变量赋值


##今日射击游戏项目相关
1. 给对象添加图片属性
	读取图片---文件IO操作---特别容易出现异常---java强制必须做异常处理

2. swing相关的:
	1)JFrame:窗口(相框)
	2)JPanel:面板(相板)


##基本认知
1. 编译器和运行期代码
	编译期:.java经编译，生成.class-----------检查语法
	运行期:JVM加载.class并运行.class---------分配对象


#--------------------------------------OOP.day06----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
###Shoot射击游戏第四天:
1. 设计超类FlyingObject，6个派生类继承超类
2. 给FlyingObject设计两个构造方法，6个派生类分别调用
3. 将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组，并测试
4. 在6个派生类中重写step()
###Shoot射击游戏第五天:
1. 画窗口
2. 给类中成员添加访问控制修饰符
3. 给对象类添加图片属性
###Shoot射击游戏第六天:
1. 设计窗口的宽和高为常量，适当地方做修改
2. 画对象:  `1+2+3 准备图片；4+5 画对象方法；6 调用画对象的方法`
  1)想画对象需要获取对象的图片，每个对象都能得图片，
    意味着得图片为共有行为，设计在FlyingObject中，
    每个对象获取图片的行为不一样，所以设计为抽象方法
    ----在FlyingObject中设计抽象方法getImage()用于获取对象的图片
  2)获取图片时需要考虑对象的状态，因为在不同状态下得的图片是不同的，
    所以需要给对象设计状态，而所有对象都有状态，
    所以将状态设计为FlyingObject中，状态一般都设计为常量
    ----在FlyingObject设计LIFE、DEAD、REMOVE，state当前状态
    获取图片时每个对象都需要判断当前状态，
    所以将判断状态的行为设计在超类中，
    每个对象判断状态的行为都是一样的，所以设计为普通方法
    ----在FlyingObject设计isLife()、isDead()、isRemove()
  3)在派生类中重写getImage()获取图片
    3.1)天空Sky，直接返回image
    3.2)子弹Bullet:
        3.2.1)若活着的，直接返回image即可
        3.2.2)若死了的，则删除
    3.3)英雄机Hero:
        3.3.1)若活着的，返回images[0]和images[1]来回切换
    3.4)小敌机Airplane:
        3.4.1)若活着的，返回images[0]
        3.4.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.5)大敌机BigAirplane:
        3.5.1)若活着的，返回images[0]
        3.5.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.6)小蜜蜂Bee:
        3.6.1)若活着的，返回images[0]
        3.6.2)若死了的，返回images[1]到images[4]轮换，4后则删除
  4)图片有了则可以开画了，每个对象都能画，
    所以画对象为共有行为，设计在FlyingObject中，
    每个对象画的方式都是一样的，所以设计为普通方法
    ----在FlyingObject中设计paintObject()画对象
  5)天空的图片需要画两张，所以重写paintObject()
    ----在Sky中重写paintObject()画对象
  6)在窗口中调用paintObject()来画对象
    ----在World中重写paint()，而后调用paintObject()


##final:最终的、不可改变的------应用率低
1. 修饰变量:变量不能被改变
2. 修饰方法:方法不能被重写
3. 修饰类:类不能被继承
`加final修饰的成员变量必须声明同时初始化

##static final常量:
1. 必须声明同时初始化
2. 通过类名点来访问，不能被改变
3. 建议:常量名所有字母都大写，多个单词用_分隔
4. 编译器在编译时将常量直接替换为具体的值，效率高
5. 何时用:数据永远不变，并且经常使用


##抽象方法:
1. 由abstract修饰
2. 只有方法的定义，没有具体的实现(连{}都没有 `没有方法体`)


##抽象类:
1. 由abstract修饰
2. 包含抽象方法的类必须是抽象类
	不包含抽象方法的类也可以声明为抽象类-----我乐意
3. 抽象类不能被实例化
4. 抽象类是需要被继承的，派生类:
	4.1)重写所有抽象方法------变不完整为完整
	4.2)也声明为抽象类--------一般不这么用
5. 抽象类的意义:
    5.1)封装派生类所共有的属性和行为-------代码复用
    5.2)为所有派生类提供了统一的类型-------向上造型
    5.3)可以包含抽象方法，为所有派生类提供统一的入口，
``		派生类的具体行为不同，但入口是一致的
`	`即：调的方法是一致的，但具体的实现的还是下边重写的逻辑


##练习:
1. 创建Person类，包含:
  1.1)成员变量:name,age,address
  1.2)构造方法:Person(3个参数){}
  1.3)方法:sayHi(){输出3个数据}
2. 创建Student类，继承Person，包含:
  2.1)成员变量:stuId
  2.2)构造方法:Student(4个参数){}
  2.3)方法:重写sayHi(){输出4个数据} 
3. 创建Teacher类，继承Person，包含:
  3.1)成员变量:salary
  3.2)构造方法:Teacher(4个参数){}
  3.3)方法:重写sayHi(){输出4个数据}
4. 创建Doctor类，继承Person，包含:
  4.1)成员变量:level
  4.2)构造方法:Doctor(4个参数){}
5. 创建Test类，main中:
  5.1)创建Person数组ps，填充数据(2个学生，2个老师，1个医生)，遍历问好



##基本认知
1. 设计规则
	1)将派生类所共有的属性和行为，抽到超类中-----抽共性
	2)所有派生类的行为都一样，设计为普通方法
	  所有派生类的行为都不一样，设计为抽象方法
	3)将部分派生类所共有的行为，抽到接口中
		符合既是也是原则时，使用接口
		接口是对继承的单根性的扩展-------实现多继承


##克晶语录
听得懂，写不出来-------------------正常的状态


#--------------------------------------OOP.day07----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
###Shoot射击游戏第四天:
1. 设计超类FlyingObject，6个派生类继承超类
2. 给FlyingObject设计两个构造方法，6个派生类分别调用
3. 将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组，并测试
4. 在6个派生类中重写step()
###Shoot射击游戏第五天:
1. 画窗口
2. 给类中成员添加访问控制修饰符
3. 给对象类添加图片属性
###Shoot射击游戏第六天:
1. 设计窗口的宽和高为常量，适当地方做修改
2. 画对象:  `1+2+3 准备图片；4+5 画对象方法；6 调用画对象的方法`
  1)想画对象需要获取对象的图片，每个对象都能得图片，
    意味着得图片为共有行为，设计在FlyingObject中，
    每个对象获取图片的行为不一样，所以设计为抽象方法
    ----在FlyingObject中设计抽象方法getImage()用于获取对象的图片
  2)获取图片时需要考虑对象的状态，因为在不同状态下得的图片是不同的，
    所以需要给对象设计状态，而所有对象都有状态，
    所以将状态设计为FlyingObject中，状态一般都设计为常量
    ----在FlyingObject设计LIFE、DEAD、REMOVE，state当前状态
    获取图片时每个对象都需要判断当前状态，
    所以将判断状态的行为设计在超类中，
    每个对象判断状态的行为都是一样的，所以设计为普通方法
    ----在FlyingObject设计isLife()、isDead()、isRemove()
  3)在派生类中重写getImage()获取图片
    3.1)天空Sky，直接返回image
    3.2)子弹Bullet:
        3.2.1)若活着的，直接返回image即可
        3.2.2)若死了的，则删除
    3.3)英雄机Hero:
        3.3.1)若活着的，返回images[0]和images[1]来回切换
    3.4)小敌机Airplane:
        3.4.1)若活着的，返回images[0]
        3.4.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.5)大敌机BigAirplane:
        3.5.1)若活着的，返回images[0]
        3.5.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.6)小蜜蜂Bee:
        3.6.1)若活着的，返回images[0]
        3.6.2)若死了的，返回images[1]到images[4]轮换，4后则删除
  4)图片有了则可以开画了，每个对象都能画，
    所以画对象为共有行为，设计在FlyingObject中，
    每个对象画的方式都是一样的，所以设计为普通方法
    ----在FlyingObject中设计paintObject()画对象
  5)天空的图片需要画两张，所以重写paintObject()
    ----在Sky中重写paintObject()画对象
  6)在窗口中调用paintObject()来画对象
    ----在World中重写paint()，而后调用paintObject()
###Shoot射击游戏第七天:
1. 敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，所以在run中调用enterAction()实现敌人入场
    在enterAction()中:
      每400毫秒，获取敌人对象，enemies扩容，将对象装到最后一个元素上
2. 子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，所以在run中调用shootAction()实现子弹入场
    在shootAction()中:
      每300毫秒，获取子弹对象，bullets扩容，数组的追加
3. 飞行物移动:
  1)飞行物移动为共有行为，所以在FlyingObject设计
    抽象方法step()，派生类分别重写
  2)飞行物移动为定时发生的，所以在run中调用stepAction()实现飞行物移动
	在stepAction()中:
		天空动，遍历敌人敌人动，遍历子弹子弹动


##成员内部类:应用率低--------了解
1. 类中套类，外面的称为Outer外部类，里面的称为Inner内部类
2. 内部类通常只服务于外部类，对外不具备可见性
3. 内部类对象通常是在外部类中创建的
4. 内部类中可以直接访问外部类的成员(包括私有的)
	内部类有个隐式的引用指向了创建它的外部类对象
	eg: 外部类名.this	`看笔记&代码


##匿名内部类:
1. 若想创建一个类(派生类)的对象，并且对象只被创建一次，此时该类不必命名，称为匿名内部类
2. jdk1.8之前，匿名内部类中访问外面的变量，要求该变量必须是final的
3. 问:内部类有独立的.class吗?---------常见面试题
    答:有		`看笔记'内部类的.class文件命名方式'


##今日射击游戏项目功能：
1. 敌人入场
2. 子弹入场
3. 飞行物移动
###实现功能思路:
1. 先写行为:
  1)若是某个对象所特有的行为，设计在具体的类中
  2)若是所有对象所共有的行为，设计在超类中
2. 页面调用:
  1)若是定时触发的，在定时器中调用
  2)若是事件触发的，在侦听器中调用

 对象行为安排
	敌人是由窗口产生的--------创建敌人对象行为设计在World类中
	子弹是由英雄机发射出来的---创建子弹对象行为设计在Hero类中
	飞行物移动为共有的行为----飞行物移动行为设计在FlyingObject类中
 定时干的事
	敌人入场
	子弹入场
	飞行物移动
	...


##基本认知
1. 程序的运行结果与你所预期的结果不同时
	1)打桩: System.out.println(数据);
	2)Debug调试:

2. paint()的调用方式有两种:
	1)frame.setVisible(true);
	2)repaint();
   `射击游戏用到的，画东西的，回头仔细去回顾然后再整理吧。

3. 数组的追加
		world.java 子弹入场
	Bullet[] bs = hero.shoot();
	bullets = Arrays.copyOf(bullets,bullets.length+bs.length);	`bs.length都是补的默认值
	System.arraycopy(bs,0,bullets,bullets.length-bs.length,bs.length); //数组的追加


#--------------------------------------OOP.day08----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
###Shoot射击游戏第四天:
1. 设计超类FlyingObject，6个派生类继承超类
2. 给FlyingObject设计两个构造方法，6个派生类分别调用
3. 将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组，并测试
4. 在6个派生类中重写step()
###Shoot射击游戏第五天:
1. 画窗口
2. 给类中成员添加访问控制修饰符
3. 给对象类添加图片属性
###Shoot射击游戏第六天:
1. 设计窗口的宽和高为常量，适当地方做修改
2. 画对象:  `1+2+3 准备图片；4+5 画对象方法；6 调用画对象的方法`
  1)想画对象需要获取对象的图片，每个对象都能得图片，
    意味着得图片为共有行为，设计在FlyingObject中，
    每个对象获取图片的行为不一样，所以设计为抽象方法
    ----在FlyingObject中设计抽象方法getImage()用于获取对象的图片
  2)获取图片时需要考虑对象的状态，因为在不同状态下得的图片是不同的，
    所以需要给对象设计状态，而所有对象都有状态，
    所以将状态设计为FlyingObject中，状态一般都设计为常量
    ----在FlyingObject设计LIFE、DEAD、REMOVE，state当前状态
    获取图片时每个对象都需要判断当前状态，
    所以将判断状态的行为设计在超类中，
    每个对象判断状态的行为都是一样的，所以设计为普通方法
    ----在FlyingObject设计isLife()、isDead()、isRemove()
  3)在派生类中重写getImage()获取图片
    3.1)天空Sky，直接返回image
    3.2)子弹Bullet:
        3.2.1)若活着的，直接返回image即可
        3.2.2)若死了的，则删除
    3.3)英雄机Hero:
        3.3.1)若活着的，返回images[0]和images[1]来回切换
    3.4)小敌机Airplane:
        3.4.1)若活着的，返回images[0]
        3.4.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.5)大敌机BigAirplane:
        3.5.1)若活着的，返回images[0]
        3.5.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.6)小蜜蜂Bee:
        3.6.1)若活着的，返回images[0]
        3.6.2)若死了的，返回images[1]到images[4]轮换，4后则删除
  4)图片有了则可以开画了，每个对象都能画，
    所以画对象为共有行为，设计在FlyingObject中，
    每个对象画的方式都是一样的，所以设计为普通方法
    ----在FlyingObject中设计paintObject()画对象
  5)天空的图片需要画两张，所以重写paintObject()
    ----在Sky中重写paintObject()画对象
  6)在窗口中调用paintObject()来画对象
    ----在World中重写paint()，而后调用paintObject()
###Shoot射击游戏第七天:
1. 敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，所以在run中调用enterAction()实现敌人入场
    在enterAction()中:
      每400毫秒，获取敌人对象，enemies扩容，将对象装到最后一个元素上
2. 子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，所以在run中调用shootAction()实现子弹入场
    在shootAction()中:
      每300毫秒，获取子弹对象，bullets扩容，数组的追加
3. 飞行物移动:
  1)飞行物移动为共有行为，所以在FlyingObject设计
    抽象方法step()，派生类分别重写
  2)飞行物移动为定时发生的，所以在run中调用stepAction()实现飞行物移动
	在stepAction()中:
		天空动，遍历敌人敌人动，遍历子弹子弹动
###Shoot射击游戏第八天:
1. 英雄机随着鼠标移动:
  1)英雄机随着鼠标动为英雄机的行为，
    所以在Hero中设计moveTo()实现英雄机随着鼠标动
  2)英雄机随着鼠标动为事件触发的，
    所以在侦听器中重写mouseMoved()鼠标移动
    在mouseMoved()中:
       获取鼠标的x和y坐标，英雄机随着动
2. 删除越界的敌人和子弹:
  1)在FlyingObject中设计outOfBounds()检测敌人是否越界
    在Bullet中重写outOfBounds()检测子弹是否越界
  2)删除越界为定时发生的，所以在run中调用outOfBoundsAction()删除越界对象
    在outOfBoundsAction()中:
      声明不越界敌人/子弹数组，遍历enemies/bullets，
      判断对象是否不越界，将不越界的装到不越界敌人/子弹数组中，
      最后将不越界敌人/子弹数组，复制到enemies/bullets中
3. 设计Enemy得分接口，Airplane和BigAirplane实现Enemy
   设计Award奖励接口，Bee实现Award


##接口:
	`看代码
1. 是一种数据类型(引用类型)
2. 由interface定义
3. 只能包含常量和抽象方法
`	`接口是完全抽象的抽象类
4. 接口不能被实例化
5. 接口是需要被实现/继承的，实现类/派生类:
      必须重写接口中的所有抽象方法
6. 一个类可以实现多个接口，用逗号隔开
    若又继承又实现时，应先继承后实现
7. 接口可以继承接口(可以继承多个接口)

 例一：
	interface Inter1{
	}
	interface Inter2{
	}
	interface Inter3 extends Inter1,Inter2{
	}

 例二：
	interface Inter1{
	  public static final int NUM = 5;
	  public abstract void show();
	  int COUNT = 5; //默认public static final
	  void test(); //默认public abstract
	
	  //int number; //编译错误，常量必须声明同时初始化
	  void say(){} //编译错误，抽象方法不能有方法体
	}


##设计规则
1. 将派生类所共有的属性和行为，抽到超类中-----抽共性
2. 所有派生类的行为都一样，设计为普通方法
	所有派生类的行为都不一样，设计为抽象方法
3. 将部分派生类所共有的行为，抽到接口中
	符合既是也是原则时，使用接口
	接口是对继承的单根性的扩展-------实现多继承


##今日射击游戏项目功能:
1. 英雄机随着鼠标移动
2. 删除越界的敌人和子弹
``		看代码和课堂笔记'处理射击游戏越界问题的两种方法'
3. 设计接口
###设计接口思路
		得分接口
	子弹打掉小敌机-----------玩家得1分
	子弹打掉大敌机-----------玩家得3分

	子弹打掉小蜜蜂-----------英雄机得奖励
	子弹打掉大黄蜂-----------英雄机得奖励、玩家得5分
 代码
	abstract class FlyingObject{
	  width,height,x,y
	  BufferedImage loadImage(String fileName){...} //读取图片
	  void paintObject(){...} //画对象
	  abstract void step(); //飞行物移动
	  abstract BufferedImage getImage(); //获取图片
	} 
	interface Enemy{ //得分接口
	  int getScore();
	}
	interface Award{ //奖励接口
	  int getAwardType();
	}
	class Bee extends FlyingObject implements Award{
	  重写getAwardType(){...}
	}
	class BigYellowBee extends FlyingObject implements Award,Enemy{
	  重写getAwardType(){...}
	  重写getScore(){...}
	}


	class Airplane extends FlyingObject implements Enemy{
	  public int getScore(){ return 1; }
	}
	class BigAirplane extends FlyingObject implements Enemy{
	  public int getScore(){ return 3; }
	}
	class Bullet extends FlyingObject{
	}
	class Hero extends FlyingObject{
	}
	class Sky extends FlyingObject{
	}
###今日射击游戏相关
1. swing相关的:
	1)事件:发生了一个事
	2)事件处理:发生事之后所做的操作
	3)侦听器:
	  3.1)有一个侦听器对象
	  3.2)把侦听器装到面板上去
2. 事件和事件处理
	  事件             事件处理
	鼠标点击        启动状态变为运行状态
	鼠标移动        英雄机随着动
	鼠标移出        运行状态变为暂停状态
	鼠标移入        暂停状态变为运行状态


##基本认知
1. 术语名词
	类和类-------------继承
	接口和接口---------继承
	类和接口-----------实现


##克晶语录
听得懂，但是写不出来--------不需要重听
听不懂我在说什么------------下个月见


#--------------------------------------OOP.day09----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
###Shoot射击游戏第四天:
1. 设计超类FlyingObject，6个派生类继承超类
2. 给FlyingObject设计两个构造方法，6个派生类分别调用
3. 将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组，并测试
4. 在6个派生类中重写step()
###Shoot射击游戏第五天:
1. 画窗口
2. 给类中成员添加访问控制修饰符
3. 给对象类添加图片属性
###Shoot射击游戏第六天:
1. 设计窗口的宽和高为常量，适当地方做修改
2. 画对象:  `1+2+3 准备图片；4+5 画对象方法；6 调用画对象的方法`
  1)想画对象需要获取对象的图片，每个对象都能得图片，
    意味着得图片为共有行为，设计在FlyingObject中，
    每个对象获取图片的行为不一样，所以设计为抽象方法
    ----在FlyingObject中设计抽象方法getImage()用于获取对象的图片
  2)获取图片时需要考虑对象的状态，因为在不同状态下得的图片是不同的，
    所以需要给对象设计状态，而所有对象都有状态，
    所以将状态设计为FlyingObject中，状态一般都设计为常量
    ----在FlyingObject设计LIFE、DEAD、REMOVE，state当前状态
    获取图片时每个对象都需要判断当前状态，
    所以将判断状态的行为设计在超类中，
    每个对象判断状态的行为都是一样的，所以设计为普通方法
    ----在FlyingObject设计isLife()、isDead()、isRemove()
  3)在派生类中重写getImage()获取图片
    3.1)天空Sky，直接返回image
    3.2)子弹Bullet:
        3.2.1)若活着的，直接返回image即可
        3.2.2)若死了的，则删除
    3.3)英雄机Hero:
        3.3.1)若活着的，返回images[0]和images[1]来回切换
    3.4)小敌机Airplane:
        3.4.1)若活着的，返回images[0]
        3.4.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.5)大敌机BigAirplane:
        3.5.1)若活着的，返回images[0]
        3.5.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.6)小蜜蜂Bee:
        3.6.1)若活着的，返回images[0]
        3.6.2)若死了的，返回images[1]到images[4]轮换，4后则删除
  4)图片有了则可以开画了，每个对象都能画，
    所以画对象为共有行为，设计在FlyingObject中，
    每个对象画的方式都是一样的，所以设计为普通方法
    ----在FlyingObject中设计paintObject()画对象
  5)天空的图片需要画两张，所以重写paintObject()
    ----在Sky中重写paintObject()画对象
  6)在窗口中调用paintObject()来画对象
    ----在World中重写paint()，而后调用paintObject()
###Shoot射击游戏第七天:
1. 敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，所以在run中调用enterAction()实现敌人入场
    在enterAction()中:
      每400毫秒，获取敌人对象，enemies扩容，将对象装到最后一个元素上
2. 子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，所以在run中调用shootAction()实现子弹入场
    在shootAction()中:
      每300毫秒，获取子弹对象，bullets扩容，数组的追加
3. 飞行物移动:
  1)飞行物移动为共有行为，所以在FlyingObject设计
    抽象方法step()，派生类分别重写
  2)飞行物移动为定时发生的，所以在run中调用stepAction()实现飞行物移动
	在stepAction()中:
		天空动，遍历敌人敌人动，遍历子弹子弹动
###Shoot射击游戏第八天:
1. 英雄机随着鼠标移动:
  1)英雄机随着鼠标动为英雄机的行为，
    所以在Hero中设计moveTo()实现英雄机随着鼠标动
  2)英雄机随着鼠标动为事件触发的，
    所以在侦听器中重写mouseMoved()鼠标移动
    在mouseMoved()中:
       获取鼠标的x和y坐标，英雄机随着动
2. 删除越界的敌人和子弹:
  1)在FlyingObject中设计outOfBounds()检测敌人是否越界
    在Bullet中重写outOfBounds()检测子弹是否越界
  2)删除越界为定时发生的，所以在run中调用outOfBoundsAction()删除越界对象
    在outOfBoundsAction()中:
      声明不越界敌人/子弹数组，遍历enemies/bullets，
      判断对象是否不越界，将不越界的装到不越界敌人/子弹数组中，
      最后将不越界敌人/子弹数组，复制到enemies/bullets中
3. 设计Enemy得分接口，Airplane和BigAirplane实现Enemy
   设计Award奖励接口，Bee实现Award
###Shoot射击游戏第九天:
1. 子弹与敌人的碰撞:
  1)在FlyingObject中设计hit()实现敌人与子弹的碰撞检测
    在FlyingObject中设计goDead()实现飞行物去死
    在Hero中设计addLife()增命、addDoubleFire()增火力
  2)子弹与敌人的碰撞为定时发生的，所以在run中调用bulletBangAction()实现子弹与敌人的碰撞
    在bulletBangAction()中:
       遍历子弹得子弹，遍历敌人得敌人，判断若撞上了:
         子弹去死、敌人去死
	 判断:
	   若被撞对象为分(Enemy)，则玩家增分
	   若被撞对象为奖励(Award)，则英雄机得奖励(命、火力值)
2. 画分和画命:
  1)在Hero中设计getLife()获取英雄机的命
  2)在paint()中: 画分和画命


##多态:
1. 意义:
    1.1)同一类型的引用在指向不同的对象时，有不同的实现
``			----**行为的多态**:cut()、run()、step()...
``			举例：cut()：
				人 p1 = new 理发师();
				人 p2 = new 外科医师();
				人 p3 = new 演员();
				p1.cut(); //剪发
				p2.cut(); //开刀
				p3.cut(); //停止表演
				
				abstract class 人{
				  abstract void cut();
				}
				class 理发师 extends 人{
				  void cut(){剪发}
				}
				class 外科医师 extends 人{
				  void cut(){开刀}
				}
				class 演员 extends 人{
				  void cut(){停止表演}
				}

``			举例：run():
				动物 o1 = new 老虎();
				动物 o2 = new 鸟();
				动物 o3 = new 鱼();
				o1.run(); //地
				o2.run(); //天
				o3.run(); //水
				
				abstract class 动物{
				  abstract void run();
				}
				class 老虎 extends 动物{
				  void run(){在地上跑}
				}
				class 鸟 extends 动物{
				  void run(){在天上飞}
				}
				class 鱼 extends 动物{
				  void run(){在水里游}
				}
    1.2)同一个对象被造型为不同的类型时，有不同的功能
``			----**对象的多态**:我、水、你...
``			举例：克晶老师：
				我 me = new 我();
				讲师      o1 = me;
				孩子他妈   o2 = me;
				老公的老婆 o3 = me;
				o1.授课();
				o2.揍他();
				o3.咬他();
				o3.收工资();
				me.授课();
				me.揍他();
				me.咬他();
				me.收工资();
				
				interface 讲师{
				  void 授课();
				}
				interface 孩子他妈{
				  void 揍他();
				}
				interface 老公的老婆{
				  void 咬他();
				  void 收工资();
				}
				class 我 implements 讲师,孩子他妈,老公的老婆{
				  public void 授课(){}
				  public void 揍他(){}
				  public void 咬他(){}
				  public void 收工资(){}
				}
2. 向上造型/自动类型转换:		`小到大`
    2.1)超类型的引用指向派生类的对象
    2.2)能造型成为的类型有: 超类+所实现的接口
    2.3)能点出来什么，看引用的类型
3. 强制类型转换	`大到小。我认为说大到小不严谨，因为我认为这第二种强转的两个类型没有大小之分。然后我又问了克晶老师，它说不必太纠结大小，它只是用大小来引入强转这个概念`
``	**看代码&笔记'多态之类型转换'**
   3.1)引用类型强制转换，成功的条件只有如下两种:
		3.1.1)引用指向的对象，就是该类型
		3.1.2)引用指向的对象，实现了该接口或继承了该类
   3.2)基本类型的强转一定会成功，但是可能会丢精度。---看Basic笔记'基本数据类型间的转换:'
4. 强转若不符合如上两个条件，则发生ClassCastException类型转换异常
``	建议:为避免异常/溢出,强转之前先通过instanceof来判断引用的对象是否是该类型
``	**看代码'典型的ClassCastException异常'**

`克晶老师：**如果想访问的东西在当前的类型中没有，就只能类型转换成有你想要的数据的类型！**


##今日射击游戏项目相关
1. 多态的应用
	子弹与敌人的碰撞:
	英雄机与敌人的碰撞:
	class FlyingObject{
	  //敌人撞子弹/英雄机
	  public boolean hit(? other){
	    this:敌人
	    other:子弹/英雄机
	  }
	}
 ?处设计为什么类型：既能接收子弹对象，也能接收英雄机对象
``									向上造型------FlyingObject

2. 子弹与敌人的碰撞处理:
	若撞上了:
	1)子弹去死(DEAD)、敌人去死(DEAD)
	2)小敌机和大敌机--玩家得分
``	  小蜜蜂---------英雄机得1命或40火力值


#--------------------------------------OOP.day10----------------------------------------

##课程回顾
	......

###Shoot射击游戏第一天:
1. 创建了6个对象类，创建World类测试
###Shoot射击游戏第二天:
1. 给6个对象类添加了构造方法，并测试
###Shoot射击游戏第三天:
1. 设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
###Shoot射击游戏第四天:
1. 设计超类FlyingObject，6个派生类继承超类
2. 给FlyingObject设计两个构造方法，6个派生类分别调用
3. 将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组，并测试
4. 在6个派生类中重写step()
###Shoot射击游戏第五天:
1. 画窗口
2. 给类中成员添加访问控制修饰符
3. 给对象类添加图片属性
###Shoot射击游戏第六天:
1. 设计窗口的宽和高为常量，适当地方做修改
2. 画对象:  `1+2+3 准备图片；4+5 画对象方法；6 调用画对象的方法`
  1)想画对象需要获取对象的图片，每个对象都能得图片，
    意味着得图片为共有行为，设计在FlyingObject中，
    每个对象获取图片的行为不一样，所以设计为抽象方法
    ----在FlyingObject中设计抽象方法getImage()用于获取对象的图片
  2)获取图片时需要考虑对象的状态，因为在不同状态下得的图片是不同的，
    所以需要给对象设计状态，而所有对象都有状态，
    所以将状态设计为FlyingObject中，状态一般都设计为常量
    ----在FlyingObject设计LIFE、DEAD、REMOVE，state当前状态
    获取图片时每个对象都需要判断当前状态，
    所以将判断状态的行为设计在超类中，
    每个对象判断状态的行为都是一样的，所以设计为普通方法
    ----在FlyingObject设计isLife()、isDead()、isRemove()
  3)在派生类中重写getImage()获取图片
    3.1)天空Sky，直接返回image
    3.2)子弹Bullet:
        3.2.1)若活着的，直接返回image即可
        3.2.2)若死了的，则删除
    3.3)英雄机Hero:
        3.3.1)若活着的，返回images[0]和images[1]来回切换
    3.4)小敌机Airplane:
        3.4.1)若活着的，返回images[0]
        3.4.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.5)大敌机BigAirplane:
        3.5.1)若活着的，返回images[0]
        3.5.2)若死了的，返回images[1]到images[4]轮换，4后则删除
    3.6)小蜜蜂Bee:
        3.6.1)若活着的，返回images[0]
        3.6.2)若死了的，返回images[1]到images[4]轮换，4后则删除
  4)图片有了则可以开画了，每个对象都能画，
    所以画对象为共有行为，设计在FlyingObject中，
    每个对象画的方式都是一样的，所以设计为普通方法
    ----在FlyingObject中设计paintObject()画对象
  5)天空的图片需要画两张，所以重写paintObject()
    ----在Sky中重写paintObject()画对象
  6)在窗口中调用paintObject()来画对象
    ----在World中重写paint()，而后调用paintObject()
###Shoot射击游戏第七天:
1. 敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，所以在run中调用enterAction()实现敌人入场
    在enterAction()中:
      每400毫秒，获取敌人对象，enemies扩容，将对象装到最后一个元素上
2. 子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，所以在run中调用shootAction()实现子弹入场
    在shootAction()中:
      每300毫秒，获取子弹对象，bullets扩容，数组的追加
3. 飞行物移动:
  1)飞行物移动为共有行为，所以在FlyingObject设计
    抽象方法step()，派生类分别重写
  2)飞行物移动为定时发生的，所以在run中调用stepAction()实现飞行物移动
	在stepAction()中:
		天空动，遍历敌人敌人动，遍历子弹子弹动
###Shoot射击游戏第八天:
1. 英雄机随着鼠标移动:
  1)英雄机随着鼠标动为英雄机的行为，
    所以在Hero中设计moveTo()实现英雄机随着鼠标动
  2)英雄机随着鼠标动为事件触发的，
    所以在侦听器中重写mouseMoved()鼠标移动
    在mouseMoved()中:
       获取鼠标的x和y坐标，英雄机随着动
2. 删除越界的敌人和子弹:
  1)在FlyingObject中设计outOfBounds()检测敌人是否越界
    在Bullet中重写outOfBounds()检测子弹是否越界
  2)删除越界为定时发生的，所以在run中调用outOfBoundsAction()删除越界对象
    在outOfBoundsAction()中:
      声明不越界敌人/子弹数组，遍历enemies/bullets，
      判断对象是否不越界，将不越界的装到不越界敌人/子弹数组中，
      最后将不越界敌人/子弹数组，复制到enemies/bullets中
3. 设计Enemy得分接口，Airplane和BigAirplane实现Enemy
   设计Award奖励接口，Bee实现Award
###Shoot射击游戏第九天:
1. 子弹与敌人的碰撞:
  1)在FlyingObject中设计hit()实现敌人与子弹的碰撞检测
    在FlyingObject中设计goDead()实现飞行物去死
    在Hero中设计addLife()增命、addDoubleFire()增火力
  2)子弹与敌人的碰撞为定时发生的，所以在run中调用bulletBangAction()实现子弹与敌人的碰撞
    在bulletBangAction()中:
       遍历子弹得子弹，遍历敌人得敌人，判断若撞上了:
         子弹去死、敌人去死
	 判断:
	   若被撞对象为分(Enemy)，则玩家增分
	   若被撞对象为奖励(Award)，则英雄机得奖励(命、火力值)
2. 画分和画命:
  1)在Hero中设计getLife()获取英雄机的命
  2)在paint()中: 画分和画命
###Shoot射击游戏第十天:
1. 英雄机与敌人的碰撞:
  1)借用FlyingObject的hit()碰撞检测、goDead()飞行物去死
    在Hero中设计subtractLife()减命、clearDoubleFire()清空火力值
  2)英雄机与敌人的碰撞为定时发生的，在run中调用heroBangAction()实现英雄机与敌人的碰撞
    在heroBangAction()中:
      遍历敌人得敌人，判断若撞上了:
        敌人去死、英雄机减命、英雄机清空火力值
2. 检测游戏结束:
  1)借用Hero中的getLife()获取命数
  2)检测游戏结束为定时发生的，在run中调用checkGameOverAction()检测游戏结束
    在checkGameOverAction()中:
      判断若英雄机命数<=0，则将当前状态修改为GAME_OVER
3. 画状态:
  1)在World中设计4个状态常量START、RUNNING、PAUSE、GAME_OVER，state(当前状态)
    在World中设计3个静态图片start、pause、gameover
    在paint()中，设置在不同状态下画不同的图片
  2)将run中的那一堆action，设计为只在运行状态下才执行
    将mouseMoved()中英雄机随着鼠标动，设计为只在运行状态下才执行
  3)重写mouseClicked()鼠标点击:
      启动状态变为运行状态
      游戏结束状态清理现场再变为启动状态
    重写mouseExited()鼠标移动: 运行状态变为暂停状态
    重写mouseEntered()鼠标移入: 暂停状态变为运行状态


##内存管理:
		看图
1. 堆:
    1.1)存储new出来的对象(包括实例变量)
    1.2)垃圾:没有任何引用所指向的对象
``		垃圾回收器(GC)不定时到内存中清扫垃圾，
``		回收过程是透明的(看不到的)，
``		不一定一发现垃圾就立刻回收
``		调用System.gc()可以建议虚拟机尽快调度GC来回收
    1.3)内存泄漏:不再使用的对象还没有被及时的回收
``		建议:不再使用的对象要及时将引用设置为null
    1.4)实例变量的生命周期:
``		创建对象时存储在堆中，对象被回收时一并被回收
2. 栈:
    2.1)存储的是正在调用的方法中的局部变量(包括方法参数)
    2.2)调用方法时为该方法分配一块对应的栈帧，
``		栈帧中存储方法中的局部变量(包括方法的参数)，
``		当方法调用结束时，栈帧被清除，局部变量一并被清除
    2.3)局部变量的生命周期:
``		方法被调用时存储在栈中，方法执行结束与栈帧一并被清除
3. 方法区:
    3.1)存储.class字节码文件(包括静态变量、方法)
    3.2)方法只有一份，通过this来区分具体的调用对象
###`实例变量&局部变量区别：
 - 实例变量:
``	1)类中、方法外
``	2)创建对象时存储在堆中，对象被回收时一并被回收
``	3)**有默认值**
 - 局部变量:
``	1)方法中
``	2)方法被调用时存储在栈中，方法执行结束与栈帧一并被清除
``	3)没有默认值
 - 例：
		Aoo o = new Aoo();-------------a=0
		o.show(6);---------------------b=6
		
		class Aoo{
		  int a;
		  void show(int b){
		    int c;
		    System.out.println(a); //0
		    System.out.println(b); //6
		    System.out.println(c); //编译错误
		  }
		}
###`堆&栈均可放基本类型&引用类型
 - 堆中放实例变量(基本类型、引用类型)
 - 栈中放局部变量(基本类型、引用类型)
 - 例：
	class Aoo{
	  Airplane a = new Airplane(); //堆
	  int num = 5;                 //堆
	  void show(){
	    Airplane aa = new Airplane(); //栈
	    int numnum = 5;               //栈
	  }
	}


##面向对象三大特征:----------常见面试题
1. 封装:
    1.1)类:封装的是对象的属性和行为
    1.2)方法:封装具体的业务逻辑功能实现
    1.3)访问控制修饰符:封装的是访问的权限
2. 继承:
    2.1)作用:代码复用
    2.2)超类:所有派生类所共有的属性和行为
``		接口:部分派生类所共有的行为
``		派生类:派生类所特有的属性和行为
    2.3)传递性，单一继承、多接口实现
3. 多态:
    3.1)行为的多态(所有抽象方法都是多态的)
``		对象的多态(所有对象都是多态的)
    3.2)向上造型、强制类型转换、instanceof判断
    3.3)多态的表现形式:
``		3.3.1)重写:根据对象的不同来表现多态
``		3.3.2)重载:根据参数的不同来表现多态


##当程序的运行结果与你所预期的结果不同时:
1. 打桩: System.out.println(数据);
2. Debug调试工具:----**先添加断点**
  2.1)掌握四个键:
      2.1.1)F5:单步调试(会进入到方法中)
      2.1.2)F6:逐过程调试(不会进入到方法中)
      2.1.3)F7:跳出方法的执行
      2.1.4)F8:直接跳到下一个断点(若后面无断点则结束调试)
  2.2)会看两个东西:
      2.2.1)会看变量
      2.2.2)会添加监视(选中表达式--右键Watch)


##基本认知：
1. 所有对象都是多态的:	
	Object是鼻祖，每个对象最少具备两种形态，自己和Object
	Hero o1 = new Hero();
	FlyingObject o2 = new Hero();
	Object o3 = new Hero();

	Airplane o1 = new Airplane();
	FlyingObject o2 = new Airplane();
	Enemy o3 = new Airplane();
	Object o4 = new Airplane();

	Aoo o1 = new Aoo();
	Object o2 = new Aoo();

	Boo o1 = new Boo();
	Object o2 = new Boo();


##面向对象课程安排：
  第一天:
    理论:
      1.什么是类？什么是对象？
      2.如何创建类？如何创建对象？如何访问成员？
    项目:
      3.创建了6个对象类，创建World类并测试
  第二天:
    理论:
      1.方法的重载:
      2.构造方法:
      3.this:
      5.null和NullPointerException
      6.引用类型之间画等号:
    项目:
      4.给6个对象类添加构造方法，并测试
  第三天:
    理论:
      1.引用类型数组:
      3.继承:
      5.super:
    项目:
      2.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
      4.创建超类FlyingObject，6个对象类继承超类
      6.给FlyingObject设计两个构造方法，6个对象类分别调用
  第四天:
    理论:
      1.向上造型:
      3.方法的重写:
      5.重写与重载的区别:
    项目:
      2.将小敌机、大敌机、小蜜蜂数组合为FlyingObject数，并测试
      4.在派生类中重写step()
      6.画窗口
  第五天:
    理论:
      1.package和import
      2.访问控制修饰符
      4.final
      5.static
    项目:
      3.给所有类中的成员添加访问控制修饰符
      6.给对象类添加图片属性
  第六天:
    理论:
      1.static final常量:
      3.抽象方法:
      4.抽象类:
    项目:
      2.设计窗口的宽和高为常量，适当地方做修改
      5.画对象
  第七天:
    理论:
      1.成员内部类
      2.匿名内部类
    项目:
      3.敌人入场
      4.子弹入场
      5.飞行物移动
  第八天:
    理论:
      3.接口
    项目:
      1.英雄机随着鼠标移动
      2.删除越界的敌人和子弹
  第九天:
    理论:
      1.多态
    项目:
      2.子弹与敌人的碰撞
      3.画分和画命
  第十天:
    理论:
      1.内存管理
    项目:
      2.英雄机与敌人的碰撞
      3.检测游戏结束
      4.画状态


